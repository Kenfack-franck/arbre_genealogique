Project Context From: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique
Generated On: lun. 26 mai 2025 09:00:41 WAT
===============================================
Ignored Directory Patterns: .* node_modules vendor build dist target __pycache__ .next cache target venv storage
Ignored File Patterns: *.log *.jar *.pdf *.png *.jpg *.class *.sqlite *.csv project_context.txt package-lock.json yarn.lock composer.lock *.ico pnpm-lock.yaml
===============================================

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/eslint.config.mjs

import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
];

export default eslintConfig;
// END OF FILE: eslint.config.mjs

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/.gitignore

# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
// END OF FILE: .gitignore

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/next.config.ts

import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;
// END OF FILE: next.config.ts

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/package.json

{
  "name": "arbre_genealogique",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "next": "15.2.3",
    "react": "^19.0.0",

    "react-dom": "^19.0.0",
    "tailwindcss": "^3.4.3"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4.0.17",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "autoprefixer": "^10.4.21",
    "eslint": "^9",
    "eslint-config-next": "15.2.3",
    "postcss": "^8.5.1",
    "typescript": "^5"
  }
}
// END OF FILE: package.json

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/postcss.config.js

module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
// END OF FILE: postcss.config.js

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/postcss.config.mjs

const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;
// END OF FILE: postcss.config.mjs

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/public/file.svg

[Non-text file (e.g., binary, data, compressed) - Contents omitted]
// END OF FILE: public/file.svg

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/public/globe.svg

[Non-text file (e.g., binary, data, compressed) - Contents omitted]
// END OF FILE: public/globe.svg

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/public/images (1).jpeg

[Non-text file (e.g., binary, data, compressed) - Contents omitted]
// END OF FILE: public/images (1).jpeg

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/public/images.jpeg

[Non-text file (e.g., binary, data, compressed) - Contents omitted]
// END OF FILE: public/images.jpeg

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/public/next.svg

[Non-text file (e.g., binary, data, compressed) - Contents omitted]
// END OF FILE: public/next.svg

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/public/vercel.svg

[Non-text file (e.g., binary, data, compressed) - Contents omitted]
// END OF FILE: public/vercel.svg

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/public/window.svg

[Non-text file (e.g., binary, data, compressed) - Contents omitted]
// END OF FILE: public/window.svg

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/README.md

This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.
// END OF FILE: README.md

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/api/auth/login/route.ts

// END OF FILE: src/api/auth/login/route.ts

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/api/auth/register/route.ts

// END OF FILE: src/api/auth/register/route.ts

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/api/family/route.ts

// END OF FILE: src/api/family/route.ts

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/api/person/route.ts

// END OF FILE: src/api/person/route.ts

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/app/auth/login/page.tsx

// END OF FILE: src/app/auth/login/page.tsx

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/app/auth/register/page.tsx

// END OF FILE: src/app/auth/register/page.tsx

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/app/dashboard/page.tsx

// END OF FILE: src/app/dashboard/page.tsx

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/app/family/[id]/edit/page.tsx

// src/app/family/new/page.tsx et src/app/family/[id]/edit/page.tsx
'use client';

import React, { useState, useEffect } from 'react';
import { useParams, useRouter } from 'next/navigation';
import Link from 'next/link';
import { useFamily } from '@/context/FamilyContext';
import { Family } from '@/lib/models/Families';

export default function FamilyFormPage() {
  const params = useParams();
  const router = useRouter();
  const { families, loading, addFamily, updateFamily } = useFamily();
  const [isNew, setIsNew] = useState(true);
  const [formData, setFormData] = useState({
    name: '',
    description: ''
  });
  const [errors, setErrors] = useState<Record<string, string>>({});
  const [isSaving, setIsSaving] = useState(false);

  // Déterminer si c'est un ajout ou une modification
  useEffect(() => {
    const id = params?.id;
    setIsNew(!id);
    
    if (!isNew && !loading && id) {
      // Trouver la famille à modifier
      const family = families.find(f => f.id === id);
      
      if (family) {
        setFormData({
          name: family.name,
          description: family.description
        });
      } else {
        // Famille non trouvée, rediriger
        router.push('/family');
      }
    }
  }, [params, families, loading, isNew, router]);

  // Gestionnaire de changement de champ
  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    const { name, value } = e.target;
    
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
    
    // Effacer l'erreur si elle existe
    if (errors[name]) {
      setErrors(prev => {
        const newErrors = { ...prev };
        delete newErrors[name];
        return newErrors;
      });
    }
  };

  // Validation du formulaire
  const validateForm = (): boolean => {
    const newErrors: Record<string, string> = {};
    
    if (!formData.name?.trim()) {
      newErrors.name = "Le nom de l'arbre généalogique est requis";
    }
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  // Soumission du formulaire
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!validateForm()) return;
    
    setIsSaving(true);
    
    try {
      if (isNew) {
        // Création d'un nouvel arbre généalogique
        const newFamily: Family = {
          id: `family-${Date.now()}`,
          name: formData.name,
          description: formData.description,
          persons: [],
          relationships: [],
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString()
        };
        
        await addFamily(newFamily);
        
        // Rediriger vers la page de l'arbre
        router.push(`/family/${newFamily.id}`);
      } else if (params?.id) {
        // Mise à jour de l'arbre existant
        await updateFamily(params.id as string, {
          name: formData.name,
          description: formData.description
        });
        
        // Rediriger vers la page de l'arbre
        router.push(`/family/${params.id}`);
      }
    } catch (error) {
      console.error('Erreur lors de la sauvegarde:', error);
      setErrors(prev => ({
        ...prev,
        submit: "Une erreur est survenue lors de la sauvegarde"
      }));
    } finally {
      setIsSaving(false);
    }
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="text-center">
          <h2 className="text-xl font-semibold mb-2">Chargement des données...</h2>
          <div className="w-12 h-12 border-4 border-t-blue-500 border-b-blue-700 rounded-full animate-spin mx-auto"></div>
        </div>
      </div>
    );
  }

  return (
    <div className="container mx-auto px-4 py-8">
      <div className="mb-6">
        <Link href={isNew ? "/family" : `/family/${params?.id}`} className="text-blue-600 hover:underline inline-flex items-center">
          <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor">
            <path fillRule="evenodd" d="M9.707 14.707a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 1.414L7.414 9H15a1 1 0 110 2H7.414l2.293 2.293a1 1 0 010 1.414z" clipRule="evenodd" />
          </svg>
          Retour
        </Link>
      </div>
      
      <div className="bg-white rounded-lg shadow-md p-6">
        <h1 className="text-2xl font-bold mb-6">
          {isNew ? "Créer un nouvel arbre généalogique" : `Modifier ${formData.name}`}
        </h1>
        
        <form onSubmit={handleSubmit}>
          {errors.submit && (
            <div className="mb-6 bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded">
              {errors.submit}
            </div>
          )}
          
          <div className="mb-6">
            <label htmlFor="name" className="form-label">
              Nom de l'arbre généalogique <span className="text-red-500">*</span>
            </label>
            <input
              type="text"
              id="name"
              name="name"
              value={formData.name}
              onChange={handleChange}
              className={`form-input ${errors.name ? 'border-red-500 ring-1 ring-red-500' : ''}`}
              placeholder="Ex: Famille Dupont"
              required
            />
            {errors.name && (
              <p className="text-red-500 text-sm mt-1">{errors.name}</p>
            )}
          </div>
          
          <div className="mb-6">
            <label htmlFor="description" className="form-label">
              Description
            </label>
            <textarea
              id="description"
              name="description"
              value={formData.description}
              onChange={handleChange}
              className="form-input"
              rows={4}
              placeholder="Description optionnelle de l'arbre généalogique"
            />
          </div>
          
          <div className="flex justify-end gap-4 mt-8">
            <Link 
              href={isNew ? "/family" : `/family/${params?.id}`}
              className="btn btn-secondary"
            >
              Annuler
            </Link>
            
            <button
              type="submit"
              className="btn btn-primary"
              disabled={isSaving}
            >
              {isSaving ? (
                <>
                  <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                  <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                  </svg>
                  Enregistrement...
                </>
              ) : (
                isNew ? 'Créer l\'arbre' : 'Enregistrer les modifications'
              )}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
}// END OF FILE: src/app/family/[id]/edit/page.tsx

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/app/family/[id]/page.tsx

// src/app/family/[id]/page.tsx
'use client';

import React, { useState, useEffect } from 'react';
import { useParams, useRouter } from 'next/navigation';
import Link from 'next/link';
import { useFamily } from '@/context/FamilyContext';
import { Person } from '../../../lib/models/Person';
import { calculateAge } from '../../../lib/utils/dateUtils';

export default function FamilyDetailPage() {
  const params = useParams();
  const router = useRouter();
  const { familyTree, loading } = useFamily();
  const [familyName, setFamilyName] = useState('');
  const [rootPerson, setRootPerson] = useState<Person | null>(null);
  const [stats, setStats] = useState({
    totalPersons: 0,
    maleCount: 0,
    femaleCount: 0,
    otherCount: 0,
    livingCount: 0,
    deceasedCount: 0,
    oldestPerson: null as Person | null,
    youngestPerson: null as Person | null,
    averageAge: 0
  });

  // Charger les données de la famille
  useEffect(() => {
    if (!loading && familyTree) {
      // Dans cette version simplifiée, nous considérons qu'il n'y a qu'une seule famille
      setFamilyName(familyTree.metadata.nom);
      
      // Calcul des statistiques
      const persons = familyTree.persons;
      
      // Compter les personnes par sexe et état
      const maleCount = persons.filter(p => p.sexe === 'M').length;
      const femaleCount = persons.filter(p => p.sexe === 'F').length;
      const otherCount = persons.filter(p => p.sexe === 'A').length;
      const livingCount = persons.filter(p => p.etat === 'vivant').length;
      const deceasedCount = persons.filter(p => p.etat === 'mort').length;
      
      // Trouver la personne la plus âgée et la plus jeune (parmi les vivants)
      const personsWithBirthDate = persons.filter(p => p.birthDate);
      
      let oldestPerson = null;
      let youngestPerson = null;
      
      if (personsWithBirthDate.length > 0) {
        oldestPerson = personsWithBirthDate.reduce((oldest, current) => {
          if (!oldest.birthDate) return current;
          if (!current.birthDate) return oldest;
          
          return new Date(oldest.birthDate) < new Date(current.birthDate) ? oldest : current;
        });
        
        youngestPerson = personsWithBirthDate.reduce((youngest, current) => {
          if (!youngest.birthDate) return current;
          if (!current.birthDate) return youngest;
          
          return new Date(youngest.birthDate) > new Date(current.birthDate) ? youngest : current;
        });
      }
      
      // Calculer l'âge moyen
      let totalAge = 0;
      let countWithAge = 0;
      
      for (const person of personsWithBirthDate) {
        if (person.birthDate) {
          const birthDate = new Date(person.birthDate);
          const endDate = person.etat === 'mort' && person.deathDate 
            ? new Date(person.deathDate) 
            : new Date();
          
          const ageMs = endDate.getTime() - birthDate.getTime();
          const ageDate = new Date(ageMs);
          const age = Math.abs(ageDate.getUTCFullYear() - 1970);
          
          totalAge += age;
          countWithAge++;
        }
      }
      
      const averageAge = countWithAge > 0 ? Math.round(totalAge / countWithAge) : 0;
      
      // Déterminer la personne racine (celle avec le plus de relations)
      if (persons.length > 0) {
        const personRelationsCount = persons.map(person => {
          const relationsCount = familyTree.relationships.filter(
            rel => rel.sourceId === person.id || rel.targetId === person.id
          ).length;
          
          return { person, relationsCount };
        });
        
        const mostConnectedPerson = personRelationsCount.reduce((most, current) => 
          current.relationsCount > most.relationsCount ? current : most
        );
        
        setRootPerson(mostConnectedPerson.person);
      }
      
      // Mettre à jour les statistiques
      setStats({
        totalPersons: persons.length,
        maleCount,
        femaleCount,
        otherCount,
        livingCount,
        deceasedCount,
        oldestPerson,
        youngestPerson,
        averageAge
      });
    }
  }, [familyTree, loading]);

  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="text-center">
          <h2 className="text-xl font-semibold mb-2">Chargement des données...</h2>
          <div className="w-12 h-12 border-4 border-t-blue-500 border-b-blue-700 rounded-full animate-spin mx-auto"></div>
        </div>
      </div>
    );
  }

  return (
    <div className="container mx-auto px-4 py-8">
      <div className="mb-6">
        <Link href="/family" className="text-blue-600 hover:underline inline-flex items-center">
          <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor">
            <path fillRule="evenodd" d="M9.707 14.707a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 1.414L7.414 9H15a1 1 0 110 2H7.414l2.293 2.293a1 1 0 010 1.414z" clipRule="evenodd" />
          </svg>
          Retour à la liste des familles
        </Link>
      </div>
      
      <div className="flex flex-col md:flex-row md:justify-between md:items-start mb-8">
        <div>
          <h1 className="text-3xl font-bold mb-2">
            {familyName}
          </h1>
          <p className="text-gray-600">
            Dernière mise à jour: {familyTree && new Date(familyTree.metadata.dateMiseAJour).toLocaleDateString()}
          </p>
        </div>
        
        <div className="mt-4 md:mt-0 flex flex-wrap gap-3">
          <Link 
            href={`/family/${params.id}/edit`} 
            className="btn btn-primary inline-flex items-center"
          >
            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
              <path d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z" />
            </svg>
            Modifier
          </Link>
          
          <Link 
            href={`/family/${params.id}/tree`} 
            className="btn btn-secondary inline-flex items-center"
          >
            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
              <path d="M7 3a1 1 0 000 2h6a1 1 0 100-2H7zM4 7a1 1 0 011-1h10a1 1 0 110 2H5a1 1 0 01-1-1zM2 11a2 2 0 012-2h12a2 2 0 012 2v4a2 2 0 01-2 2H4a2 2 0 01-2-2v-4z" />
            </svg>
            Voir larbre complet
          </Link>
        </div>
      </div>
      
      <div className="grid grid-cols-1 md:grid-cols-3 gap-8">
        {/* Statistiques */}
        <div className="bg-white rounded-lg shadow-md p-6">
          <h2 className="text-xl font-semibold mb-4 border-b pb-2">Statistiques</h2>
          
          <dl className="space-y-3">
            <div>
              <dt className="text-sm font-medium text-gray-500">Nombre total de personnes</dt>
              <dd className="mt-1 text-2xl text-gray-900">{stats.totalPersons}</dd>
            </div>
            
            <div>
              <dt className="text-sm font-medium text-gray-500">Répartition par sexe</dt>
              <dd className="mt-1">
                <div className="flex gap-2">
                  <span className="bg-blue-100 text-blue-800 text-xs font-medium px-2 py-1 rounded">
                    Hommes: {stats.maleCount}
                  </span>
                  <span className="bg-pink-100 text-pink-800 text-xs font-medium px-2 py-1 rounded">
                    Femmes: {stats.femaleCount}
                  </span>
                  {stats.otherCount > 0 && (
                    <span className="bg-purple-100 text-purple-800 text-xs font-medium px-2 py-1 rounded">
                      Autre: {stats.otherCount}
                    </span>
                  )}
                </div>
              </dd>
            </div>
            
            <div>
              <dt className="text-sm font-medium text-gray-500">Vivants / Décédés</dt>
              <dd className="mt-1">
                <div className="flex gap-2">
                  <span className="bg-green-100 text-green-800 text-xs font-medium px-2 py-1 rounded">
                    Vivants: {stats.livingCount}
                  </span>
                  <span className="bg-gray-100 text-gray-800 text-xs font-medium px-2 py-1 rounded">
                    Décédés: {stats.deceasedCount}
                  </span>
                </div>
              </dd>
            </div>
            
            <div>
              <dt className="text-sm font-medium text-gray-500">Âge moyen</dt>
              <dd className="mt-1 text-gray-900">{stats.averageAge} ans</dd>
            </div>
            
            {stats.oldestPerson && (
              <div>
                <dt className="text-sm font-medium text-gray-500">Personne la plus âgée</dt>
                <dd className="mt-1">
                  <Link href={`/person/${stats.oldestPerson.id}`} className="text-blue-600 hover:underline">
                    {stats.oldestPerson.prenom} {stats.oldestPerson.nom}
                  </Link>
                  {stats.oldestPerson.birthDate && (
                    <span className="text-sm text-gray-500 ml-2">
                      ({calculateAge(stats.oldestPerson)} ans)
                    </span>
                  )}
                </dd>
              </div>
            )}
            
            {stats.youngestPerson && (
              <div>
                <dt className="text-sm font-medium text-gray-500">Personne la plus jeune</dt>
                <dd className="mt-1">
                  <Link href={`/person/${stats.youngestPerson.id}`} className="text-blue-600 hover:underline">
                    {stats.youngestPerson.prenom} {stats.youngestPerson.nom}
                  </Link>
                  {stats.youngestPerson.birthDate && (
                    <span className="text-sm text-gray-500 ml-2">
                      ({calculateAge(stats.youngestPerson)} ans)
                    </span>
                  )}
                </dd>
              </div>
            )}
          </dl>
        </div>
        
        {/* Membres récents */}
        <div className="bg-white rounded-lg shadow-md p-6 md:col-span-2">
          <h2 className="text-xl font-semibold mb-4 border-b pb-2">Membres récents</h2>
          
          {familyTree && familyTree.persons.length > 0 ? (
            <ul className="divide-y">
              {familyTree.persons
                .slice(-5) // Afficher les 5 dernières personnes
                .map(person => (
                  <li key={person.id} className="py-3">
                    <Link href={`/person/${person.id}`} className="flex items-center hover:bg-gray-50 p-2 rounded">
                      <div className={`w-10 h-10 rounded-full flex items-center justify-center mr-3 ${
                        person.sexe === 'M' ? 'bg-blue-100 text-blue-800' : 
                        person.sexe === 'F' ? 'bg-pink-100 text-pink-800' : 
                        'bg-purple-100 text-purple-800'
                      }`}>
                        {person.prenom.charAt(0)}
                      </div>
                      <div>
                        <p className="font-medium">{person.prenom} {person.nom}</p>
                        <p className="text-sm text-gray-500">
                          {person.birthDate ? new Date(person.birthDate).getFullYear() : "?"} - 
                          {person.deathDate ? new Date(person.deathDate).getFullYear() : person.etat === "vivant" ? "présent" : "?"}
                        </p>
                      </div>
                    </Link>
                  </li>
                ))}
            </ul>
          ) : (
            <p className="text-gray-500 italic">Aucune personne dans larbre généalogique.</p>
          )}
          
          <div className="mt-6 flex justify-between items-center">
            <Link href="/person" className="text-blue-600 hover:underline text-sm">
              Voir toutes les personnes →
            </Link>
            
            <Link href="/person/new" className="btn btn-primary">
              Ajouter une personne
            </Link>
          </div>
        </div>
      </div>
      
      {/* Suggestions et actions */}
      <div className="mt-8 grid grid-cols-1 md:grid-cols-2 gap-8">
        <div className="bg-white rounded-lg shadow-md p-6">
          <h2 className="text-xl font-semibold mb-4 border-b pb-2">Racine de larbre</h2>
          
          {rootPerson ? (
            <div>
              <div className="flex items-center mb-4">
                <div className={`w-12 h-12 rounded-full flex items-center justify-center mr-4 ${
                  rootPerson.sexe === 'M' ? 'bg-blue-100 text-blue-800' : 
                  rootPerson.sexe === 'F' ? 'bg-pink-100 text-pink-800' : 
                  'bg-purple-100 text-purple-800'
                }`}>
                  {rootPerson.prenom.charAt(0)}
                </div>
                <div>
                  <p className="font-medium">{rootPerson.prenom} {rootPerson.nom}</p>
                  <p className="text-sm text-gray-500">
                    Personne centrale de larbre
                  </p>
                </div>
              </div>
              
              <p className="mb-4 text-gray-600">
                Cette personne est actuellement utilisée comme point de départ pour visualiser larbre généalogique.
              </p>
              
              <div className="flex gap-3">
                <Link 
                  href={`/person/${rootPerson.id}`} 
                  className="btn btn-secondary inline-block"
                >
                  Voir le profil
                </Link>
                <Link 
                  href={`/family/${params.id}/tree?root=${rootPerson.id}`} 
                  className="btn btn-primary inline-block"
                >
                  Voir larbre centré
                </Link>
              </div>
            </div>
          ) : (
            <p className="text-gray-500 italic">Aucune personne racine définie.</p>
          )}
        </div>
        
        <div className="bg-white rounded-lg shadow-md p-6">
          <h2 className="text-xl font-semibold mb-4 border-b pb-2">Actions rapides</h2>
          
          <ul className="space-y-3">
            <li>
              <Link href="/person/new" className="flex items-center text-blue-600 hover:underline">
                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                  <path fillRule="evenodd" d="M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z" clipRule="evenodd" />
                </svg>
                Ajouter une nouvelle personne
              </Link>
            </li>
            <li>
              <Link href="/relationship/new" className="flex items-center text-blue-600 hover:underline">
                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                  <path d="M9 6a3 3 0 11-6 0 3 3 0 016 0zM17 6a3 3 0 11-6 0 3 3 0 016 0zM12.93 17c.046-.327.07-.66.07-1a6.97 6.97 0 00-1.5-4.33A5 5 0 0119 16v1h-6.07zM6 11a5 5 0 015 5v1H1v-1a5 5 0 015-5z" />
                </svg>
                Ajouter une relation
              </Link>
            </li>
            <li>
              <Link href="/relationship/analyzer" className="flex items-center text-blue-600 hover:underline">
                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                  <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z" clipRule="evenodd" />
                </svg>
                Analyser les liens de parenté
              </Link>
            </li>
            <li>
              <Link href="/import-export" className="flex items-center text-blue-600 hover:underline">
                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                  <path fillRule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM6.293 6.707a1 1 0 010-1.414l3-3a1 1 0 011.414 0l3 3a1 1 0 01-1.414 1.414L11 5.414V13a1 1 0 11-2 0V5.414L7.707 6.707a1 1 0 01-1.414 0z" clipRule="evenodd" />
                </svg>
                Importer/Exporter des données
              </Link>
            </li>
          </ul>
        </div>
      </div>
    </div>
  );
}// END OF FILE: src/app/family/[id]/page.tsx

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/app/family/[id]/tree/page.tsx

// src/app/family/[id]/page.tsx
'use client';

import React, { useState, useEffect } from 'react';
import { useParams, useRouter } from 'next/navigation';
import Link from 'next/link';
import { useFamily } from '@/context/FamilyContext';
import { Family } from '@/lib/models/Families';
import { Person } from '@/lib/models/Person';
import { calculateAge } from '@/lib/utils/dateUtils';

export default function FamilyDetailPage() {
  const params = useParams();
  const router = useRouter();
  const { families, loading, deleteFamily } = useFamily();
  const [family, setFamily] = useState<Family | null>(null);
  const [rootPerson, setRootPerson] = useState<Person | null>(null);
  const [stats, setStats] = useState({
    totalPersons: 0,
    maleCount: 0,
    femaleCount: 0,
    otherCount: 0,
    livingCount: 0,
    deceasedCount: 0,
    oldestPerson: null as Person | null,
    youngestPerson: null as Person | null,
    averageAge: 0
  });
  const [isDeleting, setIsDeleting] = useState(false);

  // Charger les données de la famille
  useEffect(() => {
    if (!loading && families.length > 0 && params.id) {
      const foundFamily = families.find(f => f.id === params.id);
      
      if (foundFamily) {
        setFamily(foundFamily);
        
        // Calcul des statistiques
        const persons = foundFamily.persons;
        
        // Compter les personnes par sexe et état
        const maleCount = persons.filter(p => p.sexe === 'M').length;
        const femaleCount = persons.filter(p => p.sexe === 'F').length;
        const otherCount = persons.filter(p => p.sexe === 'A').length;
        const livingCount = persons.filter(p => p.etat === 'vivant').length;
        const deceasedCount = persons.filter(p => p.etat === 'mort').length;
        
        // Trouver la personne la plus âgée et la plus jeune
        const personsWithBirthDate = persons.filter(p => p.birthDate);
        
        let oldestPerson = null;
        let youngestPerson = null;
        
        if (personsWithBirthDate.length > 0) {
          oldestPerson = personsWithBirthDate.reduce((oldest, current) => {
            if (!oldest.birthDate) return current;
            if (!current.birthDate) return oldest;
            
            return new Date(oldest.birthDate) < new Date(current.birthDate) ? oldest : current;
          });
          
          youngestPerson = personsWithBirthDate.reduce((youngest, current) => {
            if (!youngest.birthDate) return current;
            if (!current.birthDate) return youngest;
            
            return new Date(youngest.birthDate) > new Date(current.birthDate) ? youngest : current;
          });
        }
        
        // Calculer l'âge moyen
        let totalAge = 0;
        let countWithAge = 0;
        
        for (const person of personsWithBirthDate) {
          if (person.birthDate) {
            const birthDate = new Date(person.birthDate);
            const endDate = person.etat === 'mort' && person.deathDate 
              ? new Date(person.deathDate) 
              : new Date();
            
            const ageMs = endDate.getTime() - birthDate.getTime();
            const ageDate = new Date(ageMs);
            const age = Math.abs(ageDate.getUTCFullYear() - 1970);
            
            totalAge += age;
            countWithAge++;
          }
        }
        
        const averageAge = countWithAge > 0 ? Math.round(totalAge / countWithAge) : 0;
        
        // Déterminer la personne racine (celle avec le plus de relations)
        if (persons.length > 0) {
          const personRelationsCount = persons.map(person => {
            const relationsCount = foundFamily.relationships.filter(
              rel => rel.sourceId === person.id || rel.targetId === person.id
            ).length;
            
            return { person, relationsCount };
          });
          
          const mostConnectedPerson = personRelationsCount.reduce((most, current) => 
            current.relationsCount > most.relationsCount ? current : most,
            { person: persons[0], relationsCount: 0 }
          );
          
          setRootPerson(mostConnectedPerson.person);
        }
        
        // Mettre à jour les statistiques
        setStats({
          totalPersons: persons.length,
          maleCount,
          femaleCount,
          otherCount,
          livingCount,
          deceasedCount,
          oldestPerson,
          youngestPerson,
          averageAge
        });
      } else {
        // Famille non trouvée, rediriger
        router.push('/family');
      }
    }
  }, [families, loading, params.id, router]);

  // Gestionnaire de suppression
  const handleDelete = async () => {
    if (!family) return;
    
    if (!window.confirm(`Êtes-vous sûr de vouloir supprimer l'arbre "${family.name}" ? Cette action est irréversible et supprimera toutes les personnes et relations associées.`)) {
      return;
    }
    
    setIsDeleting(true);
    
    try {
      await deleteFamily(family.id);
      router.push('/family');
    } catch (error) {
      console.error('Erreur lors de la suppression:', error);
      setIsDeleting(false);
    }
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="text-center">
          <h2 className="text-xl font-semibold mb-2">Chargement des données...</h2>
          <div className="w-12 h-12 border-4 border-t-blue-500 border-b-blue-700 rounded-full animate-spin mx-auto"></div>
        </div>
      </div>
    );
  }

  if (!family) {
    return (
      <div className="container mx-auto px-4 py-8">
        <div className="bg-white rounded-lg shadow-md p-6 text-center">
          <h2 className="text-2xl font-semibold mb-4">Arbre généalogique non trouvé</h2>
          <p className="mb-6">L'arbre généalogique que vous recherchez n'existe pas.</p>
          <Link href="/family" className="btn btn-primary">
            Retour à la liste des arbres
          </Link>
        </div>
      </div>
    );
  }

  return (
    <div className="container mx-auto px-4 py-8">
      <div className="mb-6">
        <Link href="/family" className="text-blue-600 hover:underline inline-flex items-center">
          <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor">
            <path fillRule="evenodd" d="M9.707 14.707a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 1.414L7.414 9H15a1 1 0 110 2H7.414l2.293 2.293a1 1 0 010 1.414z" clipRule="evenodd" />
          </svg>
          Retour à la liste des arbres
        </Link>
      </div>
      
      <div className="flex flex-col md:flex-row md:justify-between md:items-start mb-8">
        <div>
          <h1 className="text-3xl font-bold mb-2">
            {family.name}
          </h1>
          <p className="text-gray-600">
            Dernière mise à jour: {new Date(family.updatedAt).toLocaleDateString()}
          </p>
        </div>
        
        <div className="mt-4 md:mt-0 flex flex-wrap gap-3">
          <Link 
            href={`/family/${params.id}/edit`} 
            className="btn btn-primary inline-flex items-center"
          >
            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
              <path d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z" />
            </svg>
            Modifier
          </Link>
          
          <Link 
            href={`/tree?familyId=${params.id}`} 
            className="btn btn-secondary inline-flex items-center"
          >
            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
              <path d="M7 3a1 1 0 000 2h6a1 1 0 100-2H7zM4 7a1 1 0 011-1h10a1 1 0 110 2H5a1 1 0 01-1-1zM2 11a2 2 0 012-2h12a2 2 0 012 2v4a2 2 0 01-2 2H4a2 2 0 01-2-2v-4z" />
            </svg>
            Voir l'arbre complet
          </Link>
          
          <button
            onClick={handleDelete}
            className="btn btn-danger inline-flex items-center"
            disabled={isDeleting}
          >
            {isDeleting ? (
              <>
                <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                  <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                  <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                Suppression...
              </>
            ) : (
              <>
                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                  <path fillRule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clipRule="evenodd" />
                </svg>
                Supprimer
              </>
            )}
          </button>
        </div>
      </div>
      
      <div className="grid grid-cols-1 md:grid-cols-3 gap-8">
        {/* Statistiques */}
        <div className="bg-white rounded-lg shadow-md p-6">
          <h2 className="text-xl font-semibold mb-4 border-b pb-2">Statistiques</h2>
          
          <dl className="space-y-3">
            <div>
              <dt className="text-sm font-medium text-gray-500">Nombre total de personnes</dt>
              <dd className="mt-1 text-2xl text-gray-900">{stats.totalPersons}</dd>
            </div>
            
            <div>
              <dt className="text-sm font-medium text-gray-500">Répartition par sexe</dt>
              <dd className="mt-1">
                <div className="flex gap-2">
                  <span className="bg-blue-100 text-blue-800 text-xs font-medium px-2 py-1 rounded">
                    Hommes: {stats.maleCount}
                  </span>
                  <span className="bg-pink-100 text-pink-800 text-xs font-medium px-2 py-1 rounded">
                    Femmes: {stats.femaleCount}
                  </span>
                  {stats.otherCount > 0 && (
                    <span className="bg-purple-100 text-purple-800 text-xs font-medium px-2 py-1 rounded">
                      Autre: {stats.otherCount}
                    </span>
                  )}
                </div>
              </dd>
            </div>
            
            <div>
              <dt className="text-sm font-medium text-gray-500">Vivants / Décédés</dt>
              <dd className="mt-1">
                <div className="flex gap-2">
                  <span className="bg-green-100 text-green-800 text-xs font-medium px-2 py-1 rounded">
                    Vivants: {stats.livingCount}
                  </span>
                  <span className="bg-gray-100 text-gray-800 text-xs font-medium px-2 py-1 rounded">
                    Décédés: {stats.deceasedCount}
                  </span>
                </div>
              </dd>
            </div>
            
            <div>
              <dt className="text-sm font-medium text-gray-500">Âge moyen</dt>
              <dd className="mt-1 text-gray-900">{stats.averageAge} ans</dd>
            </div>
            
            {stats.oldestPerson && (
              <div>
                <dt className="text-sm font-medium text-gray-500">Personne la plus âgée</dt>
                <dd className="mt-1">
                  <Link href={`/person/${stats.oldestPerson.id}?familyId=${family.id}`} className="text-blue-600 hover:underline">
                    {stats.oldestPerson.prenom} {stats.oldestPerson.nom}
                  </Link>
                  {stats.oldestPerson.birthDate && (
                    <span className="text-sm text-gray-500 ml-2">
                      ({calculateAge(stats.oldestPerson)} ans)
                    </span>
                  )}
                </dd>
              </div>
            )}
            
            {stats.youngestPerson && (
              <div>
                <dt className="text-sm font-medium text-gray-500">Personne la plus jeune</dt>
                <dd className="mt-1">
                  <Link href={`/person/${stats.youngestPerson.id}?familyId=${family.id}`} className="text-blue-600 hover:underline">
                    {stats.youngestPerson.prenom} {stats.youngestPerson.nom}
                  </Link>
                  {stats.youngestPerson.birthDate && (
                    <span className="text-sm text-gray-500 ml-2">
                      ({calculateAge(stats.youngestPerson)} ans)
                    </span>
                  )}
                </dd>
              </div>
            )}
          </dl>
        </div>
        
        {/* Membres récents */}
        <div className="bg-white rounded-lg shadow-md p-6 md:col-span-2">
          <h2 className="text-xl font-semibold mb-4 border-b pb-2">Membres récents</h2>
          
          {family.persons.length > 0 ? (
            <ul className="divide-y">
              {family.persons
                .slice(-5) // Afficher les 5 dernières personnes
                .map(person => (
                  <li key={person.id} className="py-3">
                    <Link href={`/person/${person.id}?familyId=${family.id}`} className="flex items-center hover:bg-gray-50 p-2 rounded">
                      <div className={`w-10 h-10 rounded-full flex items-center justify-center mr-3 ${
                        person.sexe === 'M' ? 'bg-blue-100 text-blue-800' : 
                        person.sexe === 'F' ? 'bg-pink-100 text-pink-800' : 
                        'bg-purple-100 text-purple-800'
                      }`}>
                        {person.prenom.charAt(0)}
                      </div>
                      <div>
                        <p className="font-medium">{person.prenom} {person.nom}</p>
                        <p className="text-sm text-gray-500">
                          {person.birthDate ? new Date(person.birthDate).getFullYear() : "?"} - 
                          {person.deathDate ? new Date(person.deathDate).getFullYear() : person.etat === "vivant" ? "présent" : "?"}
                        </p>
                      </div>
                    </Link>
                  </li>
                ))}
            </ul>
          ) : (
            <p className="text-gray-500 italic">Aucune personne dans cet arbre généalogique.</p>
          )}
          
          <div className="mt-6 flex justify-between items-center">
            <Link href={`/person?familyId=${family.id}`} className="text-blue-600 hover:underline text-sm">
              Voir toutes les personnes →
            </Link>
            
            <Link href={`/person/new?familyId=${family.id}`} className="btn btn-primary">
              Ajouter une personne
            </Link>
          </div>
        </div>
      </div>
      
      {/* Suggestions et actions */}
      <div className="mt-8 grid grid-cols-1 md:grid-cols-2 gap-8">
        <div className="bg-white rounded-lg shadow-md p-6">
          <h2 className="text-xl font-semibold mb-4 border-b pb-2">Racine de l'arbre</h2>
          
          {rootPerson ? (
            <div>
              <div className="flex items-center mb-4">
                <div className={`w-12 h-12 rounded-full flex items-center justify-center mr-4 ${
                  rootPerson.sexe === 'M' ? 'bg-blue-100 text-blue-800' : 
                  rootPerson.sexe === 'F' ? 'bg-pink-100 text-pink-800' : 
                  'bg-purple-100 text-purple-800'
                }`}>
                  {rootPerson.prenom.charAt(0)}
                </div>
                <div>
                  <p className="font-medium">{rootPerson.prenom} {rootPerson.nom}</p>
                  <p className="text-sm text-gray-500">
                    Personne centrale de l'arbre
                  </p>
                </div>
              </div>
              
              <p className="mb-4 text-gray-600">
                Cette personne est actuellement utilisée comme point de départ pour visualiser l'arbre généalogique.
              </p>
              
              <div className="flex gap-3">
                <Link 
                  href={`/person/${rootPerson.id}?familyId=${family.id}`} 
                  className="btn btn-secondary inline-block"
                >
                  Voir le profil
                </Link>
                <Link 
                  href={`/tree?familyId=${family.id}&rootId=${rootPerson.id}`} 
                  className="btn btn-primary inline-block"
                >
                  Voir l'arbre centré
                </Link>
              </div>
            </div>
          ) : (
            <p className="text-gray-500 italic">Aucune personne racine définie.</p>
          )}
        </div>
        
        <div className="bg-white rounded-lg shadow-md p-6">
          <h2 className="text-xl font-semibold mb-4 border-b pb-2">Actions rapides</h2>
          
          <ul className="space-y-3">
            <li>
              <Link href={`/person/new?familyId=${family.id}`} className="flex items-center text-blue-600 hover:underline">
                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                  <path fillRule="evenodd" d="M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z" clipRule="evenodd" />
                </svg>
                Ajouter une nouvelle personne
              </Link>
            </li>
            <li>
              <Link href={`/relationship/new?familyId=${family.id}`} className="flex items-center text-blue-600 hover:underline">
                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                  <path d="M9 6a3 3 0 11-6 0 3 3 0 016 0zM17 6a3 3 0 11-6 0 3 3 0 016 0zM12.93 17c.046-.327.07-.66.07-1a6.97 6.97 0 00-1.5-4.33A5 5 0 0119 16v1h-6.07zM6 11a5 5 0 015 5v1H1v-1a5 5 0 015-5z" />
                </svg>
                Ajouter une relation
              </Link>
            </li>
            <li>
              <Link href={`/relationship/analyzer?familyId=${family.id}`} className="flex items-center text-blue-600 hover:underline">
                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                  <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z" clipRule="evenodd" />
                </svg>
                Analyser les liens de parenté
              </Link>
            </li>
            <li>
              <Link href="/import-export" className="flex items-center text-blue-600 hover:underline">
                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                  <path fillRule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM6.293 6.707a1 1 0 010-1.414l3-3a1 1 0 011.414 0l3 3a1 1 0 01-1.414 1.414L11 5.414V13a1 1 0 11-2 0V5.414L7.707 6.707a1 1 0 01-1.414 0z" clipRule="evenodd" />
                </svg>
                Importer/Exporter des données
              </Link>
            </li>
          </ul>
        </div>
      </div>
    </div>
  );
}// END OF FILE: src/app/family/[id]/tree/page.tsx

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/app/family/new/page.tsx

  // src/app/family/new/page.tsx et src/app/family/[id]/edit/page.tsx
  'use client';

  import React, { useState, useEffect } from 'react';
  import { useParams, useRouter } from 'next/navigation';
  import Link from 'next/link';
  import { useFamily } from '@/context/FamilyContext';
  import { Family } from '@/lib/models/Families';

  export default function FamilyFormPage() {
    const params = useParams();
    const router = useRouter();
    const { families, loading, addFamily, updateFamily } = useFamily();
    const [isNew, setIsNew] = useState(true);
    const [formData, setFormData] = useState({
      name: '',
      description: ''
    });
    const [errors, setErrors] = useState<Record<string, string>>({});
    const [isSaving, setIsSaving] = useState(false);

    // Déterminer si c'est un ajout ou une modification
    useEffect(() => {
      const id = params?.id;
      setIsNew(!id);
      
      if (!isNew && !loading && id) {
        // Trouver la famille à modifier
        const family = families.find(f => f.id === id);
        
        if (family) {
          setFormData({
            name: family.name,
            description: family.description
          });
        } else {
          // Famille non trouvée, rediriger
          router.push('/family');
        }
      }
    }, [params, families, loading, isNew, router]);

    // Gestionnaire de changement de champ
    const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
      const { name, value } = e.target;
      
      setFormData(prev => ({
        ...prev,
        [name]: value
      }));
      
      // Effacer l'erreur si elle existe
      if (errors[name]) {
        setErrors(prev => {
          const newErrors = { ...prev };
          delete newErrors[name];
          return newErrors;
        });
      }
    };

    // Validation du formulaire
    const validateForm = (): boolean => {
      const newErrors: Record<string, string> = {};
      
      if (!formData.name?.trim()) {
        newErrors.name = "Le nom de l'arbre généalogique est requis";
      }
      
      setErrors(newErrors);
      return Object.keys(newErrors).length === 0;
    };

    // Soumission du formulaire
    const handleSubmit = async (e: React.FormEvent) => {
      e.preventDefault();
      
      if (!validateForm()) return;
      
      setIsSaving(true);
      
      try {
        if (isNew) {
          // Création d'un nouvel arbre généalogique
          const newFamily: Family = {
            id: `family-${Date.now()}`,
            name: formData.name,
            description: formData.description,
            persons: [],
            relationships: [],
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString()
          };
          
          await addFamily(newFamily);
          
          // Rediriger vers la page de l'arbre
          router.push(`/family/${newFamily.id}`);
        } else if (params?.id) {
          // Mise à jour de l'arbre existant
          await updateFamily(params.id as string, {
            name: formData.name,
            description: formData.description
          });
          
          // Rediriger vers la page de l'arbre
          router.push(`/family/${params.id}`);
        }
      } catch (error) {
        console.error('Erreur lors de la sauvegarde:', error);
        setErrors(prev => ({
          ...prev,
          submit: "Une erreur est survenue lors de la sauvegarde"
        }));
      } finally {
        setIsSaving(false);
      }
    };

    if (loading) {
      return (
        <div className="flex items-center justify-center min-h-screen">
          <div className="text-center">
            <h2 className="text-xl font-semibold mb-2">Chargement des données...</h2>
            <div className="w-12 h-12 border-4 border-t-blue-500 border-b-blue-700 rounded-full animate-spin mx-auto"></div>
          </div>
        </div>
      );
    }

    return (
      <div className="container mx-auto px-4 py-8">
        <div className="mb-6">
          <Link href={isNew ? "/family" : `/family/${params?.id}`} className="text-blue-600 hover:underline inline-flex items-center">
            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor">
              <path fillRule="evenodd" d="M9.707 14.707a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 1.414L7.414 9H15a1 1 0 110 2H7.414l2.293 2.293a1 1 0 010 1.414z" clipRule="evenodd" />
            </svg>
            Retour
          </Link>
        </div>
        
        <div className="bg-white rounded-lg shadow-md p-6">
          <h1 className="text-2xl font-bold mb-6">
            {isNew ? "Créer un nouvel arbre généalogique" : `Modifier ${formData.name}`}
          </h1>
          
          <form onSubmit={handleSubmit}>
            {errors.submit && (
              <div className="mb-6 bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded">
                {errors.submit}
              </div>
            )}
            
            <div className="mb-6">
              <label htmlFor="name" className="form-label">
                Nom de l'arbre généalogique <span className="text-red-500">*</span>
              </label>
              <input
                type="text"
                id="name"
                name="name"
                value={formData.name}
                onChange={handleChange}
                className={`form-input ${errors.name ? 'border-red-500 ring-1 ring-red-500' : ''}`}
                placeholder="Ex: Famille Dupont"
                required
              />
              {errors.name && (
                <p className="text-red-500 text-sm mt-1">{errors.name}</p>
              )}
            </div>
            
            <div className="mb-6">
              <label htmlFor="description" className="form-label">
                Description
              </label>
              <textarea
                id="description"
                name="description"
                value={formData.description}
                onChange={handleChange}
                className="form-input"
                rows={4}
                placeholder="Description optionnelle de l'arbre généalogique"
              />
            </div>
            
            <div className="flex justify-end gap-4 mt-8">
              <Link 
                href={isNew ? "/family" : `/family/${params?.id}`}
                className="btn btn-secondary"
              >
                Annuler
              </Link>
              
              <button
                type="submit"
                className="btn btn-primary"
                disabled={isSaving}
              >
                {isSaving ? (
                  <>
                    <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                      <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                    Enregistrement...
                  </>
                ) : (
                  isNew ? 'Créer l\'arbre' : 'Enregistrer les modifications'
                )}
              </button>
            </div>
          </form>
        </div>
      </div>
    );
  };    // END OF FILE: src/app/family/new/page.tsx

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/app/family/page.tsx

// src/app/family/page.tsx
'use client';

import React, { useState } from 'react';
import Link from 'next/link';
import { useRouter } from 'next/navigation';
import { useFamily } from '@/context/FamilyContext';

export default function FamilyListPage() {
  const router = useRouter();
  const { families, activeFamily, loading, setActiveFamily } = useFamily();
  const [searchTerm, setSearchTerm] = useState('');

  // Filtrage des familles selon le terme de recherche
  const filteredFamilies = families.filter(family => 
    family.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
    family.description.toLowerCase().includes(searchTerm.toLowerCase())
  );

  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="text-center">
          <h2 className="text-xl font-semibold mb-2">Chargement des données...</h2>
          <div className="w-12 h-12 border-4 border-t-blue-500 border-b-blue-700 rounded-full animate-spin mx-auto"></div>
        </div>
      </div>
    );
  }

  return (
    <div className="container mx-auto px-4 py-8">
      <div className="mb-8 flex flex-col md:flex-row md:items-center md:justify-between">
        <h1 className="text-3xl font-bold mb-4 md:mb-0">Mes Arbres Généalogiques</h1>
        
        <div className="flex flex-col sm:flex-row gap-4">
          <div className="relative">
            <input
              type="text"
              placeholder="Rechercher..."
              className="w-full md:w-64 px-4 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
            />
            {searchTerm && (
              <button 
                className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-500 hover:text-gray-700"
                onClick={() => setSearchTerm('')}
              >
                ✕
              </button>
            )}
          </div>
          
          <Link 
            href="/family/new" 
            className="btn btn-primary inline-flex items-center justify-center"
          >
            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
              <path fillRule="evenodd" d="M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z" clipRule="evenodd" />
            </svg>
            Créer un nouvel arbre
          </Link>
        </div>
      </div>
      
      {filteredFamilies.length > 0 ? (
        <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
          {filteredFamilies.map(family => (
            <div 
              key={family.id} 
              className={`bg-white rounded-lg shadow-md overflow-hidden ${
                activeFamily?.id === family.id ? 'ring-2 ring-blue-500' : ''
              }`}
            >
              <div className="p-6">
                <h2 className="text-xl font-semibold mb-2">{family.name}</h2>
                <p className="text-gray-600 mb-4">{family.description}</p>
                
                <div className="flex items-center text-sm text-gray-500 mb-4">
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor">
                    <path d="M13 6a3 3 0 11-6 0 3 3 0 016 0zM18 8a2 2 0 11-4 0 2 2 0 014 0zM14 15a4 4 0 00-8 0v3h8v-3zM6 8a2 2 0 11-4 0 2 2 0 014 0zM16 18v-3a5.972 5.972 0 00-.75-2.906A3.005 3.005 0 0119 15v3h-3zM4.75 12.094A5.973 5.973 0 004 15v3H1v-3a3 3 0 013.75-2.906z" />
                  </svg>
                  {family.persons.length} {family.persons.length > 1 ? 'personnes' : 'personne'}
                </div>
                
                <div className="flex items-center text-sm text-gray-500 mb-6">
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor">
                    <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z" clipRule="evenodd" />
                  </svg>
                  Dernière mise à jour: {new Date(family.updatedAt).toLocaleDateString()}
                </div>
                
                <div className="flex space-x-3">
                  {activeFamily?.id !== family.id ? (
                    <button
                      onClick={() => setActiveFamily(family.id)}
                      className="flex-1 btn btn-secondary text-center"
                    >
                      Activer
                    </button>
                  ) : (
                    <span className="flex-1 bg-green-100 text-green-800 text-center py-2 px-4 rounded font-medium">
                      Actif
                    </span>
                  )}
                  
                  <Link
                    href={`/family/${family.id}`}
                    className="flex-1 btn btn-primary text-center"
                  >
                    Ouvrir
                  </Link>
                </div>
              </div>
            </div>
          ))}
        </div>
      ) : (
        <div className="bg-white rounded-lg shadow-md p-6 text-center">
          <h2 className="text-xl font-semibold mb-2">Aucun arbre généalogique trouvé</h2>
          <p className="text-gray-600 mb-6">
            {searchTerm 
              ? `Aucun résultat pour "${searchTerm}"`
              : "Vous n'avez pas encore créé d'arbre généalogique"}
          </p>
          <Link href="/family/new" className="btn btn-primary">
            Créer mon premier arbre
          </Link>
        </div>
      )}
      
      <div className="mt-10 bg-blue-50 border border-blue-200 rounded-lg p-6">
        <h2 className="text-xl font-semibold mb-4">Comment démarrer?</h2>
        <ul className="space-y-4">
          <li className="flex">
            <div className="flex-shrink-0 h-6 w-6 bg-blue-500 text-white rounded-full flex items-center justify-center mr-3">
              1
            </div>
            <div>
              <p className="font-medium">Créez un nouvel arbre généalogique</p>
              <p className="text-gray-600">Donnez un nom à votre arbre et commencez à construire votre histoire familiale.</p>
            </div>
          </li>
          <li className="flex">
            <div className="flex-shrink-0 h-6 w-6 bg-blue-500 text-white rounded-full flex items-center justify-center mr-3">
              2
            </div>
            <div>
              <p className="font-medium">Ajoutez des membres à votre famille</p>
              <p className="text-gray-600">Créez des profils pour chaque membre de votre famille avec leurs informations personnelles.</p>
            </div>
          </li>
          <li className="flex">
            <div className="flex-shrink-0 h-6 w-6 bg-blue-500 text-white rounded-full flex items-center justify-center mr-3">
              3
            </div>
            <div>
              <p className="font-medium">Établissez les relations familiales</p>
              <p className="text-gray-600">Reliez les membres entre eux (parents, enfants, conjoints) pour créer votre arbre.</p>
            </div>
          </li>
          <li className="flex">
            <div className="flex-shrink-0 h-6 w-6 bg-blue-500 text-white rounded-full flex items-center justify-center mr-3">
              4
            </div>
            <div>
              <p className="font-medium">Explorez et analysez votre arbre</p>
              <p className="text-gray-600">Visualisez l'arbre complet et découvrez les relations entre les différents membres.</p>
            </div>
          </li>
        </ul>
      </div>
    </div>
  );
}// END OF FILE: src/app/family/page.tsx

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/app/globals.css

/* src/app/globals.css */

@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --foreground-rgb: 0, 0, 0;
  --background-start-rgb: 245, 247, 250;
  --background-end-rgb: 255, 255, 255;
  --primary-color: 37, 99, 235;
  --secondary-color: 16, 185, 129;
  --accent-color: 124, 58, 237;
  --success-color: 34, 197, 94;
  --warning-color: 245, 158, 11;
  --error-color: 239, 68, 68;
  --primary-font: 'Inter', sans-serif;
}

/* Ajout de polices personnalisées */
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

/* Styles de base */
body {
  color: rgb(var(--foreground-rgb));
  font-family: var(--primary-font);
  background: linear-gradient(
      to bottom,
      rgb(var(--background-start-rgb)),
      rgb(var(--background-end-rgb))
    )
    fixed;
  min-height: 100vh;
}

h1, h2, h3, h4, h5, h6 {
  font-weight: 600;
  line-height: 1.2;
}

/* Animations améliorées */
@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes slideInFromRight {
  from { transform: translateX(30px); opacity: 0; }
  to { transform: translateX(0); opacity: 1; }
}

@keyframes slideInFromBottom {
  from { transform: translateY(30px); opacity: 0; }
  to { transform: translateY(0); opacity: 1; }
}

@keyframes pulse {
  0% { transform: scale(1); }
  50% { transform: scale(1.05); }
  100% { transform: scale(1); }
}

@keyframes spin-slow {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

.animate-fade-in {
  animation: fadeIn 0.5s ease-in forwards;
}

.animate-slide-in-right {
  animation: slideInFromRight 0.5s ease-out forwards;
}

.animate-slide-in-bottom {
  animation: slideInFromBottom 0.5s ease-out forwards;
}

.animate-pulse {
  animation: pulse 2s infinite;
}

.animate-spin-slow {
  animation: spin-slow 20s linear infinite;
}

.animate-fade-in-right {
  animation: slideInFromRight 0.5s ease-out forwards;
}

/* Styles personnalisés pour l'arbre généalogique */
.tree-node {
  @apply relative p-4 border border-gray-200 rounded-xl bg-white shadow-md transition-all duration-300;
}

.tree-node:hover {
  @apply shadow-xl transform scale-105 z-10 border-blue-300;
}

.tree-node-male {
  @apply border-l-4 border-l-blue-500;
}

.tree-node-female {
  @apply border-l-4 border-l-pink-500;
}

.tree-node-other {
  @apply border-l-4 border-l-purple-500;
}

.tree-connector {
  @apply bg-gray-300 rounded-full transition-colors duration-300 shadow-sm;
}

.tree-connector-parent {
  @apply bg-blue-400;
}

.tree-connector-spouse {
  @apply bg-red-400;
}

.tree-connector-child {
  @apply bg-green-400;
}

/* Styles pour les formulaires */
.form-input {
  @apply w-full px-4 py-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent shadow-sm transition-all duration-200;
}

.form-input:hover {
  @apply border-gray-400;
}

.form-label {
  @apply block text-sm font-medium text-gray-700 mb-2;
}

.form-group {
  @apply mb-4;
}

.form-error {
  @apply text-red-500 text-sm mt-1;
}

.form-hint {
  @apply text-gray-500 text-sm mt-1;
}

/* Boutons améliorés */
.btn {
  @apply px-5 py-2.5 rounded-lg text-white font-medium transition-all duration-200 shadow-sm flex items-center justify-center;
}

.btn-icon {
  @apply mr-2 h-5 w-5;
}

.btn-primary {
  @apply bg-blue-600 hover:bg-blue-700 hover:shadow-md active:bg-blue-800 focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50;
}

.btn-success {
  @apply bg-green-600 hover:bg-green-700 hover:shadow-md active:bg-green-800 focus:ring-2 focus:ring-green-500 focus:ring-opacity-50;
}

.btn-danger {
  @apply bg-red-600 hover:bg-red-700 hover:shadow-md active:bg-red-800 focus:ring-2 focus:ring-red-500 focus:ring-opacity-50;
}

.btn-secondary {
  @apply bg-gray-500 hover:bg-gray-600 hover:shadow-md active:bg-gray-700 focus:ring-2 focus:ring-gray-400 focus:ring-opacity-50;
}

.btn-outline {
  @apply border-2 border-blue-600 text-blue-600 hover:bg-blue-50 focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50;
}

.btn-sm {
  @apply px-3 py-1.5 text-sm;
}

.btn-lg {
  @apply px-6 py-3 text-lg;
}

/* Cartes et panneaux */
.card {
  @apply bg-white rounded-xl shadow-md overflow-hidden border border-gray-100 transition-all duration-300;
}

.card:hover {
  @apply shadow-lg border-gray-200;
}

.card-header {
  @apply px-6 py-4 border-b border-gray-100 bg-gray-50;
}

.card-body {
  @apply p-6;
}

.card-footer {
  @apply px-6 py-4 border-t border-gray-100 bg-gray-50;
}

/* Styles pour les cartes de personnes */
.person-card {
  @apply border rounded-xl overflow-hidden hover:shadow-lg transition-all duration-300 relative;
}

.person-card.selected {
  @apply ring-2 ring-offset-2 ring-blue-500;
}

.person-card-header {
  @apply p-4 flex items-center;
}

.person-card-avatar {
  @apply w-14 h-14 rounded-full flex items-center justify-center text-white font-bold text-xl;
}

.person-card-info {
  @apply ml-4;
}

.person-card-body {
  @apply p-4 border-t border-gray-100;
}

.person-card-footer {
  @apply p-4 bg-gray-50 border-t border-gray-100 flex justify-end space-x-2;
}

.person-male {
  @apply border-blue-200 bg-blue-50;
}

.person-male .person-card-avatar {
  @apply bg-blue-600;
}

.person-female {
  @apply border-pink-200 bg-pink-50;
}

.person-female .person-card-avatar {
  @apply bg-pink-600;
}

.person-other {
  @apply border-purple-200 bg-purple-50;
}

.person-other .person-card-avatar {
  @apply bg-purple-600;
}

/* Badge et étiquettes */
.badge {
  @apply inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium;
}

.badge-blue {
  @apply bg-blue-100 text-blue-800;
}

.badge-green {
  @apply bg-green-100 text-green-800;
}

.badge-red {
  @apply bg-red-100 text-red-800;
}

.badge-yellow {
  @apply bg-yellow-100 text-yellow-800;
}

.badge-purple {
  @apply bg-purple-100 text-purple-800;
}

/* Alerte et notifications */
.alert {
  @apply p-4 mb-4 rounded-lg;
}

.alert-info {
  @apply bg-blue-50 text-blue-800 border-l-4 border-blue-500;
}

.alert-success {
  @apply bg-green-50 text-green-800 border-l-4 border-green-500;
}

.alert-warning {
  @apply bg-yellow-50 text-yellow-800 border-l-4 border-yellow-500;
}

.alert-error {
  @apply bg-red-50 text-red-800 border-l-4 border-red-500;
}

/* Tableaux améliorés */
.table-container {
  @apply overflow-x-auto rounded-lg border border-gray-200 shadow-md;
}

.table {
  @apply min-w-full bg-white;
}

.table th {
  @apply px-6 py-3 bg-gray-50 text-left text-xs font-medium text-gray-500 uppercase tracking-wider border-b border-gray-200;
}

.table td {
  @apply px-6 py-4 whitespace-nowrap text-sm text-gray-500 border-b border-gray-100;
}

.table tr:hover {
  @apply bg-gray-50;
}

.table-striped tr:nth-child(even) {
  @apply bg-gray-50;
}

/* Utilities pour les espacements et le positionnement */
.section-spacing {
  @apply py-12 md:py-16;
}

.container-padding {
  @apply px-4 md:px-8;
}

/* Responsive fixes */
@media (max-width: 640px) {
  .container {
    @apply px-4;
  }
  
  .card-header, .card-body, .card-footer {
    @apply px-4 py-3;
  }
  
  .person-card-header {
    @apply flex-col items-start;
  }
  
  .person-card-avatar {
    @apply mb-3;
  }
  
  .person-card-info {
    @apply ml-0;
  }
}// END OF FILE: src/app/globals.css

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/app/graph-algorithms/components/AlgorithmSelector.tsx

// src/app/graph-algorithms/components/AlgorithmSelector.tsx
'use client';

import React from 'react';
import { GraphWeighted } from '@/lib/models/GraphWeighted';
import { 
  AlgorithmCategory, 
  TraversalAlgorithm, 
  ShortestPathAlgorithm, 
  MSTAlgorithm 
} from '../page';
import { depthFirstSearch } from '@/lib/algorithms/dfsSearch';
import { breadthFirstSearchBasic } from '@/lib/algorithms/bfsSearchBasic';
import { dijkstra, reconstructPath as dijkstraPath } from '@/lib/algorithms/dijkstra';
import { bellmanFord, reconstructPath as bellmanFordPath } from '@/lib/algorithms/bellmanFord';
import { kruskal, isCompleteSpanningTree as isKruskalComplete } from '@/lib/algorithms/kruskal';
import { prim, isCompleteSpanningTree as isPrimComplete } from '@/lib/algorithms/prim';

interface AlgorithmSelectorProps {
  graph: GraphWeighted | null;
  algorithmCategory: AlgorithmCategory;
  setAlgorithmCategory: (category: AlgorithmCategory) => void;
  traversalAlgorithm: TraversalAlgorithm;
  setTraversalAlgorithm: (algorithm: TraversalAlgorithm) => void;
  shortestPathAlgorithm: ShortestPathAlgorithm;
  setShortestPathAlgorithm: (algorithm: ShortestPathAlgorithm) => void;
  mstAlgorithm: MSTAlgorithm;
  setMSTAlgorithm: (algorithm: MSTAlgorithm) => void;
  startNodeId: string;
  setStartNodeId: (id: string) => void;
  endNodeId: string;
  setEndNodeId: (id: string) => void;
  runAlgorithm: (result: any) => void;
  error: string | null;
  setError: (error: string | null) => void;
  getCurrentAlgorithmName: () => string;
}

const AlgorithmSelector: React.FC<AlgorithmSelectorProps> = ({
  graph,
  algorithmCategory,
  setAlgorithmCategory,
  traversalAlgorithm,
  setTraversalAlgorithm,
  shortestPathAlgorithm,
  setShortestPathAlgorithm,
  mstAlgorithm,
  setMSTAlgorithm,
  startNodeId,
  setStartNodeId,
  endNodeId,
  setEndNodeId,
  runAlgorithm,
  error,
  setError,
  getCurrentAlgorithmName
}) => {
  // Exécution de l'algorithme choisi
  const executeAlgorithm = () => {
    // Vérifier que le graphe existe
    if (!graph) {
      setError("Veuillez d'abord créer un graphe");
      return;
    }
    
    try {
      setError(null);
      let algorithmResult;
      
      // Exécuter l'algorithme en fonction de la catégorie et du type
      if (algorithmCategory === 'traversal') {
        if (traversalAlgorithm === 'dfs') {
          algorithmResult = depthFirstSearch(graph, { startNodeId });
        } else {
          algorithmResult = breadthFirstSearchBasic(graph, { startNodeId });
        }
      } 
      else if (algorithmCategory === 'shortestPath') {
        if (shortestPathAlgorithm === 'dijkstra') {
          // Vérifier que le graphe n'a pas de poids négatifs
          if (!graph.isDijkstraCompatible()) {
            throw new Error("L'algorithme de Dijkstra ne fonctionne pas avec des poids négatifs");
          }
          algorithmResult = dijkstra(graph, startNodeId);
          
          // Si un nœud cible est spécifié, calculer le chemin
          if (endNodeId) {
            algorithmResult.path = dijkstraPath(algorithmResult, endNodeId);
          }
        } else {
          algorithmResult = bellmanFord(graph, startNodeId);
          
          // Si un nœud cible est spécifié, calculer le chemin
          if (endNodeId) {
            algorithmResult.path = bellmanFordPath(algorithmResult, endNodeId);
          }
          
          // Vérifier les cycles négatifs
          if (algorithmResult.hasNegativeCycle) {
            setError("Attention: Un cycle de poids négatif a été détecté. Les distances peuvent ne pas être correctes.");
          }
        }
      } 
      else if (algorithmCategory === 'minimumSpanningTree') {
        if (mstAlgorithm === 'kruskal') {
          algorithmResult = kruskal(graph);
          
          // Vérifier si l'ACM est complet
          if (!isKruskalComplete(algorithmResult, graph)) {
            setError("Le graphe n'est pas connexe. L'arbre couvrant minimal ne couvre pas tous les nœuds.");
          }
        } else {
          algorithmResult = prim(graph, startNodeId);
          
          // Vérifier si l'ACM est complet
          if (!isPrimComplete(algorithmResult, graph)) {
            setError("Le graphe n'est pas connexe. L'arbre couvrant minimal ne couvre pas tous les nœuds.");
          }
        }
      }
      
      // Passer le résultat au composant parent
      runAlgorithm(algorithmResult);
    } catch (e) {
      setError(e instanceof Error ? e.message : 'Erreur lors de l\'exécution de l\'algorithme');
    }
  };

  return (
    <div>
      <div className="mb-4">
        <label className="block text-sm font-medium text-gray-700 mb-1">Catégorie d'algorithme</label>
        <div className="flex flex-wrap gap-4">
          <label className="inline-flex items-center">
            <input
              type="radio"
              value="traversal"
              checked={algorithmCategory === 'traversal'}
              onChange={() => setAlgorithmCategory('traversal')}
              className="form-radio h-4 w-4 text-blue-600"
            />
            <span className="ml-2">Parcours de graphe</span>
          </label>
          <label className="inline-flex items-center">
            <input
              type="radio"
              value="shortestPath"
              checked={algorithmCategory === 'shortestPath'}
              onChange={() => setAlgorithmCategory('shortestPath')}
              className="form-radio h-4 w-4 text-blue-600"
            />
            <span className="ml-2">Plus courts chemins</span>
          </label>
          <label className="inline-flex items-center">
            <input
              type="radio"
              value="minimumSpanningTree"
              checked={algorithmCategory === 'minimumSpanningTree'}
              onChange={() => setAlgorithmCategory('minimumSpanningTree')}
              className="form-radio h-4 w-4 text-blue-600"
            />
            <span className="ml-2">Arbre couvrant minimal</span>
          </label>
        </div>
      </div>
      
      {/* Algorithmes de parcours */}
      {algorithmCategory === 'traversal' && (
        <div className="mb-4">
          <label className="block text-sm font-medium text-gray-700 mb-1">Algorithme de parcours</label>
          <div className="flex space-x-4">
            <label className="inline-flex items-center">
              <input
                type="radio"
                value="dfs"
                checked={traversalAlgorithm === 'dfs'}
                onChange={() => setTraversalAlgorithm('dfs')}
                className="form-radio h-4 w-4 text-blue-600"
              />
              <span className="ml-2">Parcours en profondeur (DFS)</span>
            </label>
            <label className="inline-flex items-center">
              <input
                type="radio"
                value="bfs"
                checked={traversalAlgorithm === 'bfs'}
                onChange={() => setTraversalAlgorithm('bfs')}
                className="form-radio h-4 w-4 text-blue-600"
              />
              <span className="ml-2">Parcours en largeur (BFS)</span>
            </label>
          </div>
        </div>
      )}
      
      {/* Algorithmes de plus courts chemins */}
      {algorithmCategory === 'shortestPath' && (
        <div className="mb-4">
          <label className="block text-sm font-medium text-gray-700 mb-1">Algorithme de plus court chemin</label>
          <div className="flex space-x-4">
            <label className="inline-flex items-center">
              <input
                type="radio"
                value="dijkstra"
                checked={shortestPathAlgorithm === 'dijkstra'}
                onChange={() => setShortestPathAlgorithm('dijkstra')}
                className="form-radio h-4 w-4 text-blue-600"
              />
              <span className="ml-2">Dijkstra (pas de poids négatifs)</span>
            </label>
            <label className="inline-flex items-center">
              <input
                type="radio"
                value="bellmanFord"
                checked={shortestPathAlgorithm === 'bellmanFord'}
                onChange={() => setShortestPathAlgorithm('bellmanFord')}
                className="form-radio h-4 w-4 text-blue-600"
              />
              <span className="ml-2">Bellman-Ford (avec poids négatifs)</span>
            </label>
          </div>
        </div>
      )}
      
      {/* Algorithmes d'arbre couvrant minimal */}
      {algorithmCategory === 'minimumSpanningTree' && (
        <div className="mb-4">
          <label className="block text-sm font-medium text-gray-700 mb-1">Algorithme d'arbre couvrant minimal</label>
          <div className="flex space-x-4">
            <label className="inline-flex items-center">
              <input
                type="radio"
                value="kruskal"
                checked={mstAlgorithm === 'kruskal'}
                onChange={() => setMSTAlgorithm('kruskal')}
                className="form-radio h-4 w-4 text-blue-600"
              />
              <span className="ml-2">Kruskal</span>
            </label>
            <label className="inline-flex items-center">
              <input
                type="radio"
                value="prim"
                checked={mstAlgorithm === 'prim'}
                onChange={() => setMSTAlgorithm('prim')}
                className="form-radio h-4 w-4 text-blue-600"
              />
              <span className="ml-2">Prim</span>
            </label>
          </div>
        </div>
      )}
      
      {/* Sélection du nœud de départ */}
      {graph && (
        <div className="mb-4">
          <label htmlFor="startNode" className="block text-sm font-medium text-gray-700 mb-1">
            Nœud de départ
          </label>
          <select
            id="startNode"
            className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
            value={startNodeId}
            onChange={(e) => setStartNodeId(e.target.value)}
          >
            {graph.getNodes().map(node => (
              <option key={node.id} value={node.id}>
                {node.label || node.id}
              </option>
            ))}
          </select>
        </div>
      )}
      
      {/* Sélection du nœud d'arrivée pour les algorithmes de plus courts chemins */}
      {graph && algorithmCategory === 'shortestPath' && (
        <div className="mb-4">
          <label htmlFor="endNode" className="block text-sm font-medium text-gray-700 mb-1">
            Nœud d'arrivée
          </label>
          <select
            id="endNode"
            className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
            value={endNodeId}
            onChange={(e) => setEndNodeId(e.target.value)}
          >
            <option value="">Tous les nœuds</option>
            {graph.getNodes().map(node => (
              <option key={node.id} value={node.id} disabled={node.id === startNodeId}>
                {node.label || node.id}
              </option>
            ))}
          </select>
        </div>
      )}
      
      <button
        className="w-full px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
        onClick={executeAlgorithm}
      >
        Exécuter {getCurrentAlgorithmName()}
      </button>
      
      {error && (
        <div className="mt-4 p-3 bg-red-100 border border-red-400 text-red-700 rounded">
          {error}
        </div>
      )}
    </div>
  );
};

export default AlgorithmSelector;// END OF FILE: src/app/graph-algorithms/components/AlgorithmSelector.tsx

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/app/graph-algorithms/components/common/Button.tsx

// END OF FILE: src/app/graph-algorithms/components/common/Button.tsx

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/app/graph-algorithms/components/common/InfoBox.tsx

// END OF FILE: src/app/graph-algorithms/components/common/InfoBox.tsx

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/app/graph-algorithms/components/common/Legend.tsx

// END OF FILE: src/app/graph-algorithms/components/common/Legend.tsx

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/app/graph-algorithms/components/GraphInput.tsx

// src/app/graph-algorithms/components/GraphInput.tsx
'use client';

import React, { useState } from 'react';
import { GraphWeighted } from '@/lib/models/GraphWeighted';
import { AlgorithmCategory } from '../page';

interface GraphInputProps {
  graph: GraphWeighted | null;
  setGraph: (graph: GraphWeighted | null) => void;
  algorithmCategory: AlgorithmCategory;
  setError: (error: string | null) => void;
  isDirected: boolean;
  setIsDirected: (isDirected: boolean) => void;
}

type GraphInputType = 'adjacencyMatrix' | 'adjacencyList';

const GraphInput: React.FC<GraphInputProps> = ({
  graph,
  setGraph,
  algorithmCategory,
  setError,
  isDirected,
  setIsDirected
}) => {
  // États locaux
  const [graphInputType, setGraphInputType] = useState<GraphInputType>('adjacencyMatrix');
  const [graphInput, setGraphInput] = useState<string>('');
  const [nodeLabels, setNodeLabels] = useState<string>('');
  
  // Fonction pour créer le graphe
  const createGraph = () => {
    try {
      setError(null);
      let newGraph: GraphWeighted;
      
      if (graphInputType === 'adjacencyMatrix') {
        // Parser la matrice d'adjacence
        const matrix = graphInput
          .trim()
          .split('\n')
          .map(row => row.trim().split(/\s+/).map(Number));
        
        // Vérifier que la matrice est carrée
        const size = matrix.length;
        if (!matrix.every(row => row.length === size)) {
          throw new Error('La matrice d\'adjacence doit être carrée');
        }
        
        // Parser les labels des nœuds si fournis
        const labels = nodeLabels.trim() ? nodeLabels.trim().split(/\s*,\s*/) : undefined;
        
        // Créer le graphe
        newGraph = GraphWeighted.fromAdjacencyMatrix(matrix, labels);
      } else {
        // Parser la liste d'adjacence (maintenant avec poids entre parenthèses)
        const lines = graphInput.trim().split('\n');
        
        // Créer le graphe
        newGraph = GraphWeighted.fromAdjacencyList(lines);
      }
      
      // Mettre à jour la direction du graphe
      newGraph.directed = isDirected;
      setGraph(newGraph);
      
      return newGraph;
    } catch (e) {
      setError(e instanceof Error ? e.message : 'Erreur lors de la création du graphe');
      return null;
    }
  };
  
  // Fonction pour charger un exemple
  const setExampleGraph = () => {
    if (algorithmCategory === 'traversal') {
      if (graphInputType === 'adjacencyMatrix') {
        setGraphInput(
          "0 1 0 0 1\n" +
          "1 0 1 1 1\n" +
          "0 1 0 1 0\n" +
          "0 1 1 0 1\n" +
          "1 1 0 1 0"
        );
        setNodeLabels("A, B, C, D, E");
      } else {
        setGraphInput(
          "A: B, E\n" +
          "B: A, C, D, E\n" +
          "C: B, D\n" +
          "D: B, C, E\n" +
          "E: A, B, D"
        );
      }
    } else if (algorithmCategory === 'shortestPath') {
      if (graphInputType === 'adjacencyMatrix') {
        setGraphInput(
          "0 4 0 0 8\n" +
          "4 0 3 2 5\n" +
          "0 3 0 7 0\n" +
          "0 2 7 0 6\n" +
          "8 5 0 6 0"
        );
        setNodeLabels("A, B, C, D, E");
      } else {
        setGraphInput(
          "A: B(4), E(8)\n" +
          "B: A(4), C(3), D(2), E(5)\n" +
          "C: B(3), D(7)\n" +
          "D: B(2), C(7), E(6)\n" +
          "E: A(8), B(5), D(6)"
        );
      }
    } else if (algorithmCategory === 'minimumSpanningTree') {
      if (graphInputType === 'adjacencyMatrix') {
        setGraphInput(
          "0 2 0 6 0\n" +
          "2 0 3 8 5\n" +
          "0 3 0 0 7\n" +
          "6 8 0 0 9\n" +
          "0 5 7 9 0"
        );
        setNodeLabels("A, B, C, D, E");
      } else {
        setGraphInput(
          "A: B(2), D(6)\n" +
          "B: A(2), C(3), D(8), E(5)\n" +
          "C: B(3), E(7)\n" +
          "D: A(6), B(8), E(9)\n" +
          "E: B(5), C(7), D(9)"
        );
      }
    }
  };
  
  // Fonction pour exporter la configuration
  const exportConfig = () => {
    const config = {
      graphInputType,
      graphInput,
      nodeLabels,
      isDirected
    };
    
    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(config));
    const downloadAnchor = document.createElement('a');
    downloadAnchor.setAttribute("href", dataStr);
    downloadAnchor.setAttribute("download", "graph-config.json");
    document.body.appendChild(downloadAnchor);
    downloadAnchor.click();
    downloadAnchor.remove();
  };
  
  // Fonction pour importer une configuration
  const importConfig = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const config = JSON.parse(e.target?.result as string);
        setGraphInputType(config.graphInputType || 'adjacencyMatrix');
        setGraphInput(config.graphInput || '');
        setNodeLabels(config.nodeLabels || '');
        setIsDirected(config.isDirected || false);
        
        // Recréer le graphe
        setTimeout(() => createGraph(), 100);
      } catch (err) {
        setError("Erreur lors de l'importation: format de fichier invalide");
      }
    };
    reader.readAsText(file);
  };
  
  return (
    <div>
      <div className="mb-4">
        <label className="block text-sm font-medium text-gray-700 mb-1">Type d'entrée</label>
        <div className="flex space-x-4">
          <label className="inline-flex items-center">
            <input
              type="radio"
              value="adjacencyMatrix"
              checked={graphInputType === 'adjacencyMatrix'}
              onChange={() => setGraphInputType('adjacencyMatrix')}
              className="form-radio h-4 w-4 text-blue-600"
            />
            <span className="ml-2">Matrice d'adjacence</span>
          </label>
          <label className="inline-flex items-center">
            <input
              type="radio"
              value="adjacencyList"
              checked={graphInputType === 'adjacencyList'}
              onChange={() => setGraphInputType('adjacencyList')}
              className="form-radio h-4 w-4 text-blue-600"
            />
            <span className="ml-2">Liste d'adjacence</span>
          </label>
        </div>
      </div>
      
      <div className="mb-4">
        <label className="block text-sm font-medium text-gray-700 mb-1">Type de graphe</label>
        <div className="flex space-x-4">
          <label className="inline-flex items-center">
            <input
              type="radio"
              value="undirected"
              checked={!isDirected}
              onChange={() => setIsDirected(false)}
              disabled={algorithmCategory === 'minimumSpanningTree'}
              className="form-radio h-4 w-4 text-blue-600"
            />
            <span className="ml-2">Non dirigé</span>
          </label>
          <label className="inline-flex items-center">
            <input
              type="radio"
              value="directed"
              checked={isDirected}
              onChange={() => setIsDirected(true)}
              disabled={algorithmCategory === 'minimumSpanningTree'}
              className="form-radio h-4 w-4 text-blue-600"
            />
            <span className="ml-2">Dirigé</span>
            {algorithmCategory === 'minimumSpanningTree' && 
              <span className="ml-2 text-xs text-red-500">(Non disponible pour ACM)</span>
            }
          </label>
        </div>
      </div>
      
      <div className="mb-4">
        <label htmlFor="graphInput" className="block text-sm font-medium text-gray-700 mb-1">
          {graphInputType === 'adjacencyMatrix' ? 'Matrice d\'adjacence' : 'Liste d\'adjacence'}
        </label>
        <textarea
          id="graphInput"
          rows={6}
          className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
          value={graphInput}
          onChange={(e) => setGraphInput(e.target.value)}
          placeholder={graphInputType === 'adjacencyMatrix' 
            ? "0 4 0\n4 0 2\n0 2 0" 
            : "A: B(4), C(2)\nB: A(4), C(1)\nC: A(2), B(1)"}
        />
        <p className="mt-1 text-sm text-gray-500">
          {graphInputType === 'adjacencyMatrix' 
            ? 'Entrez les poids des arêtes (0 pour aucune connexion)' 
            : 'Format: Nœud: Voisin1(poids1), Voisin2(poids2), ... - Exemple: A: B(4), C(2)'}
        </p>
      </div>
      
      <div className="mb-4">
        <label htmlFor="nodeLabels" className="block text-sm font-medium text-gray-700 mb-1">
          {graphInputType === 'adjacencyMatrix' 
            ? 'Labels des nœuds (séparés par des virgules)' 
            : 'Labels des nœuds (optionnel)'}
        </label>
        <textarea
          id="nodeLabels"
          rows={3}
          className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
          value={nodeLabels}
          onChange={(e) => setNodeLabels(e.target.value)}
          placeholder={graphInputType === 'adjacencyMatrix' 
            ? "A, B, C" 
            : ""}
        />
        <p className="mt-1 text-sm text-gray-500">
          {graphInputType === 'adjacencyMatrix' 
            ? 'Optionnel: noms des nœuds dans l\'ordre de la matrice' 
            : 'Pour la liste d\'adjacence, les labels sont déjà définis par les IDs'}
        </p>
      </div>
      
      <div className="flex flex-wrap gap-3 mb-2">
        <button
          className="px-4 py-2 bg-gray-200 text-gray-800 rounded hover:bg-gray-300"
          onClick={setExampleGraph}
        >
          Charger un exemple
        </button>
        
        <button
          className="px-4 py-2 bg-gray-200 text-gray-800 rounded hover:bg-gray-300"
          onClick={createGraph}
        >
          Générer le graphe
        </button>
        
        <button
          className="px-4 py-2 bg-gray-200 text-gray-800 rounded hover:bg-gray-300"
          onClick={exportConfig}
          disabled={!graph}
        >
          Exporter
        </button>
        
        <label className="px-4 py-2 bg-gray-200 text-gray-800 rounded hover:bg-gray-300 cursor-pointer">
          Importer
          <input
            type="file"
            accept=".json"
            onChange={importConfig}
            className="hidden"
          />
        </label>
      </div>
    </div>
  );
};

export default GraphInput;// END OF FILE: src/app/graph-algorithms/components/GraphInput.tsx

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/app/graph-algorithms/components/GraphVisualization.tsx

// src/app/graph-algorithms/components/GraphVisualization.tsx
'use client';

import React, { useRef, useEffect } from 'react';
import { GraphWeighted, Edge } from '@/lib/models/GraphWeighted';
import { AlgorithmCategory } from '../page';

interface GraphVisualizationProps {
  graph: GraphWeighted | null;
  result: any | null;
  algorithmCategory: AlgorithmCategory;
  startNodeId: string;
  endNodeId: string;
  isAnimating: boolean;
  setIsAnimating: (isAnimating: boolean) => void;
  animationStep: number;
  setAnimationStep: (step: number) => void;
  animationSpeed: number;
  setAnimationSpeed: (speed: number) => void;
  animationRef: React.MutableRefObject<number | null>;
  stopAnimation: () => void;
}

const GraphVisualization: React.FC<GraphVisualizationProps> = ({
  graph,
  result,
  algorithmCategory,
  startNodeId,
  endNodeId,
  isAnimating,
  setIsAnimating,
  animationStep,
  setAnimationStep,
  animationSpeed,
  setAnimationSpeed,
  animationRef,
  stopAnimation
}) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  
  // Effet pour dessiner le graphe quand il change
  useEffect(() => {
    if (graph && result) {
      drawGraph(graph, result);
    }
  }, [graph, result, algorithmCategory, startNodeId, endNodeId]);
  
  // Fonction pour télécharger l'image du graphe
  const downloadImage = () => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const link = document.createElement('a');
    link.download = `graph-${algorithmCategory}-${new Date().toISOString().slice(0, 10)}.png`;
    link.href = canvas.toDataURL('image/png');
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };
  
  // Fonction pour dessiner le graphe avec les résultats de l'algorithme
  const drawGraph = (graph: GraphWeighted, algorithmResult: any) => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    
    // Récupérer les dimensions du canvas
    const width = canvas.width;
    const height = canvas.height;
    
    // Effacer le canvas
    ctx.clearRect(0, 0, width, height);
    
    // Récupérer les nœuds et les arêtes
    const nodes = graph.getNodes();
    const edges = graph.getEdges();
    
    // Calculer les positions des nœuds (disposition circulaire simple)
    const nodePositions = new Map<string, { x: number, y: number }>();
    const radius = Math.min(width, height) * 0.4;
    const centerX = width / 2;
    const centerY = height / 2;
    
    nodes.forEach((node, index) => {
      const angle = (2 * Math.PI * index) / nodes.length;
      const x = centerX + radius * Math.cos(angle);
      const y = centerY + radius * Math.sin(angle);
      nodePositions.set(node.id, { x, y });
    });
    
    // Obtenir la plage de poids pour l'épaisseur des arêtes
    const weightRange = graph.getWeightRange();
    const minWeight = weightRange.min;
    const maxWeight = weightRange.max;
    const weightDiff = maxWeight - minWeight;
    
    // Fonction pour vérifier si une arête fait partie de la solution
    const isEdgeInSolution = (edge: Edge): boolean => {
      if (!algorithmResult) return false;
      
      if (algorithmCategory === 'minimumSpanningTree') {
        // Pour les algorithmes MST
        return algorithmResult.minimumSpanningTree.some((e: Edge) => 
          (e.source === edge.source && e.target === edge.target) || 
          (!graph.directed && e.source === edge.target && e.target === edge.source)
        );
      } else if (algorithmCategory === 'shortestPath' && algorithmResult.path) {
        // Pour les algorithmes de plus courts chemins avec un chemin
        for (let i = 0; i < algorithmResult.path.length - 1; i++) {
          const source = algorithmResult.path[i];
          const target = algorithmResult.path[i + 1];
          if ((source === edge.source && target === edge.target) || 
              (!graph.directed && source === edge.target && target === edge.source)) {
            return true;
          }
        }
      }
      
      return false;
    };
    
    // Dessiner les arêtes
    edges.forEach(edge => {
      const source = nodePositions.get(edge.source);
      const target = nodePositions.get(edge.target);
      
      if (source && target) {
        ctx.beginPath();
        ctx.moveTo(source.x, source.y);
        ctx.lineTo(target.x, target.y);
        
        // Déterminer le style de ligne selon le résultat
        const inSolution = isEdgeInSolution(edge);
        
        if (inSolution) {
          ctx.strokeStyle = '#2563EB'; // Arêtes en surbrillance
          ctx.lineWidth = 3;
        } else {
          ctx.strokeStyle = '#9CA3AF';
          // Échelle d'épaisseur basée sur le poids
          const scaleFactor = weightDiff === 0 ? 1 : (edge.weight - minWeight) / weightDiff;
          ctx.lineWidth = 1 + scaleFactor * 2;
        }
        
        ctx.stroke();
        
        // Dessiner le poids de l'arête
        const midX = (source.x + target.x) / 2;
        const midY = (source.y + target.y) / 2;
        
        // Fond blanc pour meilleure lisibilité
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(midX, midY, 10, 0, 2 * Math.PI);
        ctx.fill();
        
        ctx.fillStyle = inSolution ? '#2563EB' : '#4B5563';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(edge.weight.toString(), midX, midY);
        
        // Dessiner une flèche pour les graphes dirigés
        if (graph.directed) {
          const dx = target.x - source.x;
          const dy = target.y - source.y;
          const angle = Math.atan2(dy, dx);
          
          const headLength = 10;
          const arrowX = target.x - 15 * Math.cos(angle);
          const arrowY = target.y - 15 * Math.sin(angle);
          
          ctx.beginPath();
          ctx.moveTo(arrowX, arrowY);
          ctx.lineTo(
            arrowX - headLength * Math.cos(angle - Math.PI / 6),
            arrowY - headLength * Math.sin(angle - Math.PI / 6)
          );
          ctx.lineTo(
            arrowX - headLength * Math.cos(angle + Math.PI / 6),
            arrowY - headLength * Math.sin(angle + Math.PI / 6)
          );
          ctx.closePath();
          ctx.fillStyle = inSolution ? '#2563EB' : '#9CA3AF';
          ctx.fill();
        }
      }
    });
    
    // Dessiner les nœuds
    nodes.forEach(node => {
      const pos = nodePositions.get(node.id);
      if (!pos) return;
      
      // Déterminer la couleur du nœud en fonction de l'algorithme
      let fillColor = '#ddd';
      let isHighlighted = false;
      
      if (algorithmCategory === 'traversal' && algorithmResult?.visitedOrder) {
        // Pour les algorithmes de parcours
        const visitIndex = algorithmResult.visitedOrder.indexOf(node.id);
        if (visitIndex >= 0) {
          // Dégradé de couleur basé sur l'ordre de visite
          const ratio = visitIndex / (algorithmResult.visitedOrder.length - 1);
          const r = Math.floor(255 * ratio);
          const g = Math.floor(255 * (1 - ratio * 0.5));
          const b = Math.floor(100 * (1 - ratio));
          fillColor = `rgb(${r}, ${g}, ${b})`;
        }
      } else if (algorithmCategory === 'shortestPath') {
        // Pour les algorithmes de plus courts chemins
        if (node.id === startNodeId) {
          fillColor = '#3B82F6'; // Nœud de départ en bleu
          isHighlighted = true;
        } else if (node.id === endNodeId) {
          fillColor = '#EF4444'; // Nœud d'arrivée en rouge
          isHighlighted = true;
        } else if (algorithmResult?.path?.includes(node.id)) {
          fillColor = '#8B5CF6'; // Nœuds sur le chemin en violet
          isHighlighted = true;
        } else if (algorithmResult?.distances?.get(node.id) < Infinity) {
          // Dégradé basé sur la distance
          const distance = algorithmResult.distances.get(node.id);
          const maxDistance = Math.max(...Array.from(algorithmResult.distances.values()).filter(d => d < Infinity));
          const ratio = distance / maxDistance;
          const g = Math.floor(220 * (1 - ratio));
          fillColor = `rgb(220, ${g}, 220)`;
        }
      } else if (algorithmCategory === 'minimumSpanningTree') {
        // Pour les algorithmes MST
        const inMST = algorithmResult?.minimumSpanningTree.some((edge: Edge) => 
          edge.source === node.id || edge.target === node.id
        );
        
        if (inMST) {
          fillColor = '#10B981'; // Nœuds dans MST en vert
          isHighlighted = true;
        }
      }
      
      // Cas spécial pour le nœud de départ
      if (node.id === startNodeId) {
        fillColor = '#3B82F6'; // Nœud de départ en bleu
        isHighlighted = true;
      }
      
      // Dessiner le cercle du nœud
      ctx.beginPath();
      ctx.arc(pos.x, pos.y, 20, 0, 2 * Math.PI);
      ctx.fillStyle = fillColor;
      ctx.fill();
      ctx.strokeStyle = isHighlighted ? '#000' : '#666';
      ctx.lineWidth = isHighlighted ? 3 : 1;
      ctx.stroke();
      
      // Dessiner l'étiquette du nœud
      ctx.fillStyle = '#000';
      ctx.font = '14px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(node.label || node.id, pos.x, pos.y);
      
      // Pour les algorithmes de plus courts chemins, afficher la distance si disponible
      if (algorithmCategory === 'shortestPath' && algorithmResult?.distances) {
        const distance = algorithmResult.distances.get(node.id);
        if (distance !== undefined && distance < Infinity) {
          ctx.beginPath();
          ctx.arc(pos.x + 20, pos.y - 15, 15, 0, 2 * Math.PI);
          ctx.fillStyle = '#FFF';
          ctx.fill();
          ctx.strokeStyle = '#666';
          ctx.lineWidth = 1;
          ctx.stroke();
          
          ctx.fillStyle = '#000';
          ctx.font = '12px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(distance.toString(), pos.x + 20, pos.y - 15);
        }
      }
    });
  };
  
  // Fonction pour animer l'exécution de l'algorithme
  const animateAlgorithm = () => {
    if (!graph || !result) return;
    
    setIsAnimating(true);
    setAnimationStep(0);
    
    const totalSteps = getAnimationStepsCount();
    
    const animate = (step: number) => {
      if (step >= totalSteps) {
        setIsAnimating(false);
        return;
      }
      
      setAnimationStep(step + 1);
      drawGraphWithAnimation(graph, result, step + 1);
      
      animationRef.current = window.setTimeout(() => {
        animate(step + 1);
      }, animationSpeed);
    };
    
    animate(0);
  };
  
  // Fonction pour dessiner le graphe avec animation
  const drawGraphWithAnimation = (graph: GraphWeighted, algorithmResult: any, step: number) => {
    // Pour l'instant, on utilise simplement le même dessin que drawGraph
    // Une implémentation plus complète montrerait une animation spécifique à chaque étape
    // selon l'algorithme utilisé
    drawGraph(graph, algorithmResult);
    
    // Ajouter un compteur d'étapes
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.fillRect(10, 10, 100, 30);
    ctx.fillStyle = '#FFF';
    ctx.font = '14px Arial';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    ctx.fillText(`Étape: ${step}`, 20, 25);
  };
  
  // Obtenir le nombre d'étapes d'animation en fonction de l'algorithme
  const getAnimationStepsCount = (): number => {
    if (!result) return 0;
    
    if (algorithmCategory === 'traversal') {
      return result.visitedOrder?.length || 0;
    } else if (algorithmCategory === 'shortestPath') {
      return result.steps?.length || 0;
    } else if (algorithmCategory === 'minimumSpanningTree') {
      return result.steps?.length || 0;
    }
    
    return 0;
  };
  
  return (
    <div>
      <canvas
        ref={canvasRef}
        width={600}
        height={400}
        className="w-full border border-gray-300 rounded-lg bg-gray-50"
        style={{ cursor: 'grab' }}
      />
      
      <div className="mt-4 mb-2">
        <h3 className="font-medium mb-2">Animation de l'algorithme</h3>
        <div className="flex flex-wrap items-center gap-4">
          <button
            className={`px-3 py-1 rounded ${isAnimating ? 'bg-red-500 text-white' : 'bg-blue-500 text-white'}`}
            onClick={isAnimating ? stopAnimation : animateAlgorithm}
            disabled={!result}
          >
            {isAnimating ? 'Arrêter' : 'Animer l\'algorithme'}
          </button>
          
          <div className="flex items-center gap-2">
            <span className="text-sm">Vitesse:</span>
            <input
              type="range"
              min="100"
              max="2000"
              step="100"
              value={animationSpeed}
              onChange={(e) => setAnimationSpeed(parseInt(e.target.value))}
              className="w-32"
            />
            <span className="text-sm">{animationSpeed}ms</span>
          </div>
          
          {result && (
            <div className="text-sm">
              Étape: {animationStep} / {getAnimationStepsCount()}
            </div>
          )}
        </div>
      </div>
      
      <button
        className="mt-2 px-3 py-1 bg-gray-200 text-gray-800 rounded hover:bg-gray-300"
        onClick={downloadImage}
        disabled={!graph}
      >
        Télécharger l'image
      </button>
      
      {/* Légende adaptative selon l'algorithme */}
      <div className="mt-4 border-t pt-4">
        <h3 className="font-medium mb-2">Légende:</h3>
        <div className="grid grid-cols-2 md:grid-cols-3 gap-2">
          {algorithmCategory === 'traversal' && (
            <>
              <div className="flex items-center gap-2">
                <div className="w-4 h-4 rounded-full bg-blue-500 border border-gray-400"></div>
                <span className="text-xs">Nœud de départ</span>
              </div>
              <div className="flex items-center gap-2">
                <div className="w-4 h-4 rounded-full bg-green-500 border border-gray-400"></div>
                <span className="text-xs">Premiers nœuds visités</span>
              </div>
              <div className="flex items-center gap-2">
                <div className="w-4 h-4 rounded-full bg-red-500 border border-gray-400"></div>
                <span className="text-xs">Derniers nœuds visités</span>
              </div>
            </>
          )}
          
          {algorithmCategory === 'shortestPath' && (
            <>
              <div className="flex items-center gap-2">
                <div className="w-4 h-4 rounded-full bg-blue-500 border border-gray-400"></div>
                <span className="text-xs">Nœud de départ</span>
              </div>
              <div className="flex items-center gap-2">
                <div className="w-4 h-4 rounded-full bg-red-500 border border-gray-400"></div>
                <span className="text-xs">Nœud d'arrivée</span>
              </div>
              <div className="flex items-center gap-2">
                <div className="w-4 h-4 rounded-full bg-purple-500 border border-gray-400"></div>
                <span className="text-xs">Nœuds sur le chemin</span>
              </div>
              <div className="flex items-center gap-2">
                <div className="h-1 w-8 bg-blue-500"></div>
                <span className="text-xs">Arêtes du chemin</span>
              </div>
              <div className="flex items-center gap-2">
                <div className="relative w-4 h-4">
                  <div className="absolute inset-0 flex items-center justify-center text-xs font-bold">D</div>
                </div>
                <span className="text-xs">Distances</span>
              </div>
            </>
          )}
          
          {algorithmCategory === 'minimumSpanningTree' && (
            <>
              <div className="flex items-center gap-2">
                <div className="w-4 h-4 rounded-full bg-green-500 border border-gray-400"></div>
                <span className="text-xs">Nœuds dans l'ACM</span>
              </div>
              <div className="flex items-center gap-2">
                <div className="h-1 w-8 bg-blue-500"></div>
                <span className="text-xs">Arêtes de l'ACM</span>
              </div>
              <div className="flex items-center gap-2">
                <div className="w-4 h-4 rounded-full bg-blue-500 border border-gray-400"></div>
                <span className="text-xs">Nœud de départ (Prim)</span>
              </div>
            </>
          )}
        </div>
      </div>
    </div>
  );
};

export default GraphVisualization;// END OF FILE: src/app/graph-algorithms/components/GraphVisualization.tsx

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/app/graph-algorithms/components/ResultsPanel.tsx

// src/app/graph-algorithms/components/ResultsPanel.tsx
'use client';

import React from 'react';
import { GraphWeighted, Edge } from '@/lib/models/GraphWeighted';
import {
  AlgorithmCategory,
  TraversalAlgorithm,
  ShortestPathAlgorithm,
  MSTAlgorithm
} from '../page';

// Définir les types corrects pour "result"
interface TraversalResult {
  visitedOrder: string[];
  visitedNodes: Set<string>;
}

interface ShortestPathResult {
  distances: Map<string, number>;
  predecessors: Map<string, string | null>;
  path: string[];
  hasNegativeCycle?: boolean;
}

interface MSTResult {
  totalWeight: number;
  minimumSpanningTree: Edge[];
}

type ResultType = TraversalResult | ShortestPathResult | MSTResult;

interface ResultsPanelProps {
  result: ResultType;
  graph: GraphWeighted | null;
  algorithmCategory: AlgorithmCategory;
  startNodeId: string;
  endNodeId: string;
  traversalAlgorithm: TraversalAlgorithm;
  shortestPathAlgorithm: ShortestPathAlgorithm;
  mstAlgorithm: MSTAlgorithm;
  getCurrentAlgorithmName: () => string;
}

const ResultsPanel: React.FC<ResultsPanelProps> = ({
  result,
  graph,
  algorithmCategory,
  startNodeId,
  endNodeId,
  traversalAlgorithm,
  shortestPathAlgorithm,
  mstAlgorithm,
  getCurrentAlgorithmName
}) => {
  if (!result || !graph) return null;
  
  return (
    <div className="bg-white rounded-lg shadow-md p-6">
      <h2 className="text-xl font-semibold mb-4">Résultats de {getCurrentAlgorithmName()}</h2>

      {/* Traversal algorithms */}
      {algorithmCategory === 'traversal' && (
        <div>
          <div className="mb-4">
            <h3 className="font-medium mb-1">Ordre de visite:</h3>
            <p className="bg-gray-100 p-2 rounded overflow-x-auto">
              {(result as TraversalResult).visitedOrder.map((id, index) => {
                const node = graph?.getNodes().find(n => n.id === id);
                return `${index + 1}. ${node?.label || id}`;
              }).join(' → ')}
            </p>
          </div>

          <div className="mb-4">
            <h3 className="font-medium mb-1">Nœuds accessibles:</h3>
            <p className="bg-gray-100 p-2 rounded">
              {(result as TraversalResult).visitedNodes.size} sur {graph.getNodes().length} nœuds
            </p>
          </div>
        </div>
      )}

      {/* Shortest path algorithms */}
      {algorithmCategory === 'shortestPath' && (
        <div>
          <div className="mb-4">
            <h3 className="font-medium mb-1">
              Distances depuis {graph.getNodes().find(n => n.id === startNodeId)?.label || startNodeId}:
            </h3>
            <div className="bg-gray-100 p-2 rounded max-h-64 overflow-y-auto">
              <table className="w-full text-sm">
                <thead>
                  <tr>
                    <th className="text-left p-1">Nœud</th>
                    <th className="text-left p-1">Distance</th>
                    <th className="text-left p-1">Prédécesseur</th>
                  </tr>
                </thead>
                <tbody>
                  {Array.from((result as ShortestPathResult).distances.entries()).map(([nodeId, distance]) => {
                    const node = graph.getNodes().find(n => n.id === nodeId);
                    const predecessor = (result as ShortestPathResult).predecessors.get(nodeId);
                    const predecessorNode = predecessor ? graph.getNodes().find(n => n.id === predecessor) : null;

                    return (
                      <tr key={nodeId} className="border-t border-gray-200">
                        <td className="p-1 font-medium">{node?.label || nodeId}</td>
                        <td className="p-1">{distance === Infinity ? "∞" : distance}</td>
                        <td className="p-1">{predecessorNode?.label || predecessor || "-"}</td>
                      </tr>
                    );
                  })}
                </tbody>
              </table>
            </div>
          </div>

          {endNodeId && (result as ShortestPathResult).path && (
            <div className="mb-4">
              <h3 className="font-medium mb-1">
                Chemin le plus court vers {graph.getNodes().find(n => n.id === endNodeId)?.label || endNodeId}:
              </h3>
              <div className="bg-gray-100 p-2 rounded">
                <p className="font-medium mb-1">
                  Distance: {(result as ShortestPathResult).distances.get(endNodeId) === Infinity
                    ? "∞ (inaccessible)"
                    : (result as ShortestPathResult).distances.get(endNodeId)}
                </p>
                {(result as ShortestPathResult).path.length > 0 ? (
                  <p>
                    Chemin: {(result as ShortestPathResult).path.map(id => {
                      const node = graph.getNodes().find(n => n.id === id);
                      return node?.label || id;
                    }).join(' → ')}
                  </p>
                ) : (
                  <p>Aucun chemin trouvé</p>
                )}
              </div>
            </div>
          )}

          {shortestPathAlgorithm === 'bellmanFord' && (
            <div className="mb-4">
              <h3 className="font-medium mb-1">Détection de cycle négatif:</h3>
              <p className={`bg-gray-100 p-2 rounded ${(result as ShortestPathResult).hasNegativeCycle ? 'text-red-600 font-medium' : ''}`}>
                {(result as ShortestPathResult).hasNegativeCycle
                  ? "Un cycle de poids négatif a été détecté dans le graphe."
                  : "Aucun cycle de poids négatif détecté."}
              </p>
            </div>
          )}
        </div>
      )}

      {/* Minimum spanning tree algorithms */}
      {algorithmCategory === 'minimumSpanningTree' && (
        <div>
          <div className="mb-4">
            <h3 className="font-medium mb-1">Arbre couvrant minimal:</h3>
            <p className="bg-gray-100 p-2 rounded font-medium">
              Poids total: {(result as MSTResult).totalWeight}
            </p>
          </div>

          <div className="mb-4">
            <h3 className="font-medium mb-1">Arêtes de l'ACM:</h3>
            <div className="bg-gray-100 p-2 rounded max-h-64 overflow-y-auto">
              <table className="w-full text-sm">
                <thead>
                  <tr>
                    <th className="text-left p-1">#</th>
                    <th className="text-left p-1">De</th>
                    <th className="text-left p-1">Vers</th>
                    <th className="text-right p-1">Poids</th>
                  </tr>
                </thead>
                <tbody>
                  {(result as MSTResult).minimumSpanningTree.map((edge, index) => {
                    const sourceNode = graph.getNodes().find(n => n.id === edge.source);
                    const targetNode = graph.getNodes().find(n => n.id === edge.target);

                    return (
                      <tr key={index} className="border-t border-gray-200">
                        <td className="p-1">{index + 1}</td>
                        <td className="p-1">{sourceNode?.label || edge.source}</td>
                        <td className="p-1">{targetNode?.label || edge.target}</td>
                        <td className="p-1 text-right">{edge.weight}</td>
                      </tr>
                    );
                  })}
                </tbody>
              </table>
            </div>
          </div>

          <div className="mb-4">
            <h3 className="font-medium mb-1">Couverture:</h3>
            <p className="bg-gray-100 p-2 rounded">
              {(result as MSTResult).minimumSpanningTree.length} arêtes sur {graph.getNodes().length - 1} nécessaires
              {(result as MSTResult).minimumSpanningTree.length < (graph.getNodes().length - 1) && (
                <span className="text-amber-600 ml-2 font-medium">
                  (Le graphe n'est pas connexe)
                </span>
              )}
            </p>
          </div>
        </div>
      )}
    </div>
  );
};

export default ResultsPanel;
// END OF FILE: src/app/graph-algorithms/components/ResultsPanel.tsx

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/app/graph-algorithms/hooks/useGraphAlgorithms.tsx

// END OF FILE: src/app/graph-algorithms/hooks/useGraphAlgorithms.tsx

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/app/graph-algorithms/hooks/useGraphDrawing.tsx

// END OF FILE: src/app/graph-algorithms/hooks/useGraphDrawing.tsx

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/app/graph-algorithms/page.tsx

// src/app/graph-algorithms/page.tsx
'use client';

import React, { useState, useRef } from 'react';
import Link from 'next/link';
import { GraphWeighted } from '@/lib/models/GraphWeighted';
import GraphInput from './components/GraphInput';
import AlgorithmSelector from './components/AlgorithmSelector';
import GraphVisualization from './components/GraphVisualization';
import ResultsPanel from './components/ResultsPanel';

// Types des algorithmes
export type AlgorithmCategory = 'traversal' | 'shortestPath' | 'minimumSpanningTree';
export type TraversalAlgorithm = 'dfs' | 'bfs';
export type ShortestPathAlgorithm = 'dijkstra' | 'bellmanFord';
export type MSTAlgorithm = 'kruskal' | 'prim';
export type GraphInputType = 'adjacencyMatrix' | 'adjacencyList';

export default function GraphAlgorithmsPage() {
  // État du graphe
  const [graph, setGraph] = useState<GraphWeighted | null>(null);
  const [error, setError] = useState<string | null>(null);
  
  // État des algorithmes
  const [algorithmCategory, setAlgorithmCategory] = useState<AlgorithmCategory>('traversal');
  const [traversalAlgorithm, setTraversalAlgorithm] = useState<TraversalAlgorithm>('dfs');
  const [shortestPathAlgorithm, setShortestPathAlgorithm] = useState<ShortestPathAlgorithm>('dijkstra');
  const [mstAlgorithm, setMSTAlgorithm] = useState<MSTAlgorithm>('kruskal');
  
  // État des nœuds
  const [startNodeId, setStartNodeId] = useState<string>('0');
  const [endNodeId, setEndNodeId] = useState<string>('');
  
  // État des résultats
  const [result, setResult] = useState<any | null>(null);
  
  // Animation
  const [animationSpeed, setAnimationSpeed] = useState<number>(1000);
  const [isAnimating, setIsAnimating] = useState<boolean>(false);
  const [animationStep, setAnimationStep] = useState<number>(0);
  const animationRef = useRef<number | null>(null);
  
  // Gestion de la direction du graphe (utile pour MST)
  const [isDirected, setIsDirected] = useState<boolean>(false);
  
  // Effet secondaire pour mettre à jour la direction si on change de catégorie
  React.useEffect(() => {
    if (algorithmCategory === 'minimumSpanningTree' && isDirected) {
      setIsDirected(false); // Les MST nécessitent un graphe non dirigé
    }
  }, [algorithmCategory, isDirected]);
  
  // Fonction d'exécution d'algorithme (sera passée aux composants enfants)
  const runAlgorithm = (algorithmResult: any) => {
    setResult(algorithmResult);
    setAnimationStep(0);
    stopAnimation();
  };
  
  // Fonction pour arrêter l'animation
  const stopAnimation = () => {
    if (animationRef.current) {
      clearTimeout(animationRef.current);
      animationRef.current = null;
    }
    setIsAnimating(false);
  };
  
  // Nettoyage des animations à la sortie
  React.useEffect(() => {
    return () => {
      if (animationRef.current) {
        clearTimeout(animationRef.current);
      }
    };
  }, []);
  
  // Helper pour obtenir le nom de l'algorithme actuel
  const getCurrentAlgorithmName = (): string => {
    if (algorithmCategory === 'traversal') {
      return traversalAlgorithm === 'dfs' ? 'Parcours en Profondeur (DFS)' : 'Parcours en Largeur (BFS)';
    } else if (algorithmCategory === 'shortestPath') {
      return shortestPathAlgorithm === 'dijkstra' ? 'Algorithme de Dijkstra' : 'Algorithme de Bellman-Ford';
    } else {
      return mstAlgorithm === 'kruskal' ? 'Algorithme de Kruskal' : 'Algorithme de Prim';
    }
  };

  return (
    <div className="container mx-auto px-4 py-8">
      <div className="mb-6">
        <Link href="/" className="text-blue-600 hover:underline inline-flex items-center">
          <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor">
            <path fillRule="evenodd" d="M9.707 14.707a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 1.414L7.414 9H15a1 1 0 110 2H7.414l2.293 2.293a1 1 0 010 1.414z" clipRule="evenodd" />
          </svg>
          Retour à l'accueil
        </Link>
      </div>
      
      <h1 className="text-3xl font-bold mb-6">Visualisation d'Algorithmes de Graphes</h1>
      
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
        {/* Panneau gauche: entrée et configuration */}
        <div>
          <div className="bg-white rounded-lg shadow-md p-6 mb-6">
            <h2 className="text-xl font-semibold mb-4">Configuration du Graphe</h2>
            
            {/* Composant d'entrée de graphe */}
            <GraphInput 
              graph={graph}
              setGraph={setGraph}
              algorithmCategory={algorithmCategory}
              setError={setError}
              isDirected={isDirected}
              setIsDirected={setIsDirected}
            />
          </div>
          
          <div className="bg-white rounded-lg shadow-md p-6">
            <h2 className="text-xl font-semibold mb-4">Sélection de l'Algorithme</h2>
            
            {/* Composant de sélection d'algorithme */}
            <AlgorithmSelector 
              graph={graph}
              algorithmCategory={algorithmCategory}
              setAlgorithmCategory={setAlgorithmCategory}
              traversalAlgorithm={traversalAlgorithm}
              setTraversalAlgorithm={setTraversalAlgorithm}
              shortestPathAlgorithm={shortestPathAlgorithm}
              setShortestPathAlgorithm={setShortestPathAlgorithm}
              mstAlgorithm={mstAlgorithm}
              setMSTAlgorithm={setMSTAlgorithm}
              startNodeId={startNodeId}
              setStartNodeId={setStartNodeId}
              endNodeId={endNodeId}
              setEndNodeId={setEndNodeId}
              runAlgorithm={runAlgorithm}
              error={error}
              setError={setError}
              getCurrentAlgorithmName={getCurrentAlgorithmName}
            />
          </div>
        </div>
        
        {/* Panneau droit: visualisation et résultats */}
        <div>
          <div className="bg-white rounded-lg shadow-md p-6 mb-6">
            <h2 className="text-xl font-semibold mb-4">Visualisation du Graphe</h2>
            
            {/* Composant de visualisation */}
            <GraphVisualization 
              graph={graph}
              result={result}
              algorithmCategory={algorithmCategory}
              startNodeId={startNodeId}
              endNodeId={endNodeId}
              isAnimating={isAnimating}
              setIsAnimating={setIsAnimating}
              animationStep={animationStep}
              setAnimationStep={setAnimationStep}
              animationSpeed={animationSpeed}
              setAnimationSpeed={setAnimationSpeed}
              animationRef={animationRef}
              stopAnimation={stopAnimation}
            />
          </div>
          
          {/* Affichage des résultats conditionnels */}
          {result && (
            <ResultsPanel 
              result={result}
              graph={graph}
              algorithmCategory={algorithmCategory}
              startNodeId={startNodeId}
              endNodeId={endNodeId}
              traversalAlgorithm={traversalAlgorithm}
              shortestPathAlgorithm={shortestPathAlgorithm}
              mstAlgorithm={mstAlgorithm}
              getCurrentAlgorithmName={getCurrentAlgorithmName}
            />
          )}
        </div>
      </div>
    </div>
  );
}// END OF FILE: src/app/graph-algorithms/page.tsx

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/app/graph-algorithms/styles.module.css

/* src/app/graph-algorithms/styles.module.css */
.graphCanvas {
    background-color: #f9fafb;
    border: 1px solid #e5e7eb;
    cursor: grab;
    transition: all 0.2s ease;
  }
  
  .graphCanvas:active {
    cursor: grabbing;
  }
  
  .nodeTooltip {
    position: absolute;
    background-color: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 12px;
    pointer-events: none;
    z-index: 10;
  }
  
  .algorithmControls {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-bottom: 16px;
  }
  
  .resultBox {
    background-color: #f3f4f6;
    border-radius: 6px;
    padding: 12px;
    margin-bottom: 12px;
  }
  
  .legend {
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    margin-top: 16px;
  }
  
  .legendItem {
    display: flex;
    align-items: center;
    gap: 6px;
  }
  
  .colorBox {
    width: 16px;
    height: 16px;
    border-radius: 4px;
    border: 1px solid #d1d5db;
  }
  
  .slider {
    -webkit-appearance: none;
    appearance: none;
    width: 100%;
    height: 6px;
    background: #d1d5db;
    outline: none;
    border-radius: 3px;
  }
  
  .slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 16px;
    height: 16px;
    background: #3b82f6;
    cursor: pointer;
    border-radius: 50%;
  }
  
  .slider::-moz-range-thumb {
    width: 16px;
    height: 16px;
    background: #3b82f6;
    cursor: pointer;
    border-radius: 50%;
  }
  
  .tooltip {
    position: absolute;
    background-color: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 12px;
    pointer-events: none;
    z-index: 10;
  }
  
  .nodeLabel {
    font-size: 14px;
    font-weight: 500;
    fill: #1f2937;
    text-anchor: middle;
    pointer-events: none;
  }
  
  .helpIcon {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background-color: #e5e7eb;
    color: #4b5563;
    font-size: 12px;
    cursor: help;
    margin-left: 4px;
  }
  
  .button {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 0.5rem 1rem;
    font-size: 0.875rem;
    font-weight: 500;
    line-height: 1.25rem;
    border-radius: 0.375rem;
    border: 1px solid transparent;
    cursor: pointer;
    transition: all 150ms cubic-bezier(0.4, 0, 0.2, 1);
  }
  
  .buttonPrimary {
    background-color: #3b82f6;
    color: white;
  }
  
  .buttonPrimary:hover {
    background-color: #2563eb;
  }
  
  .buttonSecondary {
    background-color: #f3f4f6;
    color: #1f2937;
    border-color: #d1d5db;
  }
  
  .buttonSecondary:hover {
    background-color: #e5e7eb;
  }
  
  /* Animation pour les transitions */
  @keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }
  
  .fadeIn {
    animation: fadeIn 0.3s ease-in-out;
  }
  
  /* Styles pour les tables */
  .resultTable {
    width: 100%;
    border-collapse: collapse;
  }
  
  .resultTable th {
    text-align: left;
    padding: 8px;
    background-color: #f3f4f6;
    font-weight: 500;
  }
  
  .resultTable td {
    padding: 8px;
    border-top: 1px solid #e5e7eb;
  }
  
  .resultTable tr:hover {
    background-color: #f9fafb;
  }
  
  /* Responsive styles */
  @media (max-width: 768px) {
    .legend {
      flex-direction: column;
      align-items: flex-start;
    }
    
    .algorithmControls {
      flex-direction: column;
      align-items: flex-start;
    }
  }
  
  /* Animation pour les nœuds */
  @keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); }
  }
  
  .nodePulse {
    animation: pulse 1s infinite;
  }
  
  /* Amélioration de l'affichage du code */
  .codeBlock {
    background-color: #f8f8f8;
    border: 1px solid #e8e8e8;
    border-radius: 4px;
    padding: 12px;
    font-family: 'Courier New', monospace;
    overflow-x: auto;
    line-height: 1.5;
  }
  
  /* Style pour la section algorithmes */
  .algorithmInfo {
    background-color: #f0f9ff;
    border: 1px solid #bae6fd;
    border-radius: 6px;
    padding: 12px;
    margin-bottom: 16px;
  }
  
  .algorithmInfo h3 {
    color: #0369a1;
    margin-bottom: 8px;
  }
  
  .algorithmInfo p {
    color: #0c4a6e;
    font-size: 0.875rem;
    line-height: 1.5;
  }// END OF FILE: src/app/graph-algorithms/styles.module.css

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/app/layout.tsx

// src/app/layout.tsx
import './globals.css';
import { FamilyProvider } from '../context/FamilyContext';
import { Inter } from 'next/font/google';
import Link from 'next/link';

const inter = Inter({ subsets: ['latin'] });

export const metadata = {
  title: 'Arbre Généalogique',
  description: 'Application d\'arbre généalogique interactive',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="fr">
      <body className={inter.className}>
        <FamilyProvider>
          <div className="min-h-screen flex flex-col">
            <header className="bg-white shadow-sm">
              <div className="container mx-auto px-4 py-4">
                <div className="flex justify-between items-center">
                  <Link href="/" className="font-bold text-2xl text-blue-600">
                    ArbreGénéa
                  </Link>
                  
                  <nav>
                    <ul className="flex space-x-6">
                      <li>
                        <Link href="/" className="hover:text-blue-600 transition">
                          Accueil
                        </Link>
                      </li>
                      <li>
                        <Link href="/family" className="hover:text-blue-600 transition">
                            Familles
                        </Link>
                        </li>
                      <li>
                        <Link href="/tree" className="hover:text-blue-600 transition">
                          Arbre
                        </Link>
                      </li>
                      <li>
                        <Link href="/person" className="hover:text-blue-600 transition">
                          Personnes
                        </Link>
                      </li>
                      <li>
                        <Link href="/search" className="hover:text-blue-600 transition">
                          Recherche
                        </Link>
                      </li>
                      <li>
                        <Link href="/graph-algorithms" className="hover:text-blue-600 transition">
                          Algorithmes de graphes
                        </Link>
                      </li>
                    </ul>
                  </nav>
                </div>
              </div>
            </header>
            
            <main className="flex-grow">
              {children}
            </main>
            
            <footer className="bg-gray-100 border-t">
              <div className="container mx-auto px-4 py-6">
                <div className="flex flex-col md:flex-row justify-between items-center">
                  <p className="text-gray-600 mb-4 md:mb-0">
                    © {new Date().getFullYear()} ArbreGénéa - Application darbre généalogique
                  </p>
                  
                  <div className="flex space-x-4">
                    <Link href="/about" className="text-gray-600 hover:text-blue-600 transition">
                      À propos
                    </Link>
                    <Link href="/help" className="text-gray-600 hover:text-blue-600 transition">
                      Aide
                    </Link>
                  </div>
                </div>
              </div>
            </footer>
          </div>
        </FamilyProvider>
      </body>
    </html>
  );
}// END OF FILE: src/app/layout.tsx

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/app/page.tsx

// src/app/page.tsx
'use client';

import React, { useState, useEffect } from 'react';
import Link from 'next/link';
import Image from 'next/image';
import { useFamily } from '@/context/FamilyContext';

export default function HomePage() {
  const { families, activeFamily, loading } = useFamily();
  const [showWelcome, setShowWelcome] = useState(true);

  // Effet pour faire disparaître le message de bienvenue après 5 secondes
  useEffect(() => {
    const timer = setTimeout(() => {
      setShowWelcome(false);
    }, 5000);
    return () => clearTimeout(timer);
  }, []);

  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-screen bg-gradient-to-b from-blue-50 to-white">
        <div className="text-center">
          <h2 className="text-2xl font-semibold mb-4 text-blue-800">Chargement de votre histoire familiale...</h2>
          <div className="w-16 h-16 border-4 border-t-blue-500 border-b-blue-700 border-l-blue-300 border-r-blue-600 rounded-full animate-spin mx-auto"></div>
        </div>
      </div>
    );
  }

  return (
    <main className="min-h-screen bg-gradient-to-br from-blue-50 via-white to-green-50">
      {/* Hero Section améliorée */}
      <section className="relative py-20 px-4 md:px-8 overflow-hidden">
        <div className="absolute inset-0 z-0 opacity-10">
          <div className="absolute inset-0 bg-repeat" style={{ backgroundImage: "url('/images.jpeg')", backgroundSize: '300px' }}></div>
        </div>
        
        <div className="container mx-auto relative z-10">
          <div className="flex flex-col md:flex-row items-center justify-between">
            <div className="md:w-1/2 text-center md:text-left mb-10 md:mb-0">
              <h1 className="text-5xl md:text-6xl font-bold mb-6 text-blue-800 leading-tight">
                Explorateur d'<span className="text-green-600">Arbre Généalogique</span>
              </h1>
              <p className="text-xl md:text-2xl text-gray-700 mb-8 max-w-xl mx-auto md:mx-0">
                Découvrez, analysez et enrichissez votre histoire familiale à travers les générations
              </p>
              
              {activeFamily ? (
                <div className="flex flex-col sm:flex-row gap-4 justify-center md:justify-start">
                  <Link href={`/tree?familyId=${activeFamily.id}`} 
                    className="px-8 py-3 bg-blue-600 hover:bg-blue-700 text-white rounded-lg transition shadow-lg hover:shadow-xl transform hover:-translate-y-1 flex items-center justify-center">
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                      <path d="M9 4.804A7.968 7.968 0 005.5 4c-1.255 0-2.443.29-3.5.804v10A7.969 7.969 0 015.5 14c1.669 0 3.218.51 4.5 1.385A7.962 7.962 0 0114.5 14c1.255 0 2.443.29 3.5.804v-10A7.968 7.968 0 0014.5 4c-1.255 0-2.443.29-3.5.804V12a1 1 0 11-2 0V4.804z" />
                    </svg>
                    Visualiser l'arbre
                  </Link>
                  <Link href={`/person/new?familyId=${activeFamily.id}`} 
                    className="px-8 py-3 bg-green-600 hover:bg-green-700 text-white rounded-lg transition shadow-lg hover:shadow-xl transform hover:-translate-y-1 flex items-center justify-center">
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                      <path fillRule="evenodd" d="M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z" clipRule="evenodd" />
                    </svg>
                    Ajouter une personne
                  </Link>
                </div>
              ) : (
                <Link href="/family" 
                  className="px-8 py-3 bg-blue-600 hover:bg-blue-700 text-white rounded-lg transition shadow-lg hover:shadow-xl transform hover:-translate-y-1 inline-flex items-center">
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                    <path d="M9 6a3 3 0 11-6 0 3 3 0 016 0zM17 6a3 3 0 11-6 0 3 3 0 016 0zM12.93 17c.046-.327.07-.66.07-1a6.97 6.97 0 00-1.5-4.33A5 5 0 0119 16v1h-6.07zM6 11a5 5 0 015 5v1H1v-1a5 5 0 015-5z" />
                  </svg>
                  Créer mon premier arbre
                </Link>
              )}
            </div>
            
            <div className="md:w-1/2 flex justify-center">
              <div className="relative w-64 h-64 md:w-80 md:h-80 lg:w-96 lg:h-96">
                <div className="absolute inset-0 bg-blue-100 rounded-full animate-pulse"></div>
                <div className="absolute inset-4 bg-white rounded-full shadow-xl flex items-center justify-center">
                  <Image src="/globe.svg" alt="Family Tree Globe" width={300} height={300} className="transform animate-spin-slow" />
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>

      {/* Message de bienvenue avec animation */}
      {showWelcome && activeFamily && (
        <div className="fixed top-6 right-6 bg-white p-4 rounded-lg shadow-lg border-l-4 border-green-500 max-w-sm animate-fade-in-right z-50">
          <div className="flex items-start">
            <div className="bg-green-100 p-2 rounded-full mr-3">
              <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 text-green-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
              </svg>
            </div>
            <div className="flex-1">
              <h3 className="font-medium text-gray-900">Arbre actif</h3>
              <p className="text-sm text-gray-600">Vous travaillez actuellement sur l'arbre "{activeFamily.name}"</p>
            </div>
            <button onClick={() => setShowWelcome(false)} className="text-gray-400 hover:text-gray-600">
              <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                <path fillRule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clipRule="evenodd" />
              </svg>
            </button>
          </div>
        </div>
      )}

      {/* Section des fonctionnalités */}
      <section className="py-16 px-4 md:px-8">
        <div className="container mx-auto">
          <h2 className="text-3xl font-bold text-center mb-12 text-gray-800">Votre espace généalogique</h2>
          
          <div className="grid md:grid-cols-2 gap-8">
            {/* Actions rapides */}
            <div className="bg-white rounded-xl shadow-xl p-8 transform transition-all hover:shadow-2xl border-t-4 border-blue-500">
              <div className="flex items-center mb-6">
                <div className="bg-blue-100 p-3 rounded-lg mr-4">
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-8 w-8 text-blue-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 10V3L4 14h7v7l9-11h-7z" />
                  </svg>
                </div>
                <h2 className="text-2xl font-bold text-gray-800">Actions rapides</h2>
              </div>
              
              <ul className="space-y-4">
                <li className="transform transition-transform hover:translate-x-2">
                  <Link href="/family" className="flex items-center p-3 bg-blue-50 rounded-lg hover:bg-blue-100 transition-colors">
                    <div className="bg-blue-200 p-2 rounded-full mr-3">
                      <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-blue-700" viewBox="0 0 20 20" fill="currentColor">
                        <path d="M9 4.804A7.968 7.968 0 005.5 4c-1.255 0-2.443.29-3.5.804v10A7.969 7.969 0 015.5 14c1.669 0 3.218.51 4.5 1.385A7.962 7.962 0 0114.5 14c1.255 0 2.443.29 3.5.804v-10A7.968 7.968 0 0014.5 4c-1.255 0-2.443.29-3.5.804V12a1 1 0 11-2 0V4.804z" />
                      </svg>
                    </div>
                    <div>
                      <p className="font-medium text-gray-800">Gérer mes arbres généalogiques</p>
                      <p className="text-sm text-gray-600">Créez et organisez vos différentes lignées familiales</p>
                    </div>
                  </Link>
                </li>
                
                {activeFamily && (
                  <>
                    <li className="transform transition-transform hover:translate-x-2">
                      <Link href={`/person/new?familyId=${activeFamily.id}`} className="flex items-center p-3 bg-green-50 rounded-lg hover:bg-green-100 transition-colors">
                        <div className="bg-green-200 p-2 rounded-full mr-3">
                          <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-green-700" viewBox="0 0 20 20" fill="currentColor">
                            <path fillRule="evenodd" d="M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z" clipRule="evenodd" />
                          </svg>
                        </div>
                        <div>
                          <p className="font-medium text-gray-800">Ajouter une nouvelle personne</p>
                          <p className="text-sm text-gray-600">Enrichissez votre arbre avec de nouveaux membres</p>
                        </div>
                      </Link>
                    </li>
                    
                    <li className="transform transition-transform hover:translate-x-2">
                      <Link href={`/relationship/analyzer?familyId=${activeFamily.id}`} className="flex items-center p-3 bg-purple-50 rounded-lg hover:bg-purple-100 transition-colors">
                        <div className="bg-purple-200 p-2 rounded-full mr-3">
                          <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-purple-700" viewBox="0 0 20 20" fill="currentColor">
                            <path d="M9 6a3 3 0 11-6 0 3 3 0 016 0zM17 6a3 3 0 11-6 0 3 3 0 016 0zM12.93 17c.046-.327.07-.66.07-1a6.97 6.97 0 00-1.5-4.33A5 5 0 0119 16v1h-6.07zM6 11a5 5 0 015 5v1H1v-1a5 5 0 015-5z" />
                          </svg>
                        </div>
                        <div>
                          <p className="font-medium text-gray-800">Analyser les liens de parenté</p>
                          <p className="text-sm text-gray-600">Découvrez les connexions entre les membres de votre famille</p>
                        </div>
                      </Link>
                    </li>
                  </>
                )}
              </ul>
            </div>

            {/* Mes arbres généalogiques */}
            <div className="bg-white rounded-xl shadow-xl p-8 transform transition-all hover:shadow-2xl border-t-4 border-green-500">
              <div className="flex items-center justify-between mb-6">
                <div className="flex items-center">
                  <div className="bg-green-100 p-3 rounded-lg mr-4">
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-8 w-8 text-green-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 6l3 1m0 0l-3 9a5.002 5.002 0 006.001 0M6 7l3 9M6 7l6-2m6 2l3-1m-3 1l-3 9a5.002 5.002 0 006.001 0M18 7l3 9m-3-9l-6-2m0-2v2m0 16V5m0 16H9m3 0h3" />
                    </svg>
                  </div>
                  <h2 className="text-2xl font-bold text-gray-800">Mes arbres généalogiques</h2>
                </div>
                
                <Link href="/family/new" className="p-2 bg-green-500 text-white rounded-full hover:bg-green-600 transition-colors">
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 6v6m0 0v6m0-6h6m-6 0H6" />
                  </svg>
                </Link>
              </div>
              
              {families.length > 0 ? (
                <div className="overflow-hidden">
                  <ul className="divide-y divide-gray-100 -mx-4">
                    {families.map(family => (
                      <li key={family.id} className="transform transition-all hover:bg-gray-50">
                        <Link href={`/family/${family.id}`} className="flex items-center p-4 hover:bg-gray-50">
                          <div className={`w-12 h-12 rounded-lg flex items-center justify-center mr-4 text-lg font-bold ${
                            activeFamily && activeFamily.id === family.id 
                              ? 'bg-green-200 text-green-800 ring-2 ring-green-500' 
                              : 'bg-blue-100 text-blue-800'
                          }`}>
                            {family.name.charAt(0)}
                          </div>
                          <div className="flex-1">
                            <div className="flex items-center">
                              <h3 className="font-semibold text-gray-800">{family.name}</h3>
                              {activeFamily && activeFamily.id === family.id && (
                                <span className="ml-2 px-2 py-1 bg-green-100 text-green-800 text-xs rounded-full">Actif</span>
                              )}
                            </div>
                            <div className="flex items-center text-sm text-gray-500 mt-1">
                              <div className="flex items-center mr-4">
                                <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4 mr-1" viewBox="0 0 20 20" fill="currentColor">
                                  <path d="M13 6a3 3 0 11-6 0 3 3 0 016 0zM18 8a2 2 0 11-4 0 2 2 0 014 0zM14 15a4 4 0 00-8 0v3h8v-3zM6 8a2 2 0 11-4 0 2 2 0 014 0zM16 18v-3a5.972 5.972 0 00-.75-2.906A3.005 3.005 0 0119 15v3h-3zM4.75 12.094A5.973 5.973 0 004 15v3H1v-3a3 3 0 013.75-2.906z" />
                                </svg>
                                {family.persons.length} personnes
                              </div>
                              <div className="flex items-center">
                                <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4 mr-1" viewBox="0 0 20 20" fill="currentColor">
                                  <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z" clipRule="evenodd" />
                                </svg>
                                {new Date(family.updatedAt).toLocaleDateString()}
                              </div>
                            </div>
                          </div>
                          <div className="text-gray-400">
                            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                              <path fillRule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clipRule="evenodd" />
                            </svg>
                          </div>
                        </Link>
                      </li>
                    ))}
                  </ul>
                </div>
              ) : (
                <div className="text-center py-8 bg-gray-50 rounded-lg">
                  <div className="bg-white p-3 rounded-full inline-block mb-4 shadow-md">
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-8 w-8 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 6v6m0 0v6m0-6h6m-6 0H6" />
                    </svg>
                  </div>
                  <p className="text-gray-500 mb-4">Vous n'avez pas encore créé d'arbre généalogique.</p>
                  <Link href="/family/new" className="px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors shadow-md">
                    Créer mon premier arbre
                  </Link>
                </div>
              )}
              
              {families.length > 0 && (
                <div className="mt-6 text-right">
                  <Link href="/family" className="inline-flex items-center text-blue-600 hover:text-blue-800 font-medium">
                    Voir tous les arbres
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 ml-1" viewBox="0 0 20 20" fill="currentColor">
                      <path fillRule="evenodd" d="M12.293 5.293a1 1 0 011.414 0l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414-1.414L14.586 11H3a1 1 0 110-2h11.586l-2.293-2.293a1 1 0 010-1.414z" clipRule="evenodd" />
                    </svg>
                  </Link>
                </div>
              )}
            </div>
          </div>
        </div>
      </section>

      {/* Bannière statistiques */}
      {activeFamily && (
        <section className="py-12 px-4 md:px-8 bg-gradient-to-r from-blue-600 to-blue-800 text-white">
          <div className="container mx-auto">
            <div className="grid grid-cols-1 md:grid-cols-3 gap-8">
              <div className="bg-white bg-opacity-20 backdrop-filter backdrop-blur-lg rounded-xl p-6 text-center">
                <h3 className="text-lg font-medium mb-2">Membres de la famille</h3>
                <p className="text-4xl font-bold">{activeFamily.persons.length}</p>
              </div>
              
              <div className="bg-white bg-opacity-20 backdrop-filter backdrop-blur-lg rounded-xl p-6 text-center">
                <h3 className="text-lg font-medium mb-2">Arbre actif</h3>
                <p className="text-4xl font-bold">{activeFamily.name}</p>
              </div>
              
              <div className="bg-white bg-opacity-20 backdrop-filter backdrop-blur-lg rounded-xl p-6 text-center">
                <h3 className="text-lg font-medium mb-2">Dernière mise à jour</h3>
                <p className="text-4xl font-bold">{new Date(activeFamily.updatedAt).toLocaleDateString()}</p>
              </div>
            </div>
          </div>
        </section>
      )}

      {/* Footer */}
      <footer className="py-8 px-4 md:px-8 bg-gray-50 border-t border-gray-200">
        <div className="container mx-auto">
          <div className="flex flex-col md:flex-row justify-between items-center">
            <div className="mb-4 md:mb-0">
              <h3 className="text-xl font-bold text-gray-800 mb-2">Explorateur d'Arbre Généalogique</h3>
              <p className="text-gray-600">Préservez votre histoire familiale pour les générations futures</p>
            </div>
          </div>
        </div>
      </footer>
    </main>
  );
}// END OF FILE: src/app/page.tsx

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/app/person/[id]/edit/page.tsx

// src/app/person/[id]/edit/page.tsx et src/app/person/new/page.tsx
'use client';

import React, { useState, useEffect } from 'react';
import { useParams, useRouter, useSearchParams } from 'next/navigation';
import Link from 'next/link';
import { useFamily } from '@/context/FamilyContext';
import { Person } from '@/lib/models/Person';
import { Family } from '@/lib/models/Families';

export default function PersonFormPage() {
  const params = useParams();
  const router = useRouter();
  const searchParams = useSearchParams();
  const familyIdParam = searchParams.get('familyId');
  const returnTo = searchParams.get('returnTo');
  
  const { families, activeFamily, loading, addPerson, updatePerson, deletePerson } = useFamily();
  
  const [currentFamily, setCurrentFamily] = useState<Family | null>(null);
  const [isNew, setIsNew] = useState(true);
  const [formData, setFormData] = useState<Partial<Person>>({
    nom: '',
    prenom: '',
    sexe: 'M',
    birthDate: '',
    deathDate: '',
    etat: 'vivant'
  });
  const [errors, setErrors] = useState<Record<string, string>>({});
  const [isSaving, setIsSaving] = useState(false);
  const [isDeleting, setIsDeleting] = useState(false);

  // Déterminer la famille actuelle
  useEffect(() => {
    if (!loading && families.length > 0) {
      let family: Family | null = null;
      
      if (familyIdParam) {
        family = families.find(f => f.id === familyIdParam) || null;
      } else if (activeFamily) {
        family = activeFamily;
      }
      
      setCurrentFamily(family);
    }
  }, [loading, families, activeFamily, familyIdParam]);

  // Déterminer si c'est un ajout ou une modification
  useEffect(() => {
    const id = params?.id;
    setIsNew(!id);
    
    if (id && currentFamily) {
      const existingPerson = currentFamily.persons.find(p => p.id === id);
      if (existingPerson) {
        setFormData({
          ...existingPerson,
          birthDate: existingPerson.birthDate || '',
          deathDate: existingPerson.deathDate || ''
        });
      } else {
        // Personne non trouvée, rediriger
        if (currentFamily) {
          router.push(`/person?familyId=${currentFamily.id}`);
        } else {
          router.push('/person');
        }
      }
    }
  }, [params, currentFamily, router]);

  // Gestionnaire de changement de champ
  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>) => {
    const { name, value } = e.target;
    
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
    
    // Effacer l'erreur si elle existe
    if (errors[name]) {
      setErrors(prev => {
        const newErrors = { ...prev };
        delete newErrors[name];
        return newErrors;
      });
    }
  };

  // Activer/désactiver la date de décès en fonction de l'état (vivant/mort)
  const handleStateChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    const value = e.target.value as 'vivant' | 'mort';
    
    setFormData(prev => ({
      ...prev,
      etat: value,
      // Réinitialiser la date de décès si la personne est marquée comme vivante
      deathDate: value === 'vivant' ? '' : prev.deathDate
    }));
  };

  // Validation du formulaire
  const validateForm = (): boolean => {
    const newErrors: Record<string, string> = {};
    
    if (!formData.nom?.trim()) {
      newErrors.nom = "Le nom est requis";
    }
    
    if (!formData.prenom?.trim()) {
      newErrors.prenom = "Le prénom est requis";
    }
    
    if (formData.birthDate && formData.deathDate) {
      const birth = new Date(formData.birthDate);
      const death = new Date(formData.deathDate);
      
      if (birth > death) {
        newErrors.deathDate = "La date de décès doit être postérieure à la date de naissance";
      }
    }
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  // Soumission du formulaire
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!currentFamily) {
      setErrors({
        submit: "Aucun arbre généalogique sélectionné"
      });
      return;
    }
    
    if (!validateForm()) return;
    
    setIsSaving(true);
    
    try {
      if (isNew) {
        // Générer un nouvel ID
        const newId = `p${Date.now()}`;
        
        // Ajouter la nouvelle personne
        const newPerson: Person = {
          id: newId,
          nom: formData.nom || '',
          prenom: formData.prenom || '',
          sexe: formData.sexe as 'M' | 'F' | 'A',
          birthDate: formData.birthDate || null,
          deathDate: formData.deathDate || null,
          etat: formData.etat as 'vivant' | 'mort'
        };
        
        await addPerson(currentFamily.id, newPerson);
        
        // Rediriger
        if (returnTo) {
          router.push(returnTo);
        } else {
          router.push(`/person/${newId}?familyId=${currentFamily.id}`);
        }
      } else {
        // Mise à jour d'une personne existante
        const personId = params?.id as string;
        
        const updatedPerson: Person = {
          id: personId,
          nom: formData.nom || '',
          prenom: formData.prenom || '',
          sexe: formData.sexe as 'M' | 'F' | 'A',
          birthDate: formData.birthDate || null,
          deathDate: formData.deathDate || null,
          etat: formData.etat as 'vivant' | 'mort'
        };
        
        await updatePerson(currentFamily.id, updatedPerson);
        
        // Rediriger
        router.push(`/person/${personId}?familyId=${currentFamily.id}`);
      }
    } catch (error) {
      console.error('Erreur lors de la sauvegarde:', error);
      setErrors(prev => ({
        ...prev,
        submit: "Une erreur est survenue lors de la sauvegarde"
      }));
    } finally {
      setIsSaving(false);
    }
  };

  // Suppression d'une personne
  const handleDelete = async () => {
    if (!currentFamily || isNew) return;
    
    if (!window.confirm('Êtes-vous sûr de vouloir supprimer cette personne ? Cette action est irréversible et supprimera également toutes les relations associées.')) {
      return;
    }
    
    setIsDeleting(true);
    
    try {
      const personId = params?.id as string;
      
      await deletePerson(currentFamily.id, personId);
      
      // Rediriger vers la liste des personnes
      router.push(`/person?familyId=${currentFamily.id}`);
    } catch (error) {
      console.error('Erreur lors de la suppression:', error);
      setErrors(prev => ({
        ...prev,
        submit: "Une erreur est survenue lors de la suppression"
      }));
    } finally {
      setIsDeleting(false);
    }
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="text-center">
          <h2 className="text-xl font-semibold mb-2">Chargement des données...</h2>
          <div className="w-12 h-12 border-4 border-t-blue-500 border-b-blue-700 rounded-full animate-spin mx-auto"></div>
        </div>
      </div>
    );
  }

  if (!currentFamily) {
    return (
      <div className="container mx-auto px-4 py-8">
        <div className="bg-white rounded-lg shadow-md p-6 text-center">
          <h2 className="text-2xl font-semibold mb-4">Aucun arbre généalogique sélectionné</h2>
          <p className="mb-6">Veuillez sélectionner un arbre généalogique pour ajouter ou modifier une personne.</p>
          <Link href="/family" className="btn btn-primary">
            Voir mes arbres généalogiques
          </Link>
        </div>
      </div>
    );
  }

  return (
    <div className="container mx-auto px-4 py-8">
      <div className="mb-6">
        <Link 
          href={isNew ? `/person?familyId=${currentFamily.id}` : `/person/${params?.id}?familyId=${currentFamily.id}`} 
          className="text-blue-600 hover:underline inline-flex items-center"
        >
          <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor">
            <path fillRule="evenodd" d="M9.707 14.707a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 1.414L7.414 9H15a1 1 0 110 2H7.414l2.293 2.293a1 1 0 010 1.414z" clipRule="evenodd" />
          </svg>
          Retour
        </Link>
      </div>
      
      <div className="bg-white rounded-lg shadow-md p-6">
        <h1 className="text-2xl font-bold mb-6">
          {isNew ? "Ajouter une nouvelle personne" : `Modifier ${formData.prenom} ${formData.nom}`}
        </h1>
        
        <form onSubmit={handleSubmit}>
          {errors.submit && (
            <div className="mb-6 bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded">
              {errors.submit}
            </div>
          )}
          
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
            {/* Prénom */}
            <div>
              <label htmlFor="prenom" className="form-label">
                Prénom <span className="text-red-500">*</span>
              </label>
              <input
                type="text"
                id="prenom"
                name="prenom"
                value={formData.prenom || ''}
                onChange={handleChange}
                className={`form-input ${errors.prenom ? 'border-red-500 ring-1 ring-red-500' : ''}`}
                required
              />
              {errors.prenom && (
                <p className="text-red-500 text-sm mt-1">{errors.prenom}</p>
              )}
            </div>
            
            {/* Nom */}
            <div>
              <label htmlFor="nom" className="form-label">
                Nom <span className="text-red-500">*</span>
              </label>
              <input
                type="text"
                id="nom"
                name="nom"
                value={formData.nom || ''}
                onChange={handleChange}
                className={`form-input ${errors.nom ? 'border-red-500 ring-1 ring-red-500' : ''}`}
                required
              />
              {errors.nom && (
                <p className="text-red-500 text-sm mt-1">{errors.nom}</p>
              )}
            </div>
            
            {/* Sexe */}
            <div>
              <label htmlFor="sexe" className="form-label">Sexe</label>
              <select
                id="sexe"
                name="sexe"
                value={formData.sexe || 'M'}
                onChange={handleChange}
                className="form-input"
              >
                <option value="M">Homme</option>
                <option value="F">Femme</option>
                <option value="A">Autre</option>
              </select>
            </div>
            
            {/* État (vivant/mort) */}
            <div>
              <label htmlFor="etat" className="form-label">État</label>
              <select
                id="etat"
                name="etat"
                value={formData.etat || 'vivant'}
                onChange={handleStateChange}
                className="form-input"
              >
                <option value="vivant">Vivant</option>
                <option value="mort">Décédé</option>
              </select>
            </div>
            
            {/* Date de naissance */}
            <div>
              <label htmlFor="birthDate" className="form-label">Date de naissance</label>
              <input
                type="date"
                id="birthDate"
                name="birthDate"
                value={formData.birthDate || ''}
                onChange={handleChange}
                className="form-input"
              />
            </div>
            
            {/* Date de décès (visible seulement si état = mort) */}
            {formData.etat === 'mort' && (
              <div>
                <label htmlFor="deathDate" className="form-label">Date de décès</label>
                <input
                  type="date"
                  id="deathDate"
                  name="deathDate"
                  value={formData.deathDate || ''}
                  onChange={handleChange}
                  className={`form-input ${errors.deathDate ? 'border-red-500 ring-1 ring-red-500' : ''}`}
                />
                {errors.deathDate && (
                  <p className="text-red-500 text-sm mt-1">{errors.deathDate}</p>
                )}
              </div>
            )}
          </div>
          
          <div className="flex flex-col md:flex-row justify-between mt-8">
            <div>
              {!isNew && (
                <button
                  type="button"
                  onClick={handleDelete}
                  className="btn btn-danger"
                  disabled={isDeleting}
                >
                  {isDeleting ? 'Suppression...' : 'Supprimer'}
                </button>
              )}
            </div>
            
            <div className="flex gap-4 mt-4 md:mt-0">
              <Link 
                href={isNew ? `/person?familyId=${currentFamily.id}` : `/person/${params?.id}?familyId=${currentFamily.id}`}
                className="btn btn-secondary"
              >
                Annuler
              </Link>
              
              <button
                type="submit"
                className="btn btn-primary"
                disabled={isSaving}
              >
                {isSaving ? 'Enregistrement...' : 'Enregistrer'}
              </button>
            </div>
          </div>
        </form>
      </div>
    </div>
  );
}// END OF FILE: src/app/person/[id]/edit/page.tsx

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/app/person/[id]/page.tsx

// src/app/person/[id]/page.tsx
'use client';

import React, { useState, useEffect } from 'react';
import { useParams, useRouter, useSearchParams } from 'next/navigation';
import Link from 'next/link';
import { useFamily } from '@/context/FamilyContext';
import { Person } from '@/lib/models/Person';
import { Relationship } from '@/lib/models/Relationship';
import { Family } from '@/lib/models/Families';
import { calculateAge } from '@/lib/utils/dateUtils';

export default function PersonDetailPage() {
  const params = useParams();
  const router = useRouter();
  const searchParams = useSearchParams();
  const familyIdParam = searchParams.get('familyId');
  
  const { families, activeFamily, loading } = useFamily();
  
  const [currentFamily, setCurrentFamily] = useState<Family | null>(null);
  const [person, setPerson] = useState<Person | null>(null);
  const [relations, setRelations] = useState<{ 
    parents: {person: Person, relation: Relationship}[],
    children: {person: Person, relation: Relationship}[],
    spouses: {person: Person, relation: Relationship}[]
  }>({
    parents: [],
    children: [],
    spouses: []
  });

  // Déterminer la famille actuelle
  useEffect(() => {
    if (!loading && families.length > 0) {
      let family: Family | null = null;
      
      if (familyIdParam) {
        family = families.find(f => f.id === familyIdParam) || null;
      } else if (activeFamily) {
        family = activeFamily;
      }
      
      setCurrentFamily(family);
    }
  }, [loading, families, activeFamily, familyIdParam]);

  // Charger les détails de la personne
  useEffect(() => {
    if (currentFamily && params.id) {
      const personId = params.id as string;
      const foundPerson = currentFamily.persons.find(p => p.id === personId);
      
      if (foundPerson) {
        setPerson(foundPerson);
        
        // Trouver les relations
        const personParents: {person: Person, relation: Relationship}[] = [];
        const personChildren: {person: Person, relation: Relationship}[] = [];
        const personSpouses: {person: Person, relation: Relationship}[] = [];
        
        currentFamily.relationships.forEach(rel => {
          const isSource = rel.sourceId === personId;
          const isTarget = rel.targetId === personId;
          
          if (!isSource && !isTarget) return;
          
          const otherId = isSource ? rel.targetId : rel.sourceId;
          const otherPerson = currentFamily.persons.find(p => p.id === otherId);
          
          if (!otherPerson) return;
          
          if (rel.type === 'parent') {
            if (isSource) {
              // Cette personne est parent de quelqu'un
              personChildren.push({ person: otherPerson, relation: rel });
            } else {
              // Cette personne est l'enfant de quelqu'un
              personParents.push({ person: otherPerson, relation: rel });
            }
          } else if (rel.type === 'conjoint') {
            personSpouses.push({ person: otherPerson, relation: rel });
          }
        });
        
        setRelations({
          parents: personParents,
          children: personChildren,
          spouses: personSpouses
        });
      } else if (currentFamily) {
        // Personne non trouvée, rediriger
        router.push(`/person?familyId=${currentFamily.id}`);
      }
    }
  }, [currentFamily, params.id, router]);

  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="text-center">
          <h2 className="text-xl font-semibold mb-2">Chargement des données...</h2>
          <div className="w-12 h-12 border-4 border-t-blue-500 border-b-blue-700 rounded-full animate-spin mx-auto"></div>
        </div>
      </div>
    );
  }

  if (!currentFamily) {
    return (
      <div className="container mx-auto px-4 py-8">
        <div className="bg-white rounded-lg shadow-md p-6 text-center">
          <h2 className="text-2xl font-semibold mb-4">Aucun arbre généalogique sélectionné</h2>
          <p className="mb-6">Veuillez sélectionner un arbre généalogique pour voir les détails d'une personne.</p>
          <Link href="/family" className="btn btn-primary">
            Voir mes arbres généalogiques
          </Link>
        </div>
      </div>
    );
  }

  if (!person) {
    return (
      <div className="container mx-auto px-4 py-8">
        <div className="bg-white rounded-lg shadow-md p-6 text-center">
          <h2 className="text-2xl font-semibold mb-4">Personne non trouvée</h2>
          <p className="mb-6">La personne que vous recherchez n'existe pas dans cet arbre généalogique.</p>
          <Link href={`/person?familyId=${currentFamily.id}`} className="btn btn-primary">
            Retour à la liste des personnes
          </Link>
        </div>
      </div>
    );
  }

  return (
    <div className="container mx-auto px-4 py-8">
      <div className="mb-6">
        <Link href={`/person?familyId=${currentFamily.id}`} className="text-blue-600 hover:underline inline-flex items-center">
          <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor">
            <path fillRule="evenodd" d="M9.707 14.707a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 1.414L7.414 9H15a1 1 0 110 2H7.414l2.293 2.293a1 1 0 010 1.414z" clipRule="evenodd" />
          </svg>
          Retour à la liste
        </Link>
      </div>
      
      <div className="flex flex-col md:flex-row md:justify-between md:items-start mb-8">
        <div>
          <h1 className="text-3xl font-bold mb-2">
            {person.prenom} {person.nom}
          </h1>
          <p className="text-gray-600">
            {person.birthDate && new Date(person.birthDate).toLocaleDateString()} - 
            {person.deathDate ? new Date(person.deathDate).toLocaleDateString() : person.etat === "vivant" ? "présent" : "?"}
          </p>
        </div>
        
        <div className="mt-4 md:mt-0 flex flex-wrap gap-3">
          <Link 
            href={`/person/${person.id}/edit?familyId=${currentFamily.id}`} 
            className="btn btn-primary inline-flex items-center"
          >
            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
              <path d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z" />
            </svg>
            Modifier
          </Link>
          
          <Link 
            href={`/tree?familyId=${currentFamily.id}&rootId=${person.id}`} 
            className="btn btn-secondary inline-flex items-center"
          >
            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
              <path d="M7 3a1 1 0 000 2h6a1 1 0 100-2H7zM4 7a1 1 0 011-1h10a1 1 0 110 2H5a1 1 0 01-1-1zM2 11a2 2 0 012-2h12a2 2 0 012 2v4a2 2 0 01-2 2H4a2 2 0 01-2-2v-4z" />
            </svg>
            Voir dans l'arbre
          </Link>
        </div>
      </div>
      
      <div className="grid grid-cols-1 md:grid-cols-3 gap-8">
        {/* Informations personnelles */}
        <div className="bg-white rounded-lg shadow-md p-6">
          <h2 className="text-xl font-semibold mb-4 border-b pb-2">Informations personnelles</h2>
          
          <dl className="space-y-3">
            <div>
              <dt className="text-sm font-medium text-gray-500">Nom complet</dt>
              <dd className="mt-1 text-gray-900">{person.prenom} {person.nom}</dd>
            </div>
            
            <div>
              <dt className="text-sm font-medium text-gray-500">Sexe</dt>
              <dd className="mt-1 text-gray-900">
                {person.sexe === 'M' ? 'Homme' : person.sexe === 'F' ? 'Femme' : 'Autre'}
              </dd>
            </div>
            
            <div>
              <dt className="text-sm font-medium text-gray-500">Date de naissance</dt>
              <dd className="mt-1 text-gray-900">
                {person.birthDate ? new Date(person.birthDate).toLocaleDateString() : 'Inconnue'}
              </dd>
            </div>
            
            {person.deathDate && (
              <div>
                <dt className="text-sm font-medium text-gray-500">Date de décès</dt>
                <dd className="mt-1 text-gray-900">
                  {new Date(person.deathDate).toLocaleDateString()}
                </dd>
              </div>
            )}
            
            <div>
              <dt className="text-sm font-medium text-gray-500">État</dt>
              <dd className="mt-1">
                <span className={`px-2 py-1 inline-flex text-xs leading-5 font-semibold rounded-full ${
                  person.etat === 'vivant' ? 'bg-green-100 text-green-800' : 'bg-gray-100 text-gray-800'
                }`}>
                  {person.etat === 'vivant' ? 'Vivant' : 'Décédé'}
                </span>
              </dd>
            </div>
            
            <div>
              <dt className="text-sm font-medium text-gray-500">Âge</dt>
              <dd className="mt-1 text-gray-900">
                {calculateAge(person)}
              </dd>
            </div>
          </dl>
        </div>
        
        {/* Relations familiales */}
        <div className="bg-white rounded-lg shadow-md p-6 md:col-span-2">
          <h2 className="text-xl font-semibold mb-4 border-b pb-2">Relations familiales</h2>
          
          <div className="space-y-6">
            {/* Parents */}
            <div>
              <h3 className="text-lg font-medium mb-3">Parents</h3>
              {relations.parents.length > 0 ? (
                <ul className="space-y-2">
                  {relations.parents.map(({ person: parent, relation }) => (
                    <li key={parent.id} className="flex items-center">
                      <span className="bg-blue-100 text-blue-800 text-xs font-medium px-2 py-1 rounded mr-2">
                        {relation.sousType === 'pere' ? 'Père' : relation.sousType === 'mere' ? 'Mère' : 'Parent'}
                      </span>
                      <Link 
                        href={`/person/${parent.id}?familyId=${currentFamily.id}`}
                        className="text-blue-600 hover:underline"
                      >
                        {parent.prenom} {parent.nom}
                      </Link>
                    </li>
                  ))}
                </ul>
              ) : (
                <p className="text-gray-500 italic">Aucun parent enregistré</p>
              )}
            </div>
            
            {/* Conjoints */}
            <div>
              <h3 className="text-lg font-medium mb-3">Conjoints</h3>
              {relations.spouses.length > 0 ? (
                <ul className="space-y-2">
                  {relations.spouses.map(({ person: spouse, relation }) => (
                    <li key={spouse.id} className="flex items-center">
                      <span className="bg-red-100 text-red-800 text-xs font-medium px-2 py-1 rounded mr-2">
                        {relation.sousType === 'marie' ? 'Marié(e)' : 'Partenaire'}
                      </span>
                      <Link 
                        href={`/person/${spouse.id}?familyId=${currentFamily.id}`}
                        className="text-blue-600 hover:underline"
                      >
                        {spouse.prenom} {spouse.nom}
                      </Link>
                      {relation.dateDebut && (
                        <span className="text-sm text-gray-500 ml-2">
                          depuis {new Date(relation.dateDebut).toLocaleDateString()}
                        </span>
                      )}
                    </li>
                  ))}
                </ul>
              ) : (
                <p className="text-gray-500 italic">Aucun conjoint enregistré</p>
              )}
            </div>
            
            {/* Enfants */}
            <div>
              <h3 className="text-lg font-medium mb-3">Enfants</h3>
              {relations.children.length > 0 ? (
                <ul className="space-y-2">
                  {relations.children.map(({ person: child, relation }) => (
                    <li key={child.id} className="flex items-center">
                      <span className="bg-green-100 text-green-800 text-xs font-medium px-2 py-1 rounded mr-2">
                        {relation.sousType === 'adopte' ? 'Adopté(e)' : 'Biologique'}
                      </span>
                      <Link 
                        href={`/person/${child.id}?familyId=${currentFamily.id}`}
                        className="text-blue-600 hover:underline"
                      >
                        {child.prenom} {child.nom}
                      </Link>
                      <span className="text-sm text-gray-500 ml-2">
                        ({child.birthDate ? new Date(child.birthDate).getFullYear() : '?'})
                      </span>
                    </li>
                  ))}
                </ul>
              ) : (
                <p className="text-gray-500 italic">Aucun enfant enregistré</p>
              )}
            </div>
            
            {/* Actions */}
            <div className="mt-6 pt-6 border-t border-gray-200">
              <h3 className="text-lg font-medium mb-3">Ajouter une relation</h3>
              <div className="flex flex-wrap gap-3">
                <Link 
                  href={`/relationship/new?type=parent&targetId=${person.id}&familyId=${currentFamily.id}`}
                  className="btn btn-secondary text-sm"
                >
                  Ajouter un parent
                </Link>
                <Link 
                  href={`/relationship/new?type=conjoint&sourceId=${person.id}&familyId=${currentFamily.id}`}
                  className="btn btn-secondary text-sm"
                >
                  Ajouter un conjoint
                </Link>
                <Link 
                  href={`/relationship/new?type=parent&sourceId=${person.id}&familyId=${currentFamily.id}`}
                  className="btn btn-secondary text-sm"
                >
                  Ajouter un enfant
                </Link>
              </div>
            </div>
          </div>
        </div>
      </div>
      
      {/* Analyse de relations */}
      <div className="mt-8 bg-white rounded-lg shadow-md p-6">
        <h2 className="text-xl font-semibold mb-4 border-b pb-2">Analyse de relations</h2>
        
        <p className="mb-4">
          Sélectionnez une autre personne pour analyser la relation avec {person.prenom} {person.nom}
        </p>
        
        <div className="flex flex-col md:flex-row gap-4">
          <select
            className="form-input rounded-md px-4 py-2 border border-gray-300 flex-grow"
            onChange={(e) => {
              if (e.target.value) {
                router.push(`/relationship/analyzer?person1=${person.id}&person2=${e.target.value}&familyId=${currentFamily.id}`);
              }
            }}
          >
            <option value="">Sélectionner une personne</option>
            {currentFamily.persons
              .filter(p => p.id !== person.id)
              .map(p => (
                <option key={p.id} value={p.id}>{p.prenom} {p.nom}</option>
              ))}
          </select>
          
          <button
            className="btn btn-primary"
            onClick={() => router.push(`/relationship/analyzer?person1=${person.id}&familyId=${currentFamily.id}`)}
          >
            Analyser les relations
          </button>
        </div>
      </div>
    </div>
  );
}// END OF FILE: src/app/person/[id]/page.tsx

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/app/person/new/page.tsx

// src/app/person/[id]/edit/page.tsx et src/app/person/new/page.tsx
'use client';

import React, { useState, useEffect } from 'react';
import { useParams, useRouter, useSearchParams } from 'next/navigation';
import Link from 'next/link';
import { useFamily } from '@/context/FamilyContext';
import { Person } from '@/lib/models/Person';
import { Family } from '@/lib/models/Families';

export default function PersonFormPage() {
  const params = useParams();
  const router = useRouter();
  const searchParams = useSearchParams();
  const familyIdParam = searchParams.get('familyId');
  const returnTo = searchParams.get('returnTo');
  
  const { families, activeFamily, loading, addPerson, updatePerson, deletePerson } = useFamily();
  
  const [currentFamily, setCurrentFamily] = useState<Family | null>(null);
  const [isNew, setIsNew] = useState(true);
  const [formData, setFormData] = useState<Partial<Person>>({
    nom: '',
    prenom: '',
    sexe: 'M',
    birthDate: '',
    deathDate: '',
    etat: 'vivant'
  });
  const [errors, setErrors] = useState<Record<string, string>>({});
  const [isSaving, setIsSaving] = useState(false);
  const [isDeleting, setIsDeleting] = useState(false);

  // Déterminer la famille actuelle
  useEffect(() => {
    if (!loading && families.length > 0) {
      let family: Family | null = null;
      
      if (familyIdParam) {
        family = families.find(f => f.id === familyIdParam) || null;
      } else if (activeFamily) {
        family = activeFamily;
      }
      
      setCurrentFamily(family);
    }
  }, [loading, families, activeFamily, familyIdParam]);

  // Déterminer si c'est un ajout ou une modification
  useEffect(() => {
    const id = params?.id;
    setIsNew(!id);
    
    if (id && currentFamily) {
      const existingPerson = currentFamily.persons.find(p => p.id === id);
      if (existingPerson) {
        setFormData({
          ...existingPerson,
          birthDate: existingPerson.birthDate || '',
          deathDate: existingPerson.deathDate || ''
        });
      } else {
        // Personne non trouvée, rediriger
        if (currentFamily) {
          router.push(`/person?familyId=${currentFamily.id}`);
        } else {
          router.push('/person');
        }
      }
    }
  }, [params, currentFamily, router]);

  // Gestionnaire de changement de champ
  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>) => {
    const { name, value } = e.target;
    
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
    
    // Effacer l'erreur si elle existe
    if (errors[name]) {
      setErrors(prev => {
        const newErrors = { ...prev };
        delete newErrors[name];
        return newErrors;
      });
    }
  };

  // Activer/désactiver la date de décès en fonction de l'état (vivant/mort)
  const handleStateChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    const value = e.target.value as 'vivant' | 'mort';
    
    setFormData(prev => ({
      ...prev,
      etat: value,
      // Réinitialiser la date de décès si la personne est marquée comme vivante
      deathDate: value === 'vivant' ? '' : prev.deathDate
    }));
  };

  // Validation du formulaire
  const validateForm = (): boolean => {
    const newErrors: Record<string, string> = {};
    
    if (!formData.nom?.trim()) {
      newErrors.nom = "Le nom est requis";
    }
    
    if (!formData.prenom?.trim()) {
      newErrors.prenom = "Le prénom est requis";
    }
    
    if (formData.birthDate && formData.deathDate) {
      const birth = new Date(formData.birthDate);
      const death = new Date(formData.deathDate);
      
      if (birth > death) {
        newErrors.deathDate = "La date de décès doit être postérieure à la date de naissance";
      }
    }
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  // Soumission du formulaire
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!currentFamily) {
      setErrors({
        submit: "Aucun arbre généalogique sélectionné"
      });
      return;
    }
    
    if (!validateForm()) return;
    
    setIsSaving(true);
    
    try {
      if (isNew) {
        // Générer un nouvel ID
        const newId = `p${Date.now()}`;
        
        // Ajouter la nouvelle personne
        const newPerson: Person = {
          id: newId,
          nom: formData.nom || '',
          prenom: formData.prenom || '',
          sexe: formData.sexe as 'M' | 'F' | 'A',
          birthDate: formData.birthDate || null,
          deathDate: formData.deathDate || null,
          etat: formData.etat as 'vivant' | 'mort'
        };
        
        await addPerson(currentFamily.id, newPerson);
        
        // Rediriger
        if (returnTo) {
          router.push(returnTo);
        } else {
          router.push(`/person/${newId}?familyId=${currentFamily.id}`);
        }
      } else {
        // Mise à jour d'une personne existante
        const personId = params?.id as string;
        
        const updatedPerson: Person = {
          id: personId,
          nom: formData.nom || '',
          prenom: formData.prenom || '',
          sexe: formData.sexe as 'M' | 'F' | 'A',
          birthDate: formData.birthDate || null,
          deathDate: formData.deathDate || null,
          etat: formData.etat as 'vivant' | 'mort'
        };
        
        await updatePerson(currentFamily.id, updatedPerson);
        
        // Rediriger
        router.push(`/person/${personId}?familyId=${currentFamily.id}`);
      }
    } catch (error) {
      console.error('Erreur lors de la sauvegarde:', error);
      setErrors(prev => ({
        ...prev,
        submit: "Une erreur est survenue lors de la sauvegarde"
      }));
    } finally {
      setIsSaving(false);
    }
  };

  // Suppression d'une personne
  const handleDelete = async () => {
    if (!currentFamily || isNew) return;
    
    if (!window.confirm('Êtes-vous sûr de vouloir supprimer cette personne ? Cette action est irréversible et supprimera également toutes les relations associées.')) {
      return;
    }
    
    setIsDeleting(true);
    
    try {
      const personId = params?.id as string;
      
      await deletePerson(currentFamily.id, personId);
      
      // Rediriger vers la liste des personnes
      router.push(`/person?familyId=${currentFamily.id}`);
    } catch (error) {
      console.error('Erreur lors de la suppression:', error);
      setErrors(prev => ({
        ...prev,
        submit: "Une erreur est survenue lors de la suppression"
      }));
    } finally {
      setIsDeleting(false);
    }
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="text-center">
          <h2 className="text-xl font-semibold mb-2">Chargement des données...</h2>
          <div className="w-12 h-12 border-4 border-t-blue-500 border-b-blue-700 rounded-full animate-spin mx-auto"></div>
        </div>
      </div>
    );
  }

  if (!currentFamily) {
    return (
      <div className="container mx-auto px-4 py-8">
        <div className="bg-white rounded-lg shadow-md p-6 text-center">
          <h2 className="text-2xl font-semibold mb-4">Aucun arbre généalogique sélectionné</h2>
          <p className="mb-6">Veuillez sélectionner un arbre généalogique pour ajouter ou modifier une personne.</p>
          <Link href="/family" className="btn btn-primary">
            Voir mes arbres généalogiques
          </Link>
        </div>
      </div>
    );
  }

  return (
    <div className="container mx-auto px-4 py-8">
      <div className="mb-6">
        <Link 
          href={isNew ? `/person?familyId=${currentFamily.id}` : `/person/${params?.id}?familyId=${currentFamily.id}`} 
          className="text-blue-600 hover:underline inline-flex items-center"
        >
          <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor">
            <path fillRule="evenodd" d="M9.707 14.707a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 1.414L7.414 9H15a1 1 0 110 2H7.414l2.293 2.293a1 1 0 010 1.414z" clipRule="evenodd" />
          </svg>
          Retour
        </Link>
      </div>
      
      <div className="bg-white rounded-lg shadow-md p-6">
        <h1 className="text-2xl font-bold mb-6">
          {isNew ? "Ajouter une nouvelle personne" : `Modifier ${formData.prenom} ${formData.nom}`}
        </h1>
        
        <form onSubmit={handleSubmit}>
          {errors.submit && (
            <div className="mb-6 bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded">
              {errors.submit}
            </div>
          )}
          
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
            {/* Prénom */}
            <div>
              <label htmlFor="prenom" className="form-label">
                Prénom <span className="text-red-500">*</span>
              </label>
              <input
                type="text"
                id="prenom"
                name="prenom"
                value={formData.prenom || ''}
                onChange={handleChange}
                className={`form-input ${errors.prenom ? 'border-red-500 ring-1 ring-red-500' : ''}`}
                required
              />
              {errors.prenom && (
                <p className="text-red-500 text-sm mt-1">{errors.prenom}</p>
              )}
            </div>
            
            {/* Nom */}
            <div>
              <label htmlFor="nom" className="form-label">
                Nom <span className="text-red-500">*</span>
              </label>
              <input
                type="text"
                id="nom"
                name="nom"
                value={formData.nom || ''}
                onChange={handleChange}
                className={`form-input ${errors.nom ? 'border-red-500 ring-1 ring-red-500' : ''}`}
                required
              />
              {errors.nom && (
                <p className="text-red-500 text-sm mt-1">{errors.nom}</p>
              )}
            </div>
            
            {/* Sexe */}
            <div>
              <label htmlFor="sexe" className="form-label">Sexe</label>
              <select
                id="sexe"
                name="sexe"
                value={formData.sexe || 'M'}
                onChange={handleChange}
                className="form-input"
              >
                <option value="M">Homme</option>
                <option value="F">Femme</option>
                <option value="A">Autre</option>
              </select>
            </div>
            
            {/* État (vivant/mort) */}
            <div>
              <label htmlFor="etat" className="form-label">État</label>
              <select
                id="etat"
                name="etat"
                value={formData.etat || 'vivant'}
                onChange={handleStateChange}
                className="form-input"
              >
                <option value="vivant">Vivant</option>
                <option value="mort">Décédé</option>
              </select>
            </div>
            
            {/* Date de naissance */}
            <div>
              <label htmlFor="birthDate" className="form-label">Date de naissance</label>
              <input
                type="date"
                id="birthDate"
                name="birthDate"
                value={formData.birthDate || ''}
                onChange={handleChange}
                className="form-input"
              />
            </div>
            
            {/* Date de décès (visible seulement si état = mort) */}
            {formData.etat === 'mort' && (
              <div>
                <label htmlFor="deathDate" className="form-label">Date de décès</label>
                <input
                  type="date"
                  id="deathDate"
                  name="deathDate"
                  value={formData.deathDate || ''}
                  onChange={handleChange}
                  className={`form-input ${errors.deathDate ? 'border-red-500 ring-1 ring-red-500' : ''}`}
                />
                {errors.deathDate && (
                  <p className="text-red-500 text-sm mt-1">{errors.deathDate}</p>
                )}
              </div>
            )}
          </div>
          
          <div className="flex flex-col md:flex-row justify-between mt-8">
            <div>
              {!isNew && (
                <button
                  type="button"
                  onClick={handleDelete}
                  className="btn btn-danger"
                  disabled={isDeleting}
                >
                  {isDeleting ? 'Suppression...' : 'Supprimer'}
                </button>
              )}
            </div>
            
            <div className="flex gap-4 mt-4 md:mt-0">
              <Link 
                href={isNew ? `/person?familyId=${currentFamily.id}` : `/person/${params?.id}?familyId=${currentFamily.id}`}
                className="btn btn-secondary"
              >
                Annuler
              </Link>
              
              <button
                type="submit"
                className="btn btn-primary"
                disabled={isSaving}
              >
                {isSaving ? 'Enregistrement...' : 'Enregistrer'}
              </button>
            </div>
          </div>
        </form>
      </div>
    </div>
  );
}// END OF FILE: src/app/person/new/page.tsx

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/app/person/page.tsx

// src/app/person/page.tsx
'use client';

import React, { useState, useEffect } from 'react';
import Link from 'next/link';
import { useSearchParams } from 'next/navigation';
import { useFamily } from '@/context/FamilyContext';
import { Person } from '@/lib/models/Person';
import { Family } from '@/lib/models/Families';

export default function PersonsPage() {
  const searchParams = useSearchParams();
  const familyIdParam = searchParams.get('familyId');
  
  const { families, activeFamily, loading } = useFamily();
  const [currentFamily, setCurrentFamily] = useState<Family | null>(null);
  const [searchTerm, setSearchTerm] = useState('');
  const [filteredPersons, setFilteredPersons] = useState<Person[]>([]);
  const [sortConfig, setSortConfig] = useState<{key: keyof Person, direction: 'asc' | 'desc'}>({
    key: 'nom',
    direction: 'asc'
  });

  // Déterminer la famille actuelle
  useEffect(() => {
    if (!loading) {
      let family: Family | null = null;
      
      if (familyIdParam) {
        family = families.find(f => f.id === familyIdParam) || null;
      } else if (activeFamily) {
        family = activeFamily;
      }
      
      setCurrentFamily(family);
    }
  }, [loading, families, activeFamily, familyIdParam]);

  // Filtrer et trier les personnes quand les paramètres changent
  useEffect(() => {
    if (currentFamily) {
      let result = [...currentFamily.persons];
      
      // Filtrage
      if (searchTerm) {
        const lowerSearchTerm = searchTerm.toLowerCase();
        result = result.filter(person => 
          person.nom.toLowerCase().includes(lowerSearchTerm) ||
          person.prenom.toLowerCase().includes(lowerSearchTerm)
        );
      }
      
      // Tri
      result.sort((a, b) => {
        const aValue = a[sortConfig.key];
        const bValue = b[sortConfig.key];
        
        if (aValue === null && bValue === null) return 0;
        if (aValue === null) return 1;
        if (bValue === null) return -1;
        
        // Comparaison de chaînes
        if (typeof aValue === 'string' && typeof bValue === 'string') {
          return sortConfig.direction === 'asc' 
            ? aValue.localeCompare(bValue)
            : bValue.localeCompare(aValue);
        }
        
        // Comparaison par défaut
        return sortConfig.direction === 'asc'
          ? (aValue > bValue ? 1 : -1)
          : (bValue > aValue ? 1 : -1);
      });
      
      setFilteredPersons(result);
    } else {
      setFilteredPersons([]);
    }
  }, [currentFamily, searchTerm, sortConfig]);

  // Fonction pour changer le tri
  const requestSort = (key: keyof Person) => {
    setSortConfig(prevConfig => ({
      key,
      direction: prevConfig.key === key && prevConfig.direction === 'asc' ? 'desc' : 'asc',
    }));
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="text-center">
          <h2 className="text-xl font-semibold mb-2">Chargement des données...</h2>
          <div className="w-12 h-12 border-4 border-t-blue-500 border-b-blue-700 rounded-full animate-spin mx-auto"></div>
        </div>
      </div>
    );
  }

  if (!currentFamily) {
    return (
      <div className="container mx-auto px-4 py-8">
        <div className="bg-white rounded-lg shadow-md p-6 text-center">
          <h2 className="text-xl font-semibold mb-2">Aucun arbre généalogique sélectionné</h2>
          <p className="text-gray-600 mb-6">Veuillez sélectionner un arbre généalogique pour voir ses membres.</p>
          <Link href="/family" className="btn btn-primary">
            Voir mes arbres généalogiques
          </Link>
        </div>
      </div>
    );
  }

  return (
    <div className="container mx-auto px-4 py-8">
      <div className="mb-6">
        <Link href={`/family/${currentFamily.id}`} className="text-blue-600 hover:underline inline-flex items-center">
          <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor">
            <path fillRule="evenodd" d="M9.707 14.707a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 1.414L7.414 9H15a1 1 0 110 2H7.414l2.293 2.293a1 1 0 010 1.414z" clipRule="evenodd" />
          </svg>
          Retour à {currentFamily.name}
        </Link>
      </div>
      
      <div className="mb-8 flex flex-col md:flex-row md:items-center md:justify-between">
        <h1 className="text-3xl font-bold mb-4 md:mb-0">Personnes de {currentFamily.name}</h1>
        
        <div className="flex flex-col sm:flex-row gap-4">
          <div className="relative">
            <input
              type="text"
              placeholder="Rechercher..."
              className="w-full md:w-64 px-4 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
            />
            {searchTerm && (
              <button 
                className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-500 hover:text-gray-700"
                onClick={() => setSearchTerm('')}
              >
                ✕
              </button>
            )}
          </div>
          
          <Link 
            href={`/person/new?familyId=${currentFamily.id}`} 
            className="btn btn-primary inline-flex items-center justify-center"
          >
            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
              <path fillRule="evenodd" d="M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z" clipRule="evenodd" />
            </svg>
            Ajouter une personne
          </Link>
        </div>
      </div>
      
      <div className="bg-white rounded-lg shadow overflow-hidden">
        <div className="overflow-x-auto">
          <table className="min-w-full divide-y divide-gray-200">
            <thead className="bg-gray-50">
              <tr>
                <th 
                  scope="col" 
                  className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer"
                  onClick={() => requestSort('nom')}
                >
                  <div className="flex items-center">
                    Nom
                    {sortConfig.key === 'nom' && (
                      <span className="ml-1">
                        {sortConfig.direction === 'asc' ? '↑' : '↓'}
                      </span>
                    )}
                  </div>
                </th>
                <th 
                  scope="col" 
                  className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer"
                  onClick={() => requestSort('prenom')}
                >
                  <div className="flex items-center">
                    Prénom
                    {sortConfig.key === 'prenom' && (
                      <span className="ml-1">
                        {sortConfig.direction === 'asc' ? '↑' : '↓'}
                      </span>
                    )}
                  </div>
                </th>
                <th 
                  scope="col" 
                  className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer"
                  onClick={() => requestSort('sexe')}
                >
                  <div className="flex items-center">
                    Sexe
                    {sortConfig.key === 'sexe' && (
                      <span className="ml-1">
                        {sortConfig.direction === 'asc' ? '↑' : '↓'}
                      </span>
                    )}
                  </div>
                </th>
                <th 
                  scope="col" 
                  className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer"
                  onClick={() => requestSort('birthDate')}
                >
                  <div className="flex items-center">
                    Naissance
                    {sortConfig.key === 'birthDate' && (
                      <span className="ml-1">
                        {sortConfig.direction === 'asc' ? '↑' : '↓'}
                      </span>
                    )}
                  </div>
                </th>
                <th 
                  scope="col" 
                  className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer"
                  onClick={() => requestSort('etat')}
                >
                  <div className="flex items-center">
                    État
                    {sortConfig.key === 'etat' && (
                      <span className="ml-1">
                        {sortConfig.direction === 'asc' ? '↑' : '↓'}
                      </span>
                    )}
                  </div>
                </th>
                <th scope="col" className="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Actions
                </th>
              </tr>
            </thead>
            <tbody className="bg-white divide-y divide-gray-200">
              {filteredPersons.length > 0 ? (
                filteredPersons.map((person) => (
                  <tr key={person.id} className="hover:bg-gray-50">
                    <td className="px-6 py-4 whitespace-nowrap">
                      <div className="text-sm font-medium text-gray-900">{person.nom}</div>
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap">
                      <div className="text-sm text-gray-900">{person.prenom}</div>
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap">
                      <div className="text-sm text-gray-900">
                        {person.sexe === 'M' ? 'Homme' : person.sexe === 'F' ? 'Femme' : 'Autre'}
                      </div>
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap">
                      <div className="text-sm text-gray-900">
                        {person.birthDate ? new Date(person.birthDate).toLocaleDateString() : '-'}
                      </div>
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap">
                      <span className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${
                        person.etat === 'vivant' ? 'bg-green-100 text-green-800' : 'bg-gray-100 text-gray-800'
                      }`}>
                        {person.etat === 'vivant' ? 'Vivant' : 'Décédé'}
                      </span>
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                      <div className="flex justify-end space-x-2">
                        <Link href={`/person/${person.id}?familyId=${currentFamily.id}`} className="text-blue-600 hover:text-blue-900">
                          Voir
                        </Link>
                        <Link href={`/person/${person.id}/edit?familyId=${currentFamily.id}`} className="text-indigo-600 hover:text-indigo-900">
                          Modifier
                        </Link>
                      </div>
                    </td>
                  </tr>
                ))
              ) : (
                <tr>
                  <td colSpan={6} className="px-6 py-4 text-center text-sm text-gray-500">
                    {searchTerm 
                      ? `Aucune personne correspondant à "${searchTerm}" trouvée.` 
                      : "Aucune personne dans cet arbre généalogique."}
                  </td>
                </tr>
              )}
            </tbody>
          </table>
        </div>
      </div>

      <div className="mt-6 text-gray-600">
        {filteredPersons.length} personne(s) affichée(s) sur {currentFamily.persons.length} au total
      </div>
    </div>
  );
}// END OF FILE: src/app/person/page.tsx

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/app/relationship/new/page.tsx

// src/app/relationship/new/page.tsx
'use client';

import React, { useState, useEffect } from 'react';
import { useRouter, useSearchParams } from 'next/navigation';
import Link from 'next/link';
import { useFamily } from '@/context/FamilyContext';
import { Person } from '@/lib/models/Person';
import { Relationship, RelationType, RelationSubType } from '@/lib/models/Relationship';
import { Family } from '@/lib/models/Families';

export default function NewRelationshipPage() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const { families, activeFamily, loading, addRelationship } = useFamily();
  
  // Récupérer les paramètres de recherche
  const type = searchParams.get('type') as RelationType || 'parent';
  const sourceId = searchParams.get('sourceId');
  const targetId = searchParams.get('targetId');
  const familyIdParam = searchParams.get('familyId');
  
  const [currentFamily, setCurrentFamily] = useState<Family | null>(null);
  
  // États du formulaire
  const [formData, setFormData] = useState<{
    type: RelationType;
    sourceId: string;
    targetId: string;
    sousType: RelationSubType;
    dateDebut: string;
    dateFin: string;
    existingPerson: boolean;
  }>({
    type: type || 'parent',
    sourceId: sourceId || '',
    targetId: targetId || '',
    sousType: type === 'parent' ? 'pere' : type === 'conjoint' ? 'marie' : 'biologique',
    dateDebut: '',
    dateFin: '',
    existingPerson: true,
  });
  
  const [errors, setErrors] = useState<Record<string, string>>({});
  const [sourcePerson, setSourcePerson] = useState<Person | null>(null);
  const [targetPerson, setTargetPerson] = useState<Person | null>(null);
  const [availablePersons, setAvailablePersons] = useState<Person[]>([]);
  const [isSaving, setIsSaving] = useState(false);
  
  // Déterminer la famille actuelle
  useEffect(() => {
    if (!loading && families.length > 0) {
      let family: Family | null = null;
      
      if (familyIdParam) {
        family = families.find(f => f.id === familyIdParam) || null;
      } else if (activeFamily) {
        family = activeFamily;
      }
      
      setCurrentFamily(family);
      
      if (family) {
        setAvailablePersons(family.persons);
        
        // Trouver les personnes source et cible si leurs IDs sont fournis
        if (sourceId) {
          const person = family.persons.find(p => p.id === sourceId);
          if (person) setSourcePerson(person);
        }
        
        if (targetId) {
          const person = family.persons.find(p => p.id === targetId);
          if (person) setTargetPerson(person);
        }
      }
    }
  }, [loading, families, activeFamily, familyIdParam, sourceId, targetId]);
  
  // Initialiser le formulaire en fonction du type de relation et des IDs fournis
  useEffect(() => {
    if (currentFamily) {
      // Si c'est une relation parent et qu'il n'y a pas de sourceId défini
      // mais qu'il y a un targetId (enfant), on pré-remplit targetId
      if (type === 'parent' && !sourceId && targetId) {
        setFormData(prev => ({
          ...prev,
          type: 'parent',
          targetId: targetId
        }));
      }
      
      // Si c'est une relation enfant et qu'il y a un sourceId (parent)
      // mais pas de targetId défini, on pré-remplit sourceId
      if ((type === 'enfant' || type === 'child') && sourceId && !targetId) {
        setFormData(prev => ({
          ...prev,
          type: 'parent', // On utilise le type 'parent' car c'est la même relation vue différemment
          sourceId: sourceId
        }));
      }
    }
  }, [currentFamily, type, sourceId, targetId]);
  
  // Gestionnaire de changement de champ
  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>) => {
    const { name, value } = e.target;
    
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
    
    // Si on change le type de relation, mettre à jour le sous-type
    if (name === 'type') {
        setFormData(prev => ({
          ...prev,
          sousType: value === 'parent' ? 'pere' : value === 'conjoint' ? 'marie' : 'biologique'
        }));
      }
      
      // Si on change la personne source ou cible
      if (name === 'sourceId' && value && currentFamily) {
        const person = currentFamily.persons.find(p => p.id === value);
        if (person) setSourcePerson(person);
      }
      
      if (name === 'targetId' && value && currentFamily) {
        const person = currentFamily.persons.find(p => p.id === value);
        if (person) setTargetPerson(person);
      }
      
      // Effacer l'erreur si elle existe
      if (errors[name]) {
        setErrors(prev => {
          const newErrors = { ...prev };
          delete newErrors[name];
          return newErrors;
        });
      }
    };
    
    // Changement du mode (personne existante ou nouvelle)
    const handleModeChange = (e: React.ChangeEvent<HTMLInputElement>) => {
      setFormData(prev => ({
        ...prev,
        existingPerson: e.target.value === 'existing'
      }));
    };
    
    // Validation du formulaire
    const validateForm = (): boolean => {
      const newErrors: Record<string, string> = {};
      
      if (!formData.type) {
        newErrors.type = "Le type de relation est requis";
      }
      
      if (!formData.sourceId) {
        newErrors.sourceId = formData.type === 'parent' ? "Le parent est requis" : "La première personne est requise";
      }
      
      if (!formData.targetId) {
        newErrors.targetId = formData.type === 'parent' ? "L'enfant est requis" : "La seconde personne est requise";
      }
      
      if (formData.sourceId === formData.targetId) {
        newErrors.targetId = "Une personne ne peut pas être en relation avec elle-même";
      }
      
      // Vérifier si la relation existe déjà
      if (currentFamily && formData.sourceId && formData.targetId) {
        const relationExists = currentFamily.relationships.some(rel => 
          rel.type === formData.type && 
          rel.sourceId === formData.sourceId && 
          rel.targetId === formData.targetId
        );
        
        if (relationExists) {
          newErrors.submit = "Cette relation existe déjà";
        }
      }
      
      setErrors(newErrors);
      return Object.keys(newErrors).length === 0;
    };
    
    // Soumission du formulaire
    const handleSubmit = async (e: React.FormEvent) => {
      e.preventDefault();
      
      if (!currentFamily) {
        setErrors({
          submit: "Aucun arbre généalogique sélectionné"
        });
        return;
      }
      
      if (!validateForm()) return;
      
      setIsSaving(true);
      
      try {
        // Générer un ID unique pour la relation
        const newRelationId = `rel-${Date.now()}`;
        
        // Créer la nouvelle relation
        const newRelation: Relationship = {
          id: newRelationId,
          type: formData.type,
          sourceId: formData.sourceId,
          targetId: formData.targetId,
          sousType: formData.sousType,
          dateDebut: formData.dateDebut || null,
          dateFin: formData.dateFin || null
        };
        
        // Ajouter la relation à la famille
        await addRelationship(currentFamily.id, newRelation);
        
        // Rediriger vers la page de la personne cible ou source selon le contexte
        if (formData.type === 'parent') {
          router.push(`/person/${formData.targetId}?familyId=${currentFamily.id}`); // Rediriger vers l'enfant
        } else {
          router.push(`/person/${formData.sourceId}?familyId=${currentFamily.id}`); // Rediriger vers la première personne
        }
      } catch (error) {
        console.error('Erreur lors de la sauvegarde:', error);
        setErrors(prev => ({
          ...prev,
          submit: "Une erreur est survenue lors de la sauvegarde"
        }));
      } finally {
        setIsSaving(false);
      }
    };
    
    // Obtenir le libellé approprié pour les personnes source et cible selon le type de relation
    const getLabels = () => {
      switch (formData.type) {
        case 'parent':
          return { source: 'Parent', target: 'Enfant' };
        case 'conjoint':
          return { source: 'Personne 1', target: 'Personne 2 (conjoint)' };
        default:
          return { source: 'Personne 1', target: 'Personne 2' };
      }
    };
    
    const labels = getLabels();
  
    if (loading) {
      return (
        <div className="flex items-center justify-center min-h-screen">
          <div className="text-center">
            <h2 className="text-xl font-semibold mb-2">Chargement des données...</h2>
            <div className="w-12 h-12 border-4 border-t-blue-500 border-b-blue-700 rounded-full animate-spin mx-auto"></div>
          </div>
        </div>
      );
    }
  
    if (!currentFamily) {
      return (
        <div className="container mx-auto px-4 py-8">
          <div className="bg-white rounded-lg shadow-md p-6 text-center">
            <h2 className="text-2xl font-semibold mb-4">Aucun arbre généalogique sélectionné</h2>
            <p className="mb-6">Veuillez sélectionner un arbre généalogique pour ajouter une relation.</p>
            <Link href="/family" className="btn btn-primary">
              Voir mes arbres généalogiques
            </Link>
          </div>
        </div>
      );
    }
  
    return (
      <div className="container mx-auto px-4 py-8">
        <div className="mb-6">
          <Link 
            href={
              sourceId ? 
                `/person/${sourceId}?familyId=${currentFamily.id}` : 
                targetId ? 
                  `/person/${targetId}?familyId=${currentFamily.id}` : 
                  `/person?familyId=${currentFamily.id}`
            } 
            className="text-blue-600 hover:underline inline-flex items-center"
          >
            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor">
              <path fillRule="evenodd" d="M9.707 14.707a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 1.414L7.414 9H15a1 1 0 110 2H7.414l2.293 2.293a1 1 0 010 1.414z" clipRule="evenodd" />
            </svg>
            Retour
          </Link>
        </div>
        
        <div className="bg-white rounded-lg shadow-md p-6">
          <h1 className="text-2xl font-bold mb-6">
            Ajouter une nouvelle relation
          </h1>
          
          {sourcePerson && (
            <div className="mb-6 bg-blue-50 border border-blue-200 rounded-lg p-4">
              <h2 className="font-semibold text-blue-800 mb-2">
                {formData.type === 'parent' ? 'Parent' : 'Personne 1'}
              </h2>
              <p>{sourcePerson.prenom} {sourcePerson.nom}</p>
            </div>
          )}
          
          {targetPerson && formData.type === 'parent' && (
            <div className="mb-6 bg-green-50 border border-green-200 rounded-lg p-4">
              <h2 className="font-semibold text-green-800 mb-2">Enfant</h2>
              <p>{targetPerson.prenom} {targetPerson.nom}</p>
            </div>
          )}
          
          <form onSubmit={handleSubmit}>
            {errors.submit && (
              <div className="mb-6 bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded">
                {errors.submit}
              </div>
            )}
            
            <div className="mb-6">
              <label htmlFor="type" className="form-label">Type de relation</label>
              <select
                id="type"
                name="type"
                value={formData.type}
                onChange={handleChange}
                className="form-input"
              >
                <option value="parent">Parent-Enfant</option>
                <option value="conjoint">Conjoint</option>
              </select>
            </div>
            
            {/* Sélection de la personne source si elle n'est pas déjà définie */}
            {!sourceId && (
              <div className="mb-6">
                <label htmlFor="sourceId" className="form-label">
                  {labels.source} <span className="text-red-500">*</span>
                </label>
                <select
                  id="sourceId"
                  name="sourceId"
                  value={formData.sourceId}
                  onChange={handleChange}
                  className={`form-input ${errors.sourceId ? 'border-red-500 ring-1 ring-red-500' : ''}`}
                  required
                >
                  <option value="">Sélectionner une personne</option>
                  {availablePersons.map(person => (
                    <option 
                      key={person.id} 
                      value={person.id}
                      disabled={person.id === formData.targetId}
                    >
                      {person.prenom} {person.nom}
                    </option>
                  ))}
                </select>
                {errors.sourceId && (
                  <p className="text-red-500 text-sm mt-1">{errors.sourceId}</p>
                )}
              </div>
            )}
            
            {/* Sélection de la personne cible si elle n'est pas déjà définie */}
            {!targetId && (
              <div className="mb-6">
                <label htmlFor="targetId" className="form-label">
                  {labels.target} <span className="text-red-500">*</span>
                </label>
                
                <div className="mb-4">
                  <div className="flex items-center space-x-4 mb-2">
                    <label className="inline-flex items-center">
                      <input
                        type="radio"
                        name="personMode"
                        value="existing"
                        checked={formData.existingPerson}
                        onChange={handleModeChange}
                        className="form-radio h-4 w-4 text-blue-600"
                      />
                      <span className="ml-2">Personne existante</span>
                    </label>
                    <label className="inline-flex items-center">
                      <input
                        type="radio"
                        name="personMode"
                        value="new"
                        checked={!formData.existingPerson}
                        onChange={handleModeChange}
                        className="form-radio h-4 w-4 text-blue-600"
                      />
                      <span className="ml-2">Créer une nouvelle personne</span>
                    </label>
                  </div>
                </div>
                
                {formData.existingPerson ? (
                  // Sélectionner une personne existante
                  <select
                    id="targetId"
                    name="targetId"
                    value={formData.targetId}
                    onChange={handleChange}
                    className={`form-input ${errors.targetId ? 'border-red-500 ring-1 ring-red-500' : ''}`}
                    required
                  >
                    <option value="">Sélectionner une personne</option>
                    {availablePersons.map(person => (
                      <option 
                        key={person.id} 
                        value={person.id}
                        disabled={person.id === formData.sourceId}
                      >
                        {person.prenom} {person.nom}
                      </option>
                    ))}
                  </select>
                ) : (
                  // Créer une nouvelle personne avec un lien vers le formulaire
                  <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-4">
                    <p className="text-yellow-800 mb-3">
                      Vous allez créer une nouvelle personne à relier.
                    </p>
                    <Link
                      href={`/person/new?familyId=${currentFamily.id}&returnTo=${encodeURIComponent(`/relationship/new?type=${formData.type}&sourceId=${formData.sourceId}&familyId=${currentFamily.id}`)}`}
                      className="btn btn-primary"
                    >
                      Créer une nouvelle personne
                    </Link>
                  </div>
                )}
                
                {errors.targetId && (
                  <p className="text-red-500 text-sm mt-1">{errors.targetId}</p>
                )}
              </div>
            )}
            
            {/* Sous-type de relation */}
            <div className="mb-6">
              <label htmlFor="sousType" className="form-label">Type spécifique</label>
              <select
                id="sousType"
                name="sousType"
                value={formData.sousType}
                onChange={handleChange}
                className="form-input"
              >
                {formData.type === 'parent' && (
                  <>
                    <option value="pere">Père</option>
                    <option value="mere">Mère</option>
                    <option value="adoptif">Parent adoptif</option>
                  </>
                )}
                
                {formData.type === 'conjoint' && (
                  <>
                    <option value="marie">Marié(e)</option>
                    <option value="non_marie">Non marié(e)</option>
                  </>
                )}
              </select>
            </div>
            
            {/* Date de début (mariage, adoption, etc.) */}
            {formData.type === 'conjoint' && (
              <div className="mb-6">
                <label htmlFor="dateDebut" className="form-label">Date de mariage/union</label>
                <input
                  type="date"
                  id="dateDebut"
                  name="dateDebut"
                  value={formData.dateDebut}
                  onChange={handleChange}
                  className="form-input"
                />
              </div>
            )}
            
            {/* Date de fin (divorce, etc.) */}
            {formData.type === 'conjoint' && formData.sousType === 'marie' && (
              <div className="mb-6">
                <label htmlFor="dateFin" className="form-label">Date de divorce/séparation (si applicable)</label>
                <input
                  type="date"
                  id="dateFin"
                  name="dateFin"
                  value={formData.dateFin}
                  onChange={handleChange}
                  className="form-input"
                />
              </div>
            )}
            
            <div className="flex justify-end gap-4 mt-8">
              <Link 
                href={
                  sourceId ? 
                    `/person/${sourceId}?familyId=${currentFamily.id}` : 
                    targetId ? 
                      `/person/${targetId}?familyId=${currentFamily.id}` : 
                      `/person?familyId=${currentFamily.id}`
                }
                className="btn btn-secondary"
              >
                Annuler
              </Link>
              
              <button
                type="submit"
                className="btn btn-primary"
                disabled={isSaving || !formData.existingPerson}
              >
                {isSaving ? 'Enregistrement...' : 'Enregistrer la relation'}
              </button>
            </div>
          </form>
        </div>
      </div>
    );
  }// END OF FILE: src/app/relationship/new/page.tsx

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/app/search/components/DirectRelationships.tsx

import React, { useEffect } from 'react';
import { Family } from '@/lib/models/Families';
import { Person } from '@/lib/models/Person';
import { findDirectRelationships, DirectRelationshipResults } from '../utils/relationshipUtils';

interface DirectRelationshipsProps {
  person: Person;
  family: Family;
  setSearchResults: (results: DirectRelationshipResults | null) => void;
}

const DirectRelationships: React.FC<DirectRelationshipsProps> = ({
  person,
  family,
  setSearchResults
}) => {
  useEffect(() => {
    // Effectuer la recherche dès que le composant est monté ou que la personne change
    const results = findDirectRelationships(person.id, family);
    setSearchResults(results);
  }, [person.id, family, setSearchResults]);

  return (
    <div>
      <h2 className="text-xl font-semibold mb-4">Relations directes de {person.prenom} {person.nom}</h2>
      <p className="text-gray-600 mb-4">
        Recherche de toutes les relations directes : parents, frères/sœurs, enfants, grands-parents...
      </p>
      <div className="flex items-center justify-center py-4">
        <div className="w-8 h-8 border-4 border-t-blue-500 border-b-blue-700 rounded-full animate-spin"></div>
        <span className="ml-2">Recherche en cours...</span>
      </div>
    </div>
  );
};

export default DirectRelationships;// END OF FILE: src/app/search/components/DirectRelationships.tsx

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/app/search/components/PersonSelector.tsx

import React, { useState } from 'react';
import { Person } from '@/lib/models/Person';

interface PersonSelectorProps {
  persons: Person[];
  onSelectPerson: (person: Person | null) => void;
  selectedPerson: Person | null;
}

const PersonSelector: React.FC<PersonSelectorProps> = ({ 
  persons, 
  onSelectPerson,
  selectedPerson
}) => {
  const [searchTerm, setSearchTerm] = useState('');

  // Filtrer les personnes selon le terme de recherche
  const filteredPersons = persons.filter(person =>
    `${person.prenom} ${person.nom}`.toLowerCase().includes(searchTerm.toLowerCase())
  );

  return (
    <div>
      <div className="mb-4">
        <input
          type="text"
          placeholder="Rechercher une personne..."
          className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
        />
      </div>
      
      <div className="max-h-80 overflow-y-auto">
        <ul className="divide-y divide-gray-200">
          {filteredPersons.map(person => (
            <li key={person.id} className="py-2">
              <button
                className={`w-full text-left px-3 py-2 rounded-md ${
                  selectedPerson?.id === person.id ? 'bg-blue-100 text-blue-800' : 'hover:bg-gray-50'
                }`}
                onClick={() => onSelectPerson(person)}
              >
                <div className="font-medium">{person.prenom} {person.nom}</div>
                <div className="text-sm text-gray-500">
                  Né(e) : {person.birthDate ? new Date(person.birthDate).toLocaleDateString() : 'Inconnue'}
                  {person.etat === 'mort' && person.deathDate && 
                    ` • Décès : ${new Date(person.deathDate).toLocaleDateString()}`
                  }
                </div>
              </button>
            </li>
          ))}
          
          {filteredPersons.length === 0 && (
            <li className="py-4 text-center text-gray-500">
              Aucune personne trouvée pour "{searchTerm}"
            </li>
          )}
        </ul>
      </div>
    </div>
  );
};

export default PersonSelector;// END OF FILE: src/app/search/components/PersonSelector.tsx

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/app/search/components/RelationshipFinder.tsx

import React, { useState } from 'react';
import { Family } from '@/lib/models/Families';
import { Person } from '@/lib/models/Person';
import { findRelationshipPath, RelationshipPath } from '../utils/graphUtils';

interface RelationshipFinderProps {
  sourcePerson: Person;
  family: Family;
  setSearchResults: (results: RelationshipPath | null) => void;
}

const RelationshipFinder: React.FC<RelationshipFinderProps> = ({
  sourcePerson,
  family,
  setSearchResults
}) => {
  const [targetPersonId, setTargetPersonId] = useState<string>('');
  const [isSearching, setIsSearching] = useState(false);
  
  const handleSearch = () => {
    if (!targetPersonId) return;
    
    setIsSearching(true);
    
    // Simuler un délai pour montrer le chargement (pourrait être retiré)
    setTimeout(() => {
      const results = findRelationshipPath(sourcePerson.id, targetPersonId, family);
      setSearchResults(results);
      setIsSearching(false);
    }, 500);
  };

  return (
    <div>
      <h2 className="text-xl font-semibold mb-4">
        Trouver la relation avec {sourcePerson.prenom} {sourcePerson.nom}
      </h2>
      
      <div className="mb-4">
        <label htmlFor="targetPerson" className="block text-sm font-medium text-gray-700 mb-1">
          Sélectionner la deuxième personne
        </label>
        <select
          id="targetPerson"
          className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
          value={targetPersonId}
          onChange={(e) => setTargetPersonId(e.target.value)}
        >
          <option value="">Choisir une personne</option>
          {family.persons
            .filter(p => p.id !== sourcePerson.id)
            .map(person => (
              <option key={person.id} value={person.id}>
                {person.prenom} {person.nom}
              </option>
            ))}
        </select>
      </div>
      
      <button
        onClick={handleSearch}
        disabled={!targetPersonId || isSearching}
        className="w-full px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:bg-blue-300"
      >
        {isSearching ? 'Recherche en cours...' : 'Trouver la relation'}
      </button>
    </div>
  );
};

export default RelationshipFinder;// END OF FILE: src/app/search/components/RelationshipFinder.tsx

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/app/search/components/RelationshipGraph.tsx

import React, { useEffect, useRef } from 'react';
import { Family } from '@/lib/models/Families';
import { Person } from '@/lib/models/Person';
import { DirectRelationshipResults } from '../utils/relationshipUtils';
import { RelationshipPath } from '../utils/graphUtils';

interface RelationshipGraphProps {
  family: Family;
  focusPerson: Person;
  relationshipData?: DirectRelationshipResults | RelationshipPath;
}

const RelationshipGraph: React.FC<RelationshipGraphProps> = ({
  family,
  focusPerson,
  relationshipData
}) => {
  const svgRef = useRef<SVGSVGElement>(null);
  
  useEffect(() => {
    if (!svgRef.current || !relationshipData) return;
    
    // Ici, on pourrait implémenter une visualisation graphique
    // en utilisant D3.js ou une approche plus simple
    
    const svg = svgRef.current;
    const width = svg.clientWidth;
    const height = svg.clientHeight;
    
    // Effacer le contenu précédent
    while (svg.firstChild) {
      svg.removeChild(svg.firstChild);
    }
    
    // Dessiner le graphe simplifié
    const centerX = width / 2;
    const centerY = height / 2;
    
    // Créer un nœud central pour la personne principale
    createNode(svg, centerX, centerY, focusPerson.prenom, '#4F46E5');
    
    // Si c'est un résultat de relation directe
    if ('parents' in relationshipData) {
      const direct = relationshipData as DirectRelationshipResults;
      
      // Positionner les parents en haut
      if (direct.parents.father) {
        createNode(svg, centerX - 120, centerY - 100, direct.parents.father.prenom, '#3B82F6');
        createLink(svg, centerX - 120, centerY - 100, centerX, centerY, '#3B82F6');
      }
      
      if (direct.parents.mother) {
        createNode(svg, centerX + 120, centerY - 100, direct.parents.mother.prenom, '#EC4899');
        createLink(svg, centerX + 120, centerY - 100, centerX, centerY, '#EC4899');
      }
      
      // Positionner les frères et sœurs à gauche
      const siblings = [...direct.siblings.brothers, ...direct.siblings.sisters];
      siblings.slice(0, 3).forEach((sibling, index) => {
        createNode(svg, centerX - 150, centerY - 40 + index * 60, sibling.prenom, '#8B5CF6');
        createLink(svg, centerX - 150, centerY - 40 + index * 60, centerX, centerY, '#8B5CF6');
      });
      
      // Positionner les enfants en bas
      const children = [...direct.children.sons, ...direct.children.daughters];
      children.slice(0, 3).forEach((child, index) => {
        createNode(svg, centerX - 100 + index * 100, centerY + 100, child.prenom, '#10B981');
        createLink(svg, centerX - 100 + index * 100, centerY + 100, centerX, centerY, '#10B981');
      });
      
      // Positionner les conjoints à droite
      direct.spouses.slice(0, 2).forEach((spouse, index) => {
        createNode(svg, centerX + 150, centerY - 40 + index * 60, spouse.prenom, '#F59E0B');
        createLink(svg, centerX + 150, centerY - 40 + index * 60, centerX, centerY, '#F59E0B');
      });
    } 
    // Si c'est un résultat de recherche de chemin
    else if ('path' in relationshipData) {
      const path = relationshipData as RelationshipPath;
      
      // Dessiner le chemin linéaire
      const pathLength = path.path.length;
      if (pathLength > 1) {
        const stepX = width / (pathLength);
        
        path.path.forEach((node, index) => {
          const person = family.persons.find(p => p.id === node.personId);
          if (!person) return;
          
          const x = 50 + index * stepX;
          const y = height / 2;
          
          createNode(svg, x, y, person.prenom, index === 0 || index === pathLength - 1 ? '#4F46E5' : '#6B7280');
          
          if (index > 0) {
            createLink(svg, x - stepX, y, x, y, '#6B7280');
          }
        });
      }
    }
    
  }, [family, focusPerson, relationshipData]);
  
  // Fonction utilitaire pour créer un nœud (cercle avec texte)
  const createNode = (
    svg: SVGSVGElement, 
    x: number, 
    y: number, 
    label: string, 
    color: string
  ) => {
    const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    
    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    circle.setAttribute('cx', x.toString());
    circle.setAttribute('cy', y.toString());
    circle.setAttribute('r', '30');
    circle.setAttribute('fill', color);
    group.appendChild(circle);
    
    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text.setAttribute('x', x.toString());
    text.setAttribute('y', y.toString());
    text.setAttribute('text-anchor', 'middle');
    text.setAttribute('dominant-baseline', 'middle');
    text.setAttribute('fill', 'white');
    text.setAttribute('font-size', '12');
    text.textContent = label;
    group.appendChild(text);
    
    svg.appendChild(group);
  };
  
  // Fonction utilitaire pour créer un lien entre deux nœuds
  const createLink = (
    svg: SVGSVGElement, 
    x1: number, 
    y1: number, 
    x2: number, 
    y2: number, 
    color: string
  ) => {
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', x1.toString());
    line.setAttribute('y1', y1.toString());
    line.setAttribute('x2', x2.toString());
    line.setAttribute('y2', y2.toString());
    line.setAttribute('stroke', color);
    line.setAttribute('stroke-width', '2');
    
    svg.appendChild(line);
  };
  
  return (
    <div className="bg-white rounded-lg shadow-md p-6">
      <h2 className="text-xl font-semibold mb-4">Visualisation des relations</h2>
      <svg 
        ref={svgRef} 
        className="w-full h-96 border rounded-lg"
        viewBox="0 0 600 400"
        preserveAspectRatio="xMidYMid meet"
      />
      <p className="text-center text-sm text-gray-500 mt-2">
        Visualisation simplifiée des relations familiales
      </p>
    </div>
  );
};

export default RelationshipGraph;   // END OF FILE: src/app/search/components/RelationshipGraph.tsx

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/app/search/components/SearchResults.tsx

import React from 'react';
import Link from 'next/link';
import { Family } from '@/lib/models/Families';
import { Person } from '@/lib/models/Person';
import { DirectRelationshipResults } from '../utils/relationshipUtils';
import { RelationshipPath } from '../utils/graphUtils';
import { PathNode } from '../../search/utils/graphUtils';


interface SearchResultsProps {
  results: DirectRelationshipResults | RelationshipPath;
  family: Family;
}


// Ajoutez ce composant qui était présent dans la version originale
// Composant pour afficher les résultats de relations directes
const DirectRelationshipResults: React.FC<{ 
    results: DirectRelationshipResults; 
    family: Family;
  }> = ({ results, family }) => {
    return (
      <div className="bg-white rounded-lg shadow-md p-6">
        <h2 className="text-xl font-semibold mb-4">Résultats de la recherche</h2>
        
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          {/* Parents */}
          <div className="border rounded-lg p-4">
            <h3 className="font-medium text-lg mb-2">Parents</h3>
            {(!results.parents.father && !results.parents.mother) ? (
              <p className="text-gray-500">Aucun parent trouvé</p>
            ) : (
              <ul className="space-y-2">
                {results.parents.father && (
                  <li className="flex items-center">
                    <span className="text-blue-600 mr-2">Père:</span>
                    <PersonLink person={results.parents.father} family={family} />
                  </li>
                )}
                {results.parents.mother && (
                  <li className="flex items-center">
                    <span className="text-pink-600 mr-2">Mère:</span>
                    <PersonLink person={results.parents.mother} family={family} />
                  </li>
                )}
              </ul>
            )}
          </div>
          
          {/* Frères et sœurs */}
          <div className="border rounded-lg p-4">
            <h3 className="font-medium text-lg mb-2">Frères et sœurs</h3>
            {(results.siblings.brothers.length === 0 && results.siblings.sisters.length === 0) ? (
              <p className="text-gray-500">Aucun frère ou sœur trouvé</p>
            ) : (
              <>
                {results.siblings.brothers.length > 0 && (
                  <div className="mb-2">
                    <h4 className="font-medium">Frères ({results.siblings.brothers.length})</h4>
                    <ul className="list-disc list-inside ml-2">
                      {results.siblings.brothers.map(brother => (
                        <li key={brother.id}>
                          <PersonLink person={brother} family={family} />
                        </li>
                      ))}
                    </ul>
                  </div>
                )}
                
                {results.siblings.sisters.length > 0 && (
                  <div>
                    <h4 className="font-medium">Sœurs ({results.siblings.sisters.length})</h4>
                    <ul className="list-disc list-inside ml-2">
                      {results.siblings.sisters.map(sister => (
                        <li key={sister.id}>
                          <PersonLink person={sister} family={family} />
                        </li>
                      ))}
                    </ul>
                  </div>
                )}
              </>
            )}
          </div>
          
          {/* Enfants */}
          <div className="border rounded-lg p-4">
            <h3 className="font-medium text-lg mb-2">Enfants</h3>
            {(results.children.sons.length === 0 && results.children.daughters.length === 0) ? (
              <p className="text-gray-500">Aucun enfant trouvé</p>
            ) : (
              <>
                {results.children.sons.length > 0 && (
                  <div className="mb-2">
                    <h4 className="font-medium">Fils ({results.children.sons.length})</h4>
                    <ul className="list-disc list-inside ml-2">
                      {results.children.sons.map(son => (
                        <li key={son.id}>
                          <PersonLink person={son} family={family} />
                        </li>
                      ))}
                    </ul>
                  </div>
                )}
                
                {results.children.daughters.length > 0 && (
                  <div>
                    <h4 className="font-medium">Filles ({results.children.daughters.length})</h4>
                    <ul className="list-disc list-inside ml-2">
                      {results.children.daughters.map(daughter => (
                        <li key={daughter.id}>
                          <PersonLink person={daughter} family={family} />
                        </li>
                      ))}
                    </ul>
                  </div>
                )}
              </>
            )}
          </div>
          
          {/* Grands-parents */}
          <div className="border rounded-lg p-4">
            <h3 className="font-medium text-lg mb-2">Grands-parents</h3>
            {(results.grandparents.grandfathers.length === 0 && results.grandparents.grandmothers.length === 0) ? (
              <p className="text-gray-500">Aucun grand-parent trouvé</p>
            ) : (
              <>
                {results.grandparents.grandfathers.length > 0 && (
                  <div className="mb-2">
                    <h4 className="font-medium">Grands-pères ({results.grandparents.grandfathers.length})</h4>
                    <ul className="list-disc list-inside ml-2">
                      {results.grandparents.grandfathers.map(grandfather => (
                        <li key={grandfather.id}>
                          <PersonLink person={grandfather} family={family} />
                        </li>
                      ))}
                    </ul>
                  </div>
                )}
                
                {results.grandparents.grandmothers.length > 0 && (
                  <div>
                    <h4 className="font-medium">Grands-mères ({results.grandparents.grandmothers.length})</h4>
                    <ul className="list-disc list-inside ml-2">
                      {results.grandparents.grandmothers.map(grandmother => (
                        <li key={grandmother.id}>
                          <PersonLink person={grandmother} family={family} />
                        </li>
                      ))}
                    </ul>
                  </div>
                )}
              </>
            )}
          </div>
          
          {/* Oncles et tantes */}
          <div className="border rounded-lg p-4">
            <h3 className="font-medium text-lg mb-2">Oncles et tantes</h3>
            {(results.unclesAunts.uncles.length === 0 && results.unclesAunts.aunts.length === 0) ? (
              <p className="text-gray-500">Aucun oncle ou tante trouvé</p>
            ) : (
              <>
                {results.unclesAunts.uncles.length > 0 && (
                  <div className="mb-2">
                    <h4 className="font-medium">Oncles ({results.unclesAunts.uncles.length})</h4>
                    <ul className="list-disc list-inside ml-2">
                      {results.unclesAunts.uncles.map(uncle => (
                        <li key={uncle.id}>
                          <PersonLink person={uncle} family={family} />
                        </li>
                      ))}
                    </ul>
                  </div>
                )}
                
                {results.unclesAunts.aunts.length > 0 && (
                  <div>
                    <h4 className="font-medium">Tantes ({results.unclesAunts.aunts.length})</h4>
                    <ul className="list-disc list-inside ml-2">
                      {results.unclesAunts.aunts.map(aunt => (
                        <li key={aunt.id}>
                          <PersonLink person={aunt} family={family} />
                        </li>
                      ))}
                    </ul>
                  </div>
                )}
              </>
            )}
          </div>
          
          {/* Conjoints */}
          <div className="border rounded-lg p-4">
            <h3 className="font-medium text-lg mb-2">Conjoints</h3>
            {results.spouses.length === 0 ? (
              <p className="text-gray-500">Aucun conjoint trouvé</p>
            ) : (
              <ul className="list-disc list-inside ml-2">
                {results.spouses.map(spouse => (
                  <li key={spouse.id}>
                    <PersonLink person={spouse} family={family} />
                  </li>
                ))}
              </ul>
            )}
          </div>
        </div>
      </div>
    );
  };
  
  // Composant utilitaire pour créer un lien vers une personne
  const PersonLink: React.FC<{
    person: Person;
    family: Family;
  }> = ({ person, family }) => {
    return (
      <Link 
        href={`/person/${person.id}?family=${family.id}`}
        className="text-blue-600 hover:underline"
      >
        {person.prenom} {person.nom}
        <span className="text-gray-500 text-sm ml-1">
          ({person.birthDate ? new Date(person.birthDate).getFullYear() : '?'})
        </span>
      </Link>
    );
  };



const SearchResults: React.FC<SearchResultsProps> = ({ results, family }) => {
  // Vérifier si c'est un résultat de relation directe
  const isDirectRelationship = 'parents' in results;
  
  if (isDirectRelationship) {
    const directResults = results as DirectRelationshipResults;
    return <DirectRelationshipResults results={directResults} family={family} />;
  } else {
    const pathResults = results as RelationshipPath;
    return <RelationshipPathResults results={pathResults} family={family} />;
  }
};

// Version améliorée du composant pour afficher les résultats de relation entre deux personnes
const RelationshipPathResults: React.FC<{
    results: RelationshipPath;
    family: Family;
  }> = ({ results, family }) => {
    // Trouver les personnes impliquées dans le chemin
    const startPerson = family.persons.find(p => p.id === results.path[0].personId);
    const endPerson = family.persons.find(p => p.id === results.path[results.path.length - 1].personId);
    
    return (
      <div className="bg-white rounded-lg shadow-md p-6">
        <h2 className="text-xl font-semibold mb-4">Relation trouvée</h2>
        
        <div className="mb-6 bg-blue-50 p-4 rounded-lg border border-blue-200">
          <div className="text-center mb-2">
            <div className="text-xl">
              {startPerson && (
                <span className="font-semibold">{startPerson.prenom} {startPerson.nom}</span>
              )}
              <span className="mx-2">est</span>
              <span className="font-semibold text-blue-600">{results.description}</span>
              <span className="mx-2">de</span>
              {endPerson && (
                <span className="font-semibold">{endPerson.prenom} {endPerson.nom}</span>
              )}
            </div>
          </div>
        </div>
        
        <div className="border rounded-lg p-4">
          <h3 className="font-medium text-lg mb-3">Explication de la relation</h3>
          
          {/* Version graphique simplifiée (sous forme d'arbre horizontal) */}
          <div className="flex justify-center items-center mb-6 overflow-x-auto py-4">
            {results.path.map((node, index) => {
              const person = family.persons.find(p => p.id === node.personId);
              if (!person) return null;
              
              // Détermine le texte explicatif de la relation
              let relationText = "";
              if (index > 0 && node.relationship) {
                const rel = node.relationship;
                if (rel.type === "parent" && rel.sourceId === node.personId) {
                  relationText = person.sexe === "M" ? "est le père de" : "est la mère de";
                } else if (rel.type === "parent" && rel.targetId === node.personId) {
                  relationText = person.sexe === "M" ? "est le fils de" : "est la fille de";
                } else if (rel.type === "conjoint") {
                  relationText = rel.sousType === "marie" ? 
                    "est marié(e) à" : "est en couple avec";
                }
              }
              
              return (
                <React.Fragment key={index}>
                  {/* Nœud de personne */}
                  <div className="flex flex-col items-center min-w-max">
                    <div className={`w-16 h-16 rounded-full flex items-center justify-center text-white font-bold ${
                      index === 0 ? "bg-blue-600" : 
                      index === results.path.length - 1 ? "bg-green-600" : "bg-gray-600"
                    }`}>
                      {person.prenom.charAt(0)}{person.nom.charAt(0)}
                    </div>
                    <div className="mt-2 text-center">
                      <div className="font-medium">{person.prenom} {person.nom}</div>
                      <div className="text-xs text-gray-500">
                        {person.birthDate ? new Date(person.birthDate).getFullYear() : '?'}
                        {person.etat === 'mort' && person.deathDate && 
                          ` - ${new Date(person.deathDate).getFullYear()}`
                        }
                      </div>
                    </div>
                  </div>
                  
                  {/* Flèche et texte explicatif entre les personnes */}
                  {index < results.path.length - 1 && (
                    <div className="mx-2 flex flex-col items-center justify-center">
                      <div className="text-center text-sm text-gray-600 mb-1 min-w-max px-2">
                        {relationText}
                      </div>
                      <div className="text-gray-400 text-2xl">→</div>
                    </div>
                  )}
                </React.Fragment>
              );
            })}
          </div>
          
          {/* Version textuelle en langage naturel */}
          <div className="bg-gray-50 p-4 rounded-lg">
            <h4 className="font-medium mb-2">Explication en langage naturel:</h4>
            <p className="text-gray-700">
              {buildNaturalLanguageExplanation(results.path, family)}
            </p>
          </div>
        </div>
      </div>
    );
  };
  
  // Fonction pour créer une explication en langage naturel de la relation
  function buildNaturalLanguageExplanation(path: PathNode[], family: Family): string {
    if (path.length <= 1) return "Il s'agit de la même personne.";
    
    const startPerson = family.persons.find(p => p.id === path[0].personId);
    const endPerson = family.persons.find(p => p.id === path[path.length - 1].personId);
    
    if (!startPerson || !endPerson) return "Relation inconnue.";
    
    // Pour les relations directes simples
    if (path.length === 2) {
      const rel = path[1].relationship;
      if (!rel) return "Relation directe inconnue.";
      
      if (rel.type === "parent" && rel.sourceId === path[0].personId) {
        return `${startPerson.prenom} est ${startPerson.sexe === "M" ? "le père" : "la mère"} de ${endPerson.prenom}.`;
      } else if (rel.type === "parent" && rel.targetId === path[0].personId) {
        return `${startPerson.prenom} est ${startPerson.sexe === "M" ? "le fils" : "la fille"} de ${endPerson.prenom}.`;
      } else if (rel.type === "conjoint") {
        return `${startPerson.prenom} est ${rel.sousType === "marie" ? "marié(e)" : "en couple"} avec ${endPerson.prenom}.`;
      }
    }
    
    // Pour les frères et sœurs
    if (path.length === 3 && isFullSiblingPath(path)) {
      return `${startPerson.prenom} et ${endPerson.prenom} sont ${
        startPerson.sexe === endPerson.sexe ? 
          (startPerson.sexe === "M" ? "frères" : "sœurs") : 
          "frère et sœur"
      } (ils partagent les mêmes parents).`;
    }
    
    // Pour les grands-parents / petits-enfants
    if (path.length === 3 && path[1].relationship?.type === "parent" && path[2].relationship?.type === "parent") {
      if (path[1].relationship.targetId === path[0].personId) {
        return `${startPerson.prenom} est ${
          startPerson.sexe === "M" ? "le grand-père" : "la grand-mère"
        } de ${endPerson.prenom}.`;
      } else {
        return `${startPerson.prenom} est ${
          startPerson.sexe === "M" ? "le petit-fils" : "la petite-fille"
        } de ${endPerson.prenom}.`;
      }
    }
    
    // Pour les oncles/tantes ou neveux/nièces
    if (path.length === 4 && isUncleAuntNephewNiecePath(path, family)) {
      const middlePerson = family.persons.find(p => p.id === path[2].personId);
      if (!middlePerson) return "Relation oncle/tante ou neveu/nièce.";
      
      if (isUncleAuntPath(path)) {
        return `${startPerson.prenom} est ${
          startPerson.sexe === "M" ? "l'oncle" : "la tante"
        } de ${endPerson.prenom} (${middlePerson.prenom} est ${
          middlePerson.sexe === "M" ? "le père" : "la mère"
        } de ${endPerson.prenom} et ${
          startPerson.sexe === "M" ? "le frère" : "la sœur"
        } de ${middlePerson.prenom}).`;
      } else {
        return `${startPerson.prenom} est ${
          startPerson.sexe === "M" ? "le neveu" : "la nièce"
        } de ${endPerson.prenom} (${startPerson.prenom} est ${
          startPerson.sexe === "M" ? "le fils" : "la fille"
        } de ${middlePerson.prenom} qui est ${
          middlePerson.sexe === "M" ? "le frère" : "la sœur"
        } de ${endPerson.prenom}).`;
      }
    }
    
    // Pour les cousins
    if (path.length === 5 && isCousinPath(path, family)) {
      return `${startPerson.prenom} et ${endPerson.prenom} sont cousins (ils partagent un grand-parent commun).`;
    }
    
    // Relation complexe : construction étape par étape
    let explanation = `${startPerson.prenom} `;
    
    for (let i = 1; i < path.length; i++) {
      const currentPerson = family.persons.find(p => p.id === path[i].personId);
      const rel = path[i].relationship;
      
      if (!currentPerson || !rel) continue;
      
      const previousPerson = family.persons.find(p => p.id === path[i-1].personId);
      if (!previousPerson) continue;
      
      if (rel.type === "parent") {
        if (rel.sourceId === path[i-1].personId) {
          explanation += `est ${previousPerson.sexe === "M" ? "le père" : "la mère"} de ${currentPerson.prenom}`;
        } else {
          explanation += `est ${previousPerson.sexe === "M" ? "le fils" : "la fille"} de ${currentPerson.prenom}`;
        }
      } else if (rel.type === "conjoint") {
        explanation += `est ${rel.sousType === "marie" ? "marié(e)" : "en couple"} avec ${currentPerson.prenom}`;
      }
      
      explanation += i < path.length - 1 ? ", qui " : ".";
    }
    
    return explanation;
  }
  
  // Fonctions auxiliaires pour déterminer le type de chemin
  function isFullSiblingPath(path: PathNode[]): boolean {
    if (path.length !== 3) return false;
    
    const rel1 = path[1].relationship;
    const rel2 = path[2].relationship;
    
    return !!(rel1 && rel2 && 
      rel1.type === "parent" && rel2.type === "parent" &&
      rel1.sourceId === rel2.sourceId &&
      rel1.targetId === path[0].personId &&
      rel2.targetId === path[2].personId);
  }
  
  function isUncleAuntNephewNiecePath(path: PathNode[], family: Family): boolean {
    if (path.length !== 4) return false;
    
    // Vérifier si c'est un chemin oncle/tante ou neveu/nièce
    return isUncleAuntPath(path) || isNephewNiecePath(path);
  }
  
  function isUncleAuntPath(path: PathNode[]): boolean {
    if (path.length !== 4) return false;
    
    const rel1 = path[1].relationship;
    const rel2 = path[2].relationship;
    const rel3 = path[3].relationship;
    
    return !!(rel1 && rel2 && rel3 &&
      rel1.type === "parent" && 
      rel2.type === "parent" && 
      rel3.type === "parent" &&
      rel1.targetId === path[0].personId &&
      rel2.sourceId === rel1.sourceId &&
      rel3.targetId === path[3].personId);
  }
  
  function isNephewNiecePath(path: PathNode[]): boolean {
    if (path.length !== 4) return false;
    
    const rel1 = path[1].relationship;
    const rel2 = path[2].relationship;
    const rel3 = path[3].relationship;
    
    return !!(rel1 && rel2 && rel3 &&
      rel1.type === "parent" && 
      rel2.type === "parent" && 
      rel3.type === "parent" &&
      rel1.sourceId === path[0].personId &&
      rel2.targetId === path[1].personId &&
      rel3.sourceId === rel2.sourceId);
  }
  
  function isCousinPath(path: PathNode[], family: Family): boolean {
    if (path.length !== 5) return false;
    
    const rel1 = path[1].relationship;
    const rel2 = path[2].relationship;
    const rel3 = path[3].relationship;
    const rel4 = path[4].relationship;
    
    return !!(rel1 && rel2 && rel3 && rel4 &&
      rel1.type === "parent" && 
      rel2.type === "parent" && 
      rel3.type === "parent" && 
      rel4.type === "parent" &&
      rel2.sourceId === rel3.sourceId);
  }


// Ajoutez cet export default à la fin du fichier
export default SearchResults;// END OF FILE: src/app/search/components/SearchResults.tsx

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/app/search/page.tsx

'use client';

import React, { useState } from 'react';
import { useFamily } from '@/context/FamilyContext';
import { Person } from '@/lib/models/Person';
import PersonSelector from './components/PersonSelector';
import DirectRelationships from './components/DirectRelationships';
import RelationshipFinder from './components/RelationshipFinder';
import SearchResults from './components/SearchResults';
import Link from 'next/link';

export default function SearchPage() {
  const { activeFamily, loading } = useFamily();
  const [selectedPerson, setSelectedPerson] = useState<Person | null>(null);
  const [searchResults, setSearchResults] = useState<any | null>(null);
  const [searchType, setSearchType] = useState<'direct' | 'relation'>('direct');

  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="text-center">
          <h2 className="text-xl font-semibold mb-2">Chargement des données...</h2>
          <div className="w-12 h-12 border-4 border-t-blue-500 border-b-blue-700 rounded-full animate-spin mx-auto"></div>
        </div>
      </div>
    );
  }

  if (!activeFamily) {
    return (
      <div className="container mx-auto px-4 py-8">
        <div className="bg-white rounded-lg shadow-md p-6 text-center">
          <h2 className="text-xl font-semibold mb-2">Aucun arbre généalogique sélectionné</h2>
          <p className="text-gray-600 mb-6">Veuillez sélectionner un arbre généalogique pour effectuer une recherche.</p>
          <Link href="/family" className="btn btn-primary">
            Voir mes arbres généalogiques
          </Link>
        </div>
      </div>
    );
  }

  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-3xl font-bold mb-6">Recherche Généalogique</h1>
      
      <div className="grid grid-cols-1 lg:grid-cols-12 gap-8">
        <div className="lg:col-span-4">
          <div className="bg-white rounded-lg shadow-md p-6 mb-6">
            <h2 className="text-xl font-semibold mb-4">Sélection de la personne</h2>
            <PersonSelector 
              persons={activeFamily.persons}
              onSelectPerson={setSelectedPerson}
              selectedPerson={selectedPerson}
            />
          </div>
          
          <div className="bg-white rounded-lg shadow-md p-6">
            <h2 className="text-xl font-semibold mb-4">Type de recherche</h2>
            <div className="flex flex-col space-y-2">
              <label className="inline-flex items-center">
                <input
                  type="radio"
                  value="direct"
                  checked={searchType === 'direct'}
                  onChange={() => setSearchType('direct')}
                  className="form-radio h-4 w-4 text-blue-600"
                />
                <span className="ml-2">Relations directes</span>
              </label>
              <label className="inline-flex items-center">
                <input
                  type="radio"
                  value="relation"
                  checked={searchType === 'relation'}
                  onChange={() => setSearchType('relation')}
                  className="form-radio h-4 w-4 text-blue-600"
                />
                <span className="ml-2">Trouver la relation exacte</span>
              </label>
            </div>
          </div>
        </div>
        
        <div className="lg:col-span-8">
          {selectedPerson ? (
            <div className="bg-white rounded-lg shadow-md p-6">
              {searchType === 'direct' ? (
                <DirectRelationships 
                  person={selectedPerson}
                  family={activeFamily}
                  setSearchResults={setSearchResults}
                />
              ) : (
                <RelationshipFinder 
                  sourcePerson={selectedPerson}
                  family={activeFamily}
                  setSearchResults={setSearchResults}
                />
              )}
            </div>
          ) : (
            <div className="bg-white rounded-lg shadow-md p-6 text-center">
              <p className="text-gray-600">Veuillez sélectionner une personne pour commencer la recherche.</p>
            </div>
          )}
          
          {searchResults && (
            <div className="mt-6">
              <SearchResults results={searchResults} family={activeFamily} />
            </div>
          )}
        </div>
      </div>
    </div>
  );
}// END OF FILE: src/app/search/page.tsx

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/app/search/utils/graphUtils.ts

import { Family } from '@/lib/models/Families';
import { Person } from '@/lib/models/Person';
import { Relationship } from '@/lib/models/Relationship';

// Type pour représenter un nœud dans le chemin
interface PathNode {
  personId: string;
  relationship?: Relationship;
  via?: string; // ID de la personne intermédiaire
}

// Type pour représenter un chemin complet entre deux personnes
export interface RelationshipPath {
  path: PathNode[];
  description: string;
}

// Fonction pour trouver le plus court chemin entre deux personnes (BFS)
export function findRelationshipPath(sourceId: string, targetId: string, family: Family): RelationshipPath | null {
  if (sourceId === targetId) {
    return {
      path: [{ personId: sourceId }],
      description: "Même personne"
    };
  }
  
  const visited = new Set<string>([sourceId]);
  const queue: { id: string; path: PathNode[] }[] = [{ id: sourceId, path: [{ personId: sourceId }] }];
  
  while (queue.length > 0) {
    const { id, path } = queue.shift()!;
    
    // Trouver toutes les relations de cette personne
    const relations = family.relationships.filter(
      r => r.sourceId === id || r.targetId === id
    );
    
    for (const relation of relations) {
      const nextId = relation.sourceId === id ? relation.targetId : relation.sourceId;
      
      if (!visited.has(nextId)) {
        visited.add(nextId);
        
        const newPath = [...path, { 
          personId: nextId, 
          relationship: relation,
          via: relation.type === 'parent' ? (relation.sourceId === id ? nextId : id) : undefined
        }];
        
        if (nextId === targetId) {
          // Trouver le chemin
          return {
            path: newPath,
            description: describeRelationship(newPath, family)
          };
        }
        
        queue.push({ id: nextId, path: newPath });
      }
    }
  }
  
  // Aucun chemin trouvé
  return null;
}

// Fonction pour décrire en langage naturel la relation entre deux personnes
function describeRelationship(path: PathNode[], family: Family): string {
  if (path.length <= 1) return "Même personne";
  if (path.length === 2) {
    const relation = path[1].relationship!;
    const person1 = family.persons.find(p => p.id === path[0].personId)!;
    const person2 = family.persons.find(p => p.id === path[1].personId)!;
    
    if (relation.type === 'parent') {
      if (relation.sourceId === path[0].personId) {
        return person1.sexe === 'M' ? "Père" : "Mère";
      } else {
        return person2.sexe === 'M' ? "Fils" : "Fille";
      }
    } else if (relation.type === 'conjoint') {
      return relation.sousType === 'marie' ? "Conjoint(e)" : "Partenaire";
    }
  }
  
  // Relation plus complexe - analyser le chemin
  // Frères/Sœurs (même parents)
  if (path.length === 3 && 
      path[1].relationship?.type === 'parent' && 
      path[2].relationship?.type === 'parent' &&
      path[1].relationship.targetId === path[0].personId &&
      path[2].relationship.targetId === path[path.length-1].personId &&
      path[1].relationship.sourceId === path[2].relationship.sourceId) {
    
    const sibling = family.persons.find(p => p.id === path[path.length-1].personId)!;
    return sibling.sexe === 'M' ? "Frère" : "Sœur";
  }
  
  // Grands-parents / petits-enfants
  if (path.length === 3 && 
      path[1].relationship?.type === 'parent' && 
      path[2].relationship?.type === 'parent') {
    
    if (path[1].relationship.targetId === path[0].personId && 
        path[2].relationship.targetId === path[1].personId) {
      // Grand-parent
      const grandparent = family.persons.find(p => p.id === path[path.length-1].personId)!;
      return grandparent.sexe === 'M' ? "Grand-père" : "Grand-mère";
    } else if (path[1].relationship.sourceId === path[0].personId && 
               path[2].relationship.sourceId === path[1].personId) {
      // Petit-enfant
      const grandchild = family.persons.find(p => p.id === path[path.length-1].personId)!;
      return grandchild.sexe === 'M' ? "Petit-fils" : "Petite-fille";
    }
  }
  
  // Oncles/tantes - neveux/nièces
  if (path.length === 4 && isUncleAuntPath(path)) {
    const relative = family.persons.find(p => p.id === path[path.length-1].personId)!;
    if (path[1].relationship?.targetId === path[0].personId) {
      return relative.sexe === 'M' ? "Oncle" : "Tante";
    } else {
      return relative.sexe === 'M' ? "Neveu" : "Nièce";
    }
  }
  
  // Cousins
  if (path.length === 5 && isCousinPath(path)) {
    const cousin = family.persons.find(p => p.id === path[path.length-1].personId)!;
    return cousin.sexe === 'M' ? "Cousin" : "Cousine";
  }
  
  // Relation générique si aucune correspondance spécifique n'est trouvée
  return `Relation familiale (${path.length - 1} liens)`;
}

// Fonction pour identifier un chemin oncle/tante - neveu/nièce
function isUncleAuntPath(path: PathNode[]): boolean {
  if (path.length !== 4) return false;
  
  const rel1 = path[1].relationship;
  const rel2 = path[2].relationship;
  const rel3 = path[3].relationship;
  
  if (!rel1 || !rel2 || !rel3) return false;
  
  // Schéma: personne -> parent -> frère/sœur du parent -> neveu/nièce
  // ou: personne -> frère/sœur -> enfant du frère/sœur -> oncle/tante
  
  return (
    rel1.type === 'parent' && 
    rel2.type === 'parent' && 
    rel3.type === 'parent' &&
    rel1.targetId === path[0].personId && 
    rel2.targetId !== path[1].personId && 
    rel2.sourceId === rel1.sourceId
  ) || (
    rel1.type === 'parent' && 
    rel2.type === 'parent' && 
    rel3.type === 'parent' &&
    rel1.sourceId === path[0].personId && 
    rel2.sourceId !== path[1].personId && 
    rel2.targetId === rel1.targetId
  );
}

// Fonction pour identifier un chemin de cousins
function isCousinPath(path: PathNode[]): boolean {
  if (path.length !== 5) return false;
  
  const rel1 = path[1].relationship;
  const rel2 = path[2].relationship;
  const rel3 = path[3].relationship;
  const rel4 = path[4].relationship;
  
  if (!rel1 || !rel2 || !rel3 || !rel4) return false;
  
  // Schéma: personne -> parent -> grand-parent -> parent -> cousin
  return (
    rel1.type === 'parent' && 
    rel2.type === 'parent' && 
    rel3.type === 'parent' && 
    rel4.type === 'parent' &&
    rel1.targetId === path[0].personId && 
    rel2.targetId === path[1].personId &&
    rel3.sourceId === rel2.sourceId &&
    rel4.targetId === path[4].personId
  );
}// END OF FILE: src/app/search/utils/graphUtils.ts

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/app/search/utils/relationshipUtils.ts

import { Family } from '@/lib/models/Families';
import { Person } from '@/lib/models/Person';
import { Relationship } from '@/lib/models/Relationship';

// Fonction pour trouver les parents d'une personne
export function findParents(personId: string, family: Family): Person[] {
  const parentRelations = family.relationships.filter(
    r => r.type === 'parent' && r.targetId === personId
  );
  
  return parentRelations.map(relation => 
    family.persons.find(p => p.id === relation.sourceId)
  ).filter(Boolean) as Person[];
}

// Fonction pour trouver les enfants d'une personne
export function findChildren(personId: string, family: Family): Person[] {
  const childRelations = family.relationships.filter(
    r => r.type === 'parent' && r.sourceId === personId
  );
  
  return childRelations.map(relation => 
    family.persons.find(p => p.id === relation.targetId)
  ).filter(Boolean) as Person[];
}

// Fonction pour trouver les frères et sœurs
export function findSiblings(personId: string, family: Family): Person[] {
  const person = family.persons.find(p => p.id === personId);
  if (!person) return [];
  
  // Trouver les parents
  const parents = findParents(personId, family);
  
  // Trouver tous les enfants de ces parents
  const siblings = new Set<Person>();
  parents.forEach(parent => {
    const children = findChildren(parent.id, family);
    children.forEach(child => {
      // Ne pas inclure la personne elle-même
      if (child.id !== personId) {
        siblings.add(child);
      }
    });
  });
  
  return Array.from(siblings);
}

// Fonction pour trouver les grands-parents
export function findGrandparents(personId: string, family: Family): Person[] {
  const parents = findParents(personId, family);
  
  const grandparents = new Set<Person>();
  parents.forEach(parent => {
    const parentParents = findParents(parent.id, family);
    parentParents.forEach(gp => grandparents.add(gp));
  });
  
  return Array.from(grandparents);
}

// Fonction pour trouver les oncles et tantes
export function findUnclesAunts(personId: string, family: Family): Person[] {
  const parents = findParents(personId, family);
  
  const unclesAunts = new Set<Person>();
  parents.forEach(parent => {
    const parentSiblings = findSiblings(parent.id, family);
    parentSiblings.forEach(sibling => unclesAunts.add(sibling));
  });
  
  return Array.from(unclesAunts);
}

// Fonction pour trouver les conjoints
export function findSpouses(personId: string, family: Family): Person[] {
  const spouseRelations = family.relationships.filter(
    r => r.type === 'conjoint' && (r.sourceId === personId || r.targetId === personId)
  );
  
  return spouseRelations.map(relation => {
    const spouseId = relation.sourceId === personId ? relation.targetId : relation.sourceId;
    return family.persons.find(p => p.id === spouseId);
  }).filter(Boolean) as Person[];
}

// Fonction générique pour catégoriser les personnes par sexe
export function categorizeByGender(persons: Person[]): { males: Person[]; females: Person[] } {
  return {
    males: persons.filter(p => p.sexe === 'M'),
    females: persons.filter(p => p.sexe === 'F')
  };
}

// Types de résultats pour la recherche directe
export interface DirectRelationshipResults {
  parents: {
    father: Person | null;
    mother: Person | null;
  };
  siblings: {
    brothers: Person[];
    sisters: Person[];
  };
  children: {
    sons: Person[];
    daughters: Person[];
  };
  grandparents: {
    grandfathers: Person[];
    grandmothers: Person[];
  };
  unclesAunts: {
    uncles: Person[];
    aunts: Person[];
  };
  spouses: Person[];
}

// Fonction pour trouver toutes les relations directes
export function findDirectRelationships(personId: string, family: Family): DirectRelationshipResults {
  const parents = findParents(personId, family);
  const parentsByGender = categorizeByGender(parents);
  
  const siblings = findSiblings(personId, family);
  const siblingsByGender = categorizeByGender(siblings);
  
  const children = findChildren(personId, family);
  const childrenByGender = categorizeByGender(children);
  
  const grandparents = findGrandparents(personId, family);
  const grandparentsByGender = categorizeByGender(grandparents);
  
  const unclesAunts = findUnclesAunts(personId, family);
  const unclesAuntsByGender = categorizeByGender(unclesAunts);
  
  const spouses = findSpouses(personId, family);
  
  return {
    parents: {
      father: parentsByGender.males[0] || null,
      mother: parentsByGender.females[0] || null,
    },
    siblings: {
      brothers: siblingsByGender.males,
      sisters: siblingsByGender.females,
    },
    children: {
      sons: childrenByGender.males,
      daughters: childrenByGender.females,
    },
    grandparents: {
      grandfathers: grandparentsByGender.males,
      grandmothers: grandparentsByGender.females,
    },
    unclesAunts: {
      uncles: unclesAuntsByGender.males,
      aunts: unclesAuntsByGender.females,
    },
    spouses: spouses,
  };
}// END OF FILE: src/app/search/utils/relationshipUtils.ts

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/app/tree/page.tsx

// src/app/tree/page.tsx
'use client';

import React, { useEffect, useState, useRef } from 'react';
import { useSearchParams } from 'next/navigation';
import Link from 'next/link';
import { useFamily } from '@/context/FamilyContext';
import { Person } from '@/lib/models/Person';
import { Family } from '@/lib/models/Families';

export default function TreeViewPage() {
  const searchParams = useSearchParams();
  const familyIdParam = searchParams.get('familyId');
  const rootIdParam = searchParams.get('rootId');
  
  const { families, activeFamily, loading } = useFamily();
  const [currentFamily, setCurrentFamily] = useState<Family | null>(null);
  const [rootPerson, setRootPerson] = useState<Person | null>(null);
  const [selectedPerson, setSelectedPerson] = useState<Person | null>(null);
  
  const [zoomLevel, setZoomLevel] = useState(1);
  const svgRef = useRef<SVGSVGElement>(null);
  const [dragState, setDragState] = useState({ isDragging: false, startX: 0, startY: 0 });
  const [viewBox, setViewBox] = useState({ x: 0, y: 0, width: 1000, height: 600 });
  
  const [treeNodes, setTreeNodes] = useState<TreeNode[]>([]);
  const [treeEdges, setTreeEdges] = useState<TreeEdge[]>([]);

  // Déterminer la famille actuelle
  useEffect(() => {
    if (!loading && families.length > 0) {
      let family: Family | null = null;
      
      if (familyIdParam) {
        family = families.find(f => f.id === familyIdParam) || null;
      } else if (activeFamily) {
        family = activeFamily;
      }
      
      setCurrentFamily(family);
    }
  }, [loading, families, activeFamily, familyIdParam]);

  // Déterminer la personne racine
  useEffect(() => {
    if (currentFamily) {
      let root: Person | null = null;
      
      if (rootIdParam) {
        root = currentFamily.persons.find(p => p.id === rootIdParam) || null;
      }
      
      if (!root && currentFamily.persons.length > 0) {
        // Trouver la personne avec le plus de relations
        const personRelationsCount = currentFamily.persons.map(person => {
          const relationsCount = currentFamily.relationships.filter(
            rel => rel.sourceId === person.id || rel.targetId === person.id
          ).length;
          
          return { person, relationsCount };
        });
        
        const mostConnectedPerson = personRelationsCount.reduce((most, current) => 
          current.relationsCount > most.relationsCount ? current : most,
          { person: currentFamily.persons[0], relationsCount: 0 }
        );
        
        root = mostConnectedPerson.person;
      }
      
      setRootPerson(root);
    } else {
      setRootPerson(null);
    }
  }, [currentFamily, rootIdParam]);

  // Générer l'arbre quand la personne racine change
  useEffect(() => {
    if (currentFamily && rootPerson) {
      try {
        const { nodes, edges } = generateTreeLayout(currentFamily, rootPerson.id);
        setTreeNodes(nodes);
        setTreeEdges(edges);
        
        // Réinitialiser la vue
        setViewBox({
          x: -100,
          y: -50,
          width: 1000,
          height: 600
        });
      } catch (error) {
        console.error("Erreur lors de la génération du layout:", error);
      }
    } else {
      setTreeNodes([]);
      setTreeEdges([]);
    }
  }, [currentFamily, rootPerson]);

  // Fonction de zoom
  const handleZoom = (factor: number) => {
    setZoomLevel(prev => {
      const newZoom = prev * factor;
      // Limites de zoom
      return Math.min(Math.max(newZoom, 0.5), 3);
    });
    
    setViewBox(prev => ({
      x: prev.x,
      y: prev.y,
      width: prev.width / factor,
      height: prev.height / factor
    }));
  };

  // Gestionnaires pour le glisser-déposer
  const handleMouseDown = (e: React.MouseEvent) => {
    if (e.button === 0) { // Click gauche
      setDragState({
        isDragging: true,
        startX: e.clientX,
        startY: e.clientY
      });
    }
  };

  const handleMouseMove = (e: React.MouseEvent) => {
    if (dragState.isDragging && svgRef.current) {
      const dx = (e.clientX - dragState.startX) * (viewBox.width / svgRef.current.clientWidth);
      const dy = (e.clientY - dragState.startY) * (viewBox.height / svgRef.current.clientHeight);
      
      setViewBox(prev => ({
        ...prev,
        x: prev.x - dx,
        y: prev.y - dy
      }));
      
      setDragState({
        isDragging: true,
        startX: e.clientX,
        startY: e.clientY
      });
    }
  };

  const handleMouseUp = () => {
    setDragState({ isDragging: false, startX: 0, startY: 0 });
  };

  // Fonction pour sélectionner une personne
  const handleSelectPerson = (person: Person) => {
    setSelectedPerson(prev => prev?.id === person.id ? null : person);
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="text-center">
          <h2 className="text-xl font-semibold mb-2">Chargement des données...</h2>
          <div className="w-12 h-12 border-4 border-t-blue-500 border-b-blue-700 rounded-full animate-spin mx-auto"></div>
        </div>
      </div>
    );
  }

  if (!currentFamily) {
    return (
      <div className="container mx-auto px-4 py-8">
        <div className="bg-white rounded-lg shadow-md p-6 text-center">
          <h2 className="text-xl font-semibold mb-2">Aucun arbre généalogique sélectionné</h2>
          <p className="text-gray-600 mb-6">Veuillez sélectionner un arbre généalogique pour visualiser l'arbre.</p>
          <Link href="/family" className="btn btn-primary">
            Voir mes arbres généalogiques
          </Link>
        </div>
      </div>
    );
  }

  return (
    <div className="container mx-auto px-4 py-8">
      <div className="mb-6">
        <Link href={`/family/${currentFamily.id}`} className="text-blue-600 hover:underline inline-flex items-center">
          <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor">
            <path fillRule="evenodd" d="M9.707 14.707a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 1.414L7.414 9H15a1 1 0 110 2H7.414l2.293 2.293a1 1 0 010 1.414z" clipRule="evenodd" />
          </svg>
          Retour à {currentFamily.name}
        </Link>
      </div>
      
      <div className="mb-6 flex flex-col md:flex-row md:items-center md:justify-between">
        <h1 className="text-3xl font-bold mb-4 md:mb-0">Arbre Généalogique - {currentFamily.name}</h1>
        
        <div className="flex flex-wrap gap-3">
          <button
            onClick={() => handleZoom(1.2)}
            className="btn btn-secondary px-4 py-2"
          >
            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
              <path fillRule="evenodd" d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z" clipRule="evenodd" />
            </svg>
          </button>
          <button
            onClick={() => handleZoom(0.8)}
            className="btn btn-secondary px-4 py-2"
          >
            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
              <path fillRule="evenodd" d="M5 10a1 1 0 011-1h8a1 1 0 110 2H6a1 1 0 01-1-1z" clipRule="evenodd" />
            </svg>
          </button>
          
          {currentFamily.persons.length > 0 && (
            <select
              value={rootPerson?.id || ''}
              onChange={(e) => {
                const newRootId = e.target.value;
                window.location.href = `/tree?familyId=${currentFamily.id}${newRootId ? `&rootId=${newRootId}` : ''}`;
              }}
              className="form-input rounded-md px-4 py-2 border border-gray-300"
            >
              <option value="" disabled>Centrer sur une personne</option>
              {currentFamily.persons.map(person => (
                <option key={person.id} value={person.id}>
                  {person.prenom} {person.nom}
                </option>
              ))}
            </select>
          )}
        </div>
      </div>
      
      <div className="bg-white rounded-lg shadow-md p-4 mb-6 overflow-hidden">
        <div 
          className="w-full h-[600px] border border-gray-200 rounded-lg overflow-hidden"
          style={{ cursor: dragState.isDragging ? 'grabbing' : 'grab' }}
        >
          {treeNodes.length > 0 ? (
            <svg
              ref={svgRef}
              width="100%"
              height="100%"
              viewBox={`${viewBox.x} ${viewBox.y} ${viewBox.width} ${viewBox.height}`}
              onMouseDown={handleMouseDown}
              onMouseMove={handleMouseMove}
              onMouseUp={handleMouseUp}
              onMouseLeave={handleMouseUp}
            >
              {/* Lignes de connexion */}
              {treeEdges.map(edge => {
                const sourceNode = treeNodes.find(n => n.id === edge.source);
                const targetNode = treeNodes.find(n => n.id === edge.target);
                
                if (!sourceNode || !targetNode) return null;
                
                return (
                  <line
                    key={edge.id}
                    x1={sourceNode.x}
                    y1={sourceNode.y}
                    x2={targetNode.x}
                    y2={targetNode.y}
                    stroke={edge.type === 'spouse' ? '#F87171' : '#60A5FA'}
                    strokeWidth="2"
                    strokeDasharray={edge.type === 'spouse' ? "5,5" : ""}
                  />
                );
              })}
              
              {/* Nœuds */}
              {treeNodes.map(node => {
                const isSelected = selectedPerson?.id === node.id;
                const isMale = node.person.sexe === 'M';
                const isFemale = node.person.sexe === 'F';
                
                const rectWidth = 150;
                const rectHeight = 80;
                
                return (
                  <g
                    key={node.id}
                    transform={`translate(${node.x - rectWidth/2}, ${node.y - rectHeight/2})`}
                    onClick={() => handleSelectPerson(node.person)}
                    className="cursor-pointer"
                  >
                    <rect
                      width={rectWidth}
                      height={rectHeight}
                      rx="8"
                      ry="8"
                      fill={isMale ? '#DBEAFE' : isFemale ? '#FCE7F3' : '#F3F4F6'}
                      stroke={isSelected ? '#2563EB' : '#9CA3AF'}
                      strokeWidth={isSelected ? "3" : "1"}
                    />
                    <text
                      x="75"
                      y="30"
                      textAnchor="middle"
                      className="text-sm font-medium"
                      fill="#111827"
                    >
                      {node.person.prenom}
                    </text>
                    <text
                      x="75"
                      y="50"
                      textAnchor="middle"
                      className="text-sm font-medium"
                      fill="#111827"
                    >
                      {node.person.nom}
                    </text>
                    <text
                      x="75"
                      y="70"
                      textAnchor="middle"
                      className="text-xs"
                      fill="#4B5563"
                    >
                      {node.person.birthDate ? new Date(node.person.birthDate).getFullYear() : "?"} - 
                      {node.person.deathDate ? new Date(node.person.deathDate).getFullYear() : node.person.etat === "vivant" ? "présent" : "?"}
                    </text>
                  </g>
                );
              })}
            </svg>
          ) : (
            <div className="flex items-center justify-center h-full">
              <p className="text-gray-500">
                {currentFamily.persons.length === 0 
                  ? "Cet arbre généalogique est vide. Ajoutez des personnes pour commencer."
                  : "Impossible de générer l'arbre. Vérifiez les relations entre les personnes."}
              </p>
            </div>
          )}
        </div>
      </div>
      
      {selectedPerson && (
        <div className="bg-white rounded-lg shadow-md p-6 mb-6">
          <div className="flex justify-between items-start mb-4">
            <h2 className="text-2xl font-semibold">
              {selectedPerson.prenom} {selectedPerson.nom}
            </h2>
            <div className="flex gap-2">
              <Link
                href={`/tree?familyId=${currentFamily.id}&rootId=${selectedPerson.id}`}
                className="btn btn-primary px-4 py-2"
              >
                Centrer l'arbre
              </Link>
              <Link
                href={`/person/${selectedPerson.id}?familyId=${currentFamily.id}`}
                className="btn btn-secondary px-4 py-2"
              >
                Voir profil
              </Link>
            </div>
          </div>
          
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div>
              <h3 className="text-lg font-medium mb-2">Informations</h3>
              <ul className="space-y-2">
                <li><span className="font-medium">Sexe:</span> {selectedPerson.sexe === 'M' ? 'Homme' : selectedPerson.sexe === 'F' ? 'Femme' : 'Autre'}</li>
                <li><span className="font-medium">Naissance:</span> {selectedPerson.birthDate ? new Date(selectedPerson.birthDate).toLocaleDateString() : 'Inconnue'}</li>
                <li><span className="font-medium">Décès:</span> {selectedPerson.deathDate ? new Date(selectedPerson.deathDate).toLocaleDateString() : (selectedPerson.etat === 'vivant' ? 'Vivant' : 'Inconnu')}</li>
              </ul>
            </div>
            
            <div>
              <h3 className="text-lg font-medium mb-2">Relations</h3>
              <ul className="space-y-2">
                {currentFamily.relationships
                  .filter(rel => rel.sourceId === selectedPerson.id || rel.targetId === selectedPerson.id)
                  .map(rel => {
                    const isSource = rel.sourceId === selectedPerson.id;
                    const otherId = isSource ? rel.targetId : rel.sourceId;
                    const otherPerson = currentFamily.persons.find(p => p.id === otherId);
                    
                    if (!otherPerson) return null;
                    
                    let relationLabel = "";
                    if (rel.type === 'conjoint') {
                      relationLabel = rel.sousType === 'marie' ? 'Marié(e) avec' : 'Partenaire de';
                    } else if (rel.type === 'parent' && isSource) {
                      relationLabel = rel.sousType === 'pere' ? 'Père de' : rel.sousType === 'mere' ? 'Mère de' : 'Parent de';
                    } else if (rel.type === 'parent' && !isSource) {
                      relationLabel = otherPerson.sexe === 'M' ? 'Fils de' : otherPerson.sexe === 'F' ? 'Fille de' : 'Enfant de';
                    }
                    
                    return (
                      <li key={rel.id}>
                        <span className="font-medium">{relationLabel}</span>{' '}
                        <button
                          onClick={() => {
                            const person = currentFamily.persons.find(p => p.id === otherId);
                            if (person) setSelectedPerson(person);
                          }}
                          className="text-blue-600 hover:underline"
                        >
                          {otherPerson.prenom} {otherPerson.nom}
                        </button>
                      </li>
                    );
                  })}
              </ul>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

// Types pour l'arbre
interface TreeNode {
  id: string;
  person: Person;
  x: number;
  y: number;
  level: number;
}

interface TreeEdge {
  id: string;
  source: string;
  target: string;
  type: 'parent-child' | 'spouse';
}

// Fonction simplifiée pour générer le layout de l'arbre
function generateTreeLayout(family: Family, rootId: string): { nodes: TreeNode[], edges: TreeEdge[] } {
  const nodes: TreeNode[] = [];
  const edges: TreeEdge[] = [];
  const processed = new Set<string>();
  
  // Trouver la personne racine
  const rootPerson = family.persons.find(p => p.id === rootId);
  if (!rootPerson) {
    throw new Error("Personne racine non trouvée");
  }
  
  // Ajouter la racine au centre
  nodes.push({
    id: rootPerson.id,
    person: rootPerson,
    x: 0,
    y: 0,
    level: 0
  });
  processed.add(rootPerson.id);
  
  // Ajouter les conjoints (à droite)
  const spouseRelations = family.relationships.filter(r => 
    r.type === 'conjoint' && (r.sourceId === rootId || r.targetId === rootId)
  );
  
  let spouseX = 200;
  for (const rel of spouseRelations) {
    const spouseId = rel.sourceId === rootId ? rel.targetId : rel.sourceId;
    const spouse = family.persons.find(p => p.id === spouseId);
    
    if (spouse && !processed.has(spouseId)) {
      nodes.push({
        id: spouseId,
        person: spouse,
        x: spouseX,
        y: 0,
        level: 0
      });
      
      edges.push({
        id: `edge-spouse-${rel.id}`,
        source: rootId,
        target: spouseId,
        type: 'spouse'
      });
      
      processed.add(spouseId);
      spouseX += 200;
    }
  }
  
  // Ajouter les parents (en haut)
  const parentRelations = family.relationships.filter(r => 
    r.type === 'parent' && r.targetId === rootId
  );
  
  let parentX = -200;
  for (const rel of parentRelations) {
    const parentId = rel.sourceId;
    const parent = family.persons.find(p => p.id === parentId);
    
    if (parent && !processed.has(parentId)) {
      nodes.push({
        id: parentId,
        person: parent,
        x: parentX,
        y: -150,
        level: -1
      });
      
      edges.push({
        id: `edge-parent-${rel.id}`,
        source: parentId,
        target: rootId,
        type: 'parent-child'
      });
      
      processed.add(parentId);
      parentX += 200;
    }
  }
  
  // Ajouter les enfants (en bas)
  const childRelations = family.relationships.filter(r => 
    r.type === 'parent' && r.sourceId === rootId
  );
  
  let childCount = childRelations.length;
  let childX = -(childCount * 100) + 100;
  
  for (const rel of childRelations) {
    const childId = rel.targetId;
    const child = family.persons.find(p => p.id === childId);
    
    if (child && !processed.has(childId)) {
      nodes.push({
        id: childId,
        person: child,
        x: childX,
        y: 150,
        level: 1
      });
      
      edges.push({
        id: `edge-child-${rel.id}`,
        source: rootId,
        target: childId,
        type: 'parent-child'
      });
      
      processed.add(childId);
      childX += 200;
    }
  }
  
  return { nodes, edges };
}// END OF FILE: src/app/tree/page.tsx

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/components/auth/LoginForm.tsx

// END OF FILE: src/components/auth/LoginForm.tsx

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/components/auth/RegisterForm.tsx

// END OF FILE: src/components/auth/RegisterForm.tsx

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/components/family/FamilyCard.tsx

// END OF FILE: src/components/family/FamilyCard.tsx

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/components/family/FamilyForm.tsx

// END OF FILE: src/components/family/FamilyForm.tsx

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/components/person/PersonCard.tsx

// END OF FILE: src/components/person/PersonCard.tsx

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/components/person/PersonForm.tsx

// END OF FILE: src/components/person/PersonForm.tsx

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/components/person/RelationshipForm.tsx

// END OF FILE: src/components/person/RelationshipForm.tsx

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/components/tree/TreeContainer.tsx

// END OF FILE: src/components/tree/TreeContainer.tsx

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/components/tree/TreeNodeConnector.tsx

// END OF FILE: src/components/tree/TreeNodeConnector.tsx

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/components/tree/TreeNode.tsx

// END OF FILE: src/components/tree/TreeNode.tsx

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/context/FamilyContext.tsx

// src/context/FamilyContext.tsx
'use client';

import React, { createContext, useContext, useState, useEffect } from 'react';
import { FamilyTreeData } from '../lib/models/FamilyTree';
import { Family, FamiliesData } from '../lib/models/Families';
import { Person } from '../lib/models/Person';
import { Relationship } from '../lib/models/Relationship';
import { initialFamiliesData } from '@/lib/data/initialFamilyTree';


interface FamilyContextType {
  families: Family[];
  activeFamily: Family | null;
  loading: boolean;
  setActiveFamily: (familyId: string) => void;
  addFamily: (family: Family) => Promise<void>;
  updateFamily: (familyId: string, updates: Partial<Family>) => Promise<void>;
  deleteFamily: (familyId: string) => Promise<void>;
  addPerson: (familyId: string, person: Person) => Promise<void>;
  updatePerson: (familyId: string, person: Person) => Promise<void>;
  deletePerson: (familyId: string, personId: string) => Promise<void>;
  addRelationship: (familyId: string, relationship: Relationship) => Promise<void>;
  updateRelationship: (familyId: string, relationship: Relationship) => Promise<void>;
  deleteRelationship: (familyId: string, relationshipId: string) => Promise<void>;
  getAllData: () => FamiliesData;
}

const FamilyContext = createContext<FamilyContextType | undefined>(undefined);

// Fonction pour charger les données depuis le localStorage
const loadFamiliesData = (): FamiliesData => {
  if (typeof window === 'undefined') {
    return initialFamiliesData; // Utiliser les données initiales sur le serveur
  }
  
  const data = localStorage.getItem('familiesData');
  if (!data) {
    return initialFamiliesData; // Utiliser les données initiales si rien n'est stocké
  }
  
  try {
    return JSON.parse(data) as FamiliesData;
  } catch (error) {
    console.error('Error parsing families data:', error);
    return initialFamiliesData; // En cas d'erreur, utiliser les données initiales
  }
};

// Fonction pour sauvegarder les données dans le localStorage
const saveFamiliesData = async (data: FamiliesData): Promise<void> => {
  if (typeof window === 'undefined') return;
  localStorage.setItem('familiesData', JSON.stringify(data));
};

export const FamilyProvider: React.FC<{children: React.ReactNode}> = ({ children }) => {
  const [familiesData, setFamiliesData] = useState<FamiliesData>({ 
    families: [], 
    activeFamilyId: null,
    lastUpdated: new Date().toISOString()
  });
  const [loading, setLoading] = useState(true);
  
  // Charger les données au démarrage
  useEffect(() => {
    const initializeData = async () => {
      try {
        const data = loadFamiliesData();
        setFamiliesData(data);
        
        // Sauvegarder les données initiales si elles n'étaient pas déjà stockées
        if (!localStorage.getItem('familiesData')) {
          await saveFamiliesData(data);
        }
      } catch (error) {
        console.error('Failed to initialize family data:', error);
      } finally {
        setLoading(false);
      }
    };
    
    initializeData();
  }, []);
  
  // Obtenir la famille active
  const activeFamily = familiesData.activeFamilyId
    ? familiesData.families.find(f => f.id === familiesData.activeFamilyId) || null
    : familiesData.families.length > 0 ? familiesData.families[0] : null;
  
  // Définir la famille active
  const setActiveFamily = (familyId: string) => {
    setFamiliesData(prev => ({
      ...prev,
      activeFamilyId: familyId
    }));
    
    saveFamiliesData({
      ...familiesData,
      activeFamilyId: familyId
    });
  };
  
  // Ajouter une nouvelle famille
  const addFamily = async (family: Family) => {
    const newFamiliesData = {
      ...familiesData,
      families: [...familiesData.families, family],
      activeFamilyId: family.id,
      lastUpdated: new Date().toISOString()
    };
    
    await saveFamiliesData(newFamiliesData);
    setFamiliesData(newFamiliesData);
  };
  
  // Mettre à jour une famille existante
  const updateFamily = async (familyId: string, updates: Partial<Family>) => {
    const updatedFamilies = familiesData.families.map(f => 
      f.id === familyId
        ? { ...f, ...updates, updatedAt: new Date().toISOString() }
        : f
    );
    
    const newFamiliesData = {
      ...familiesData,
      families: updatedFamilies,
      lastUpdated: new Date().toISOString()
    };
    
    await saveFamiliesData(newFamiliesData);
    setFamiliesData(newFamiliesData);
  };
  
  // Supprimer une famille
  const deleteFamily = async (familyId: string) => {
    const updatedFamilies = familiesData.families.filter(f => f.id !== familyId);
    
    // Si on supprime la famille active, définir une autre famille comme active
    let newActiveFamilyId = familiesData.activeFamilyId;
    if (familyId === familiesData.activeFamilyId) {
      newActiveFamilyId = updatedFamilies.length > 0 ? updatedFamilies[0].id : null;
    }
    
    const newFamiliesData = {
      ...familiesData,
      families: updatedFamilies,
      activeFamilyId: newActiveFamilyId,
      lastUpdated: new Date().toISOString()
    };
    
    await saveFamiliesData(newFamiliesData);
    setFamiliesData(newFamiliesData);
  };
  
  // Ajouter une personne à une famille
  const addPerson = async (familyId: string, person: Person) => {
    const updatedFamilies = familiesData.families.map(f => 
      f.id === familyId
        ? {
            ...f,
            persons: [...f.persons, person],
            updatedAt: new Date().toISOString()
          }
        : f
    );
    
    const newFamiliesData = {
      ...familiesData,
      families: updatedFamilies,
      lastUpdated: new Date().toISOString()
    };
    
    await saveFamiliesData(newFamiliesData);
    setFamiliesData(newFamiliesData);
  };
  
  // Mettre à jour une personne dans une famille
  const updatePerson = async (familyId: string, person: Person) => {
    const updatedFamilies = familiesData.families.map(f => 
      f.id === familyId
        ? {
            ...f,
            persons: f.persons.map(p => p.id === person.id ? person : p),
            updatedAt: new Date().toISOString()
          }
        : f
    );
    
    const newFamiliesData = {
      ...familiesData,
      families: updatedFamilies,
      lastUpdated: new Date().toISOString()
    };
    
    await saveFamiliesData(newFamiliesData);
    setFamiliesData(newFamiliesData);
  };
  
  // Supprimer une personne d'une famille
  const deletePerson = async (familyId: string, personId: string) => {
    const updatedFamilies = familiesData.families.map(f => 
      f.id === familyId
        ? {
            ...f,
            // Supprimer la personne
            persons: f.persons.filter(p => p.id !== personId),
            // Supprimer les relations associées
            relationships: f.relationships.filter(r => 
              r.sourceId !== personId && r.targetId !== personId
            ),
            updatedAt: new Date().toISOString()
          }
        : f
    );
    
    const newFamiliesData = {
      ...familiesData,
      families: updatedFamilies,
      lastUpdated: new Date().toISOString()
    };
    
    await saveFamiliesData(newFamiliesData);
    setFamiliesData(newFamiliesData);
  };
  
  // Ajouter une relation à une famille
  const addRelationship = async (familyId: string, relationship: Relationship) => {
    const updatedFamilies = familiesData.families.map(f => 
      f.id === familyId
        ? {
            ...f,
            relationships: [...f.relationships, relationship],
            updatedAt: new Date().toISOString()
          }
        : f
    );
    
    const newFamiliesData = {
      ...familiesData,
      families: updatedFamilies,
      lastUpdated: new Date().toISOString()
    };
    
    await saveFamiliesData(newFamiliesData);
    setFamiliesData(newFamiliesData);
  };
  
  // Mettre à jour une relation dans une famille
  const updateRelationship = async (familyId: string, relationship: Relationship) => {
    const updatedFamilies = familiesData.families.map(f => 
      f.id === familyId
        ? {
            ...f,
            relationships: f.relationships.map(r => 
              r.id === relationship.id ? relationship : r
            ),
            updatedAt: new Date().toISOString()
          }
        : f
    );
    
    const newFamiliesData = {
      ...familiesData,
      families: updatedFamilies,
      lastUpdated: new Date().toISOString()
    };
    
    await saveFamiliesData(newFamiliesData);
    setFamiliesData(newFamiliesData);
  };
  
  // Supprimer une relation d'une famille
  const deleteRelationship = async (familyId: string, relationshipId: string) => {
    const updatedFamilies = familiesData.families.map(f => 
      f.id === familyId
        ? {
            ...f,
            relationships: f.relationships.filter(r => r.id !== relationshipId),
            updatedAt: new Date().toISOString()
          }
        : f
    );
    
    const newFamiliesData = {
      ...familiesData,
      families: updatedFamilies,
      lastUpdated: new Date().toISOString()
    };
    
    await saveFamiliesData(newFamiliesData);
    setFamiliesData(newFamiliesData);
  };
  
  // Obtenir toutes les données
  const getAllData = () => familiesData;
  
  return (
    <FamilyContext.Provider
      value={{
        families: familiesData.families,
        activeFamily,
        loading,
        setActiveFamily,
        addFamily,
        updateFamily,
        deleteFamily,
        addPerson,
        updatePerson,
        deletePerson,
        addRelationship,
        updateRelationship,
        deleteRelationship,
        getAllData
      }}
    >
      {children}
    </FamilyContext.Provider>
  );
};

export function useFamily() {
  const context = useContext(FamilyContext);
  if (context === undefined) {
    throw new Error('useFamily must be used within a FamilyProvider');
  }
  return context;
}// END OF FILE: src/context/FamilyContext.tsx

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/lib/algorithms/bellmanFord.ts

// src/lib/algorithms/bellmanFord.ts
import { GraphWeighted, Edge } from '../models/GraphWeighted';

export interface BellmanFordResult {
  distances: Map<string, number>;
  predecessors: Map<string, string | null>;
  hasNegativeCycle: boolean;
  steps: BellmanFordStep[];
  iterationDistances: Map<string, number>[]; // Distances à chaque itération
}

export interface BellmanFordStep {
  iteration: number;
  edge: Edge;
  relaxed: boolean;
  newDistance?: number;
  distanceTable: Map<string, number>;
}

/**
 * Implémente l'algorithme de Bellman-Ford pour trouver les plus courts chemins
 * depuis un nœud source vers tous les autres nœuds du graphe, avec support des poids négatifs.
 * 
 * @param graph Graphe pondéré
 * @param startNodeId ID du nœud source
 * @returns Résultat de l'algorithme (distances, prédécesseurs, présence de cycle négatif)
 */
export function bellmanFord(graph: GraphWeighted, startNodeId: string): BellmanFordResult {
  const distances = new Map<string, number>();
  const predecessors = new Map<string, string | null>();
  const steps: BellmanFordStep[] = [];
  const iterationDistances: Map<string, number>[] = [];
  
  // Initialiser les distances à l'infini et les prédécesseurs à null
  graph.getNodes().forEach(node => {
    distances.set(node.id, node.id === startNodeId ? 0 : Infinity);
    predecessors.set(node.id, null);
  });
  
  const edges = graph.getEdges();
  const nodeCount = graph.getNodes().length;
  
  // Enregistrer les distances initiales
  iterationDistances.push(new Map(distances));
  
  // Phase 1: Relaxer toutes les arêtes |V| - 1 fois
  for (let i = 0; i < nodeCount - 1; i++) {
    let hasRelaxation = false;
    
    // Pour chaque arête
    for (const edge of edges) {
      const sourceDistance = distances.get(edge.source)!;
      
      // Si le nœud source est accessible
      if (sourceDistance !== Infinity) {
        const targetDistance = distances.get(edge.target)!;
        const newDistance = sourceDistance + edge.weight;
        
        // Si on trouve un chemin plus court
        if (newDistance < targetDistance) {
          distances.set(edge.target, newDistance);
          predecessors.set(edge.target, edge.source);
          hasRelaxation = true;
          
          // Enregistrer cette étape
          steps.push({
            iteration: i + 1,
            edge,
            relaxed: true,
            newDistance,
            distanceTable: new Map(distances)
          });
        } else {
          // Aucune relaxation pour cette arête
          steps.push({
            iteration: i + 1,
            edge,
            relaxed: false,
            distanceTable: new Map(distances)
          });
        }
      }
    }
    
    // Enregistrer les distances après cette itération
    iterationDistances.push(new Map(distances));
    
    // Optimisation: si aucune relaxation dans cette itération, on peut s'arrêter
    if (!hasRelaxation) {
      break;
    }
  }
  
  // Phase 2: Vérifier s'il y a un cycle de poids négatif
  let hasNegativeCycle = false;
  
  for (const edge of edges) {
    const sourceDistance = distances.get(edge.source)!;
    
    if (sourceDistance !== Infinity) {
      const targetDistance = distances.get(edge.target)!;
      const newDistance = sourceDistance + edge.weight;
      
      // Si on peut encore relaxer après |V| - 1 itérations, il y a un cycle négatif
      if (newDistance < targetDistance) {
        hasNegativeCycle = true;
        break;
      }
    }
  }
  
  return {
    distances,
    predecessors,
    hasNegativeCycle,
    steps,
    iterationDistances
  };
}

/**
 * Reconstruit le chemin le plus court du nœud source au nœud cible
 * 
 * @param result Résultat de l'algorithme de Bellman-Ford
 * @param targetNodeId ID du nœud cible
 * @returns Chemin (liste ordonnée des IDs de nœuds) ou null si pas de chemin
 */
export function reconstructPath(result: BellmanFordResult, targetNodeId: string): string[] | null {
  // Si le graphe a un cycle négatif, les distances ne sont pas fiables
  if (result.hasNegativeCycle) {
    return null;
  }
  
  const { predecessors, distances } = result;
  
  // Vérifier si le nœud cible est accessible
  if (distances.get(targetNodeId) === Infinity) {
    return null;
  }
  
  const path: string[] = [];
  let currentNode: string | null = targetNodeId;
  const visited = new Set<string>(); // Pour éviter les boucles infinies
  
  // Remonter les prédécesseurs jusqu'à la source
  while (currentNode !== null) {
    // Vérifier si on est dans une boucle
    if (visited.has(currentNode)) {
      return null; // Boucle détectée
    }
    
    visited.add(currentNode);
    path.unshift(currentNode);
    currentNode = predecessors.get(currentNode)!;
  }
  
  return path;
}// END OF FILE: src/lib/algorithms/bellmanFord.ts

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/lib/algorithms/bfsSearchBasic.ts

// src/lib/algorithms/bfsSearchBasic.ts
import { Graph } from '../models/Graph';

export interface BFSOptions {
  startNodeId: string;
  visitCallback?: (nodeId: string, depth: number) => void;
  maxDepth?: number;
}

export interface BFSResult {
  visitedOrder: string[];
  visitedNodes: Set<string>;
  paths: Map<string, string[]>;
  depthMap: Map<string, number>;
}

/**
 * Exécute un parcours en largeur (BFS) sur un graphe
 * @param graph Le graphe à parcourir
 * @param options Options de configuration du BFS
 * @returns Résultat du parcours
 */
export function breadthFirstSearchBasic(graph: Graph, options: BFSOptions): BFSResult {
  const { startNodeId, visitCallback, maxDepth = Infinity } = options;
  
  const visitedOrder: string[] = []; // Ordre de visite des nœuds
  const visitedNodes = new Set<string>(); // Ensemble des nœuds visités
  const queue: { nodeId: string; depth: number; path: string[] }[] = []; // File d'attente
  const paths = new Map<string, string[]>(); // Chemins pour atteindre chaque nœud
  const depthMap = new Map<string, number>(); // Profondeur de chaque nœud
  
  // Initialiser pour le nœud de départ
  visitedNodes.add(startNodeId);
  visitedOrder.push(startNodeId);
  queue.push({ nodeId: startNodeId, depth: 0, path: [startNodeId] });
  paths.set(startNodeId, [startNodeId]);
  depthMap.set(startNodeId, 0);
  
  // Exécuter le callback pour le nœud de départ
  if (visitCallback) {
    visitCallback(startNodeId, 0);
  }
  
  // Parcours BFS
  while (queue.length > 0) {
    const { nodeId, depth, path } = queue.shift()!;
    
    // Ne pas explorer au-delà de la profondeur maximale
    if (depth >= maxDepth) continue;
    
    // Récupérer les voisins du nœud
    const neighbors = graph.getNeighbors(nodeId);
    
    // Explorer les voisins non visités
    for (const neighborId of neighbors) {
      if (!visitedNodes.has(neighborId)) {
        // Marquer comme visité
        visitedNodes.add(neighborId);
        visitedOrder.push(neighborId);
        
        // Mettre à jour le chemin
        const newPath = [...path, neighborId];
        paths.set(neighborId, newPath);
        depthMap.set(neighborId, depth + 1);
        
        // Ajouter à la file d'attente
        queue.push({ nodeId: neighborId, depth: depth + 1, path: newPath });
        
        // Exécuter le callback
        if (visitCallback) {
          visitCallback(neighborId, depth + 1);
        }
      }
    }
  }
  
  return {
    visitedOrder,
    visitedNodes,
    paths,
    depthMap
  };
}

/**
 * Crée une représentation visuelle du parcours BFS sous forme de niveaux
 * Utile pour comprendre la structure en "couches" d'un BFS
 */
export function createBFSLevelVisualization(result: BFSResult): { [level: number]: string[] } {
  const levels: { [level: number]: string[] } = {};
  
  // Regrouper les nœuds par niveau
  Array.from(result.depthMap.entries()).forEach(([nodeId, depth]) => {
    if (!levels[depth]) {
      levels[depth] = [];
    }
    levels[depth].push(nodeId);
  });
  
  return levels;
}// END OF FILE: src/lib/algorithms/bfsSearchBasic.ts

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/lib/algorithms/bfsSearch.ts

// src/lib/algorithms/bfsSearch.ts
import { Person } from '../models/Person';
import { Relationship } from '../models/Relationship';

export interface BFSOptions {
  maxDepth?: number;
  relationTypes?: string[];
  directionFilter?: 'outgoing' | 'incoming' | 'both';
}

export interface BFSResult {
  person: Person;
  distance: number;
  path: Relationship[];
}

export function breadthFirstSearch(
  persons: Map<string, Person>,
  relationships: Relationship[],
  startId: string,
  options: BFSOptions = {}
): Map<string, BFSResult> {
  const { 
    maxDepth = Infinity, 
    relationTypes = [], 
    directionFilter = 'both' 
  } = options;
  
  // Création des index pour les relations
  const relationsBySourceId = new Map<string, Relationship[]>();
  const relationsByTargetId = new Map<string, Relationship[]>();
  
  for (const rel of relationships) {
    // Indexer par source
    if (!relationsBySourceId.has(rel.sourceId)) {
      relationsBySourceId.set(rel.sourceId, []);
    }
    relationsBySourceId.get(rel.sourceId)!.push(rel);
    
    // Indexer par cible
    if (!relationsByTargetId.has(rel.targetId)) {
      relationsByTargetId.set(rel.targetId, []);
    }
    relationsByTargetId.get(rel.targetId)!.push(rel);
  }
  
  // File d'attente BFS
  const queue: {id: string; distance: number; path: Relationship[]}[] = [
    {id: startId, distance: 0, path: []}
  ];
  const visited = new Set<string>([startId]);
  const result = new Map<string, BFSResult>();
  
  while (queue.length > 0) {
    const { id, distance, path } = queue.shift()!;
    const person = persons.get(id);
    
    if (!person) continue;
    
    result.set(id, { person, distance, path });
    
    if (distance >= maxDepth) continue;
    
    // Explorer toutes les relations selon le filtre de direction
    let relationsToExplore: Relationship[] = [];
    
    if (directionFilter === 'outgoing' || directionFilter === 'both') {
      const outgoing = relationsBySourceId.get(id) || [];
      relationsToExplore = relationsToExplore.concat(outgoing);
    }
    
    if (directionFilter === 'incoming' || directionFilter === 'both') {
      const incoming = relationsByTargetId.get(id) || [];
      relationsToExplore = relationsToExplore.concat(incoming);
    }
    
    // Filtrer par type de relation si spécifié
    if (relationTypes.length > 0) {
      relationsToExplore = relationsToExplore.filter(rel => 
        relationTypes.includes(rel.type)
      );
    }
    
    // Parcourir les relations
    for (const relation of relationsToExplore) {
      const nextId = relation.sourceId === id ? relation.targetId : relation.sourceId;
      
      if (!visited.has(nextId)) {
        visited.add(nextId);
        const newPath = [...path, relation];
        queue.push({
          id: nextId,
          distance: distance + 1,
          path: newPath
        });
      }
    }
  }
  
  return result;
}// END OF FILE: src/lib/algorithms/bfsSearch.ts

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/lib/algorithms/dfsSearch.ts

// src/lib/algorithms/dfsSearch.ts
import { Graph } from '../models/Graph';

export interface DFSOptions {
  startNodeId: string;
  visitCallback?: (nodeId: string, depth: number) => void;
  maxDepth?: number;
}

export interface DFSResult {
  visitedOrder: string[];
  visitedNodes: Set<string>;
  paths: Map<string, string[]>;
  depthMap: Map<string, number>;
}

/**
 * Exécute un parcours en profondeur (DFS) sur un graphe
 * @param graph Le graphe à parcourir
 * @param options Options de configuration du DFS
 * @returns Résultat du parcours
 */
export function depthFirstSearch(graph: Graph, options: DFSOptions): DFSResult {
  const { startNodeId, visitCallback, maxDepth = Infinity } = options;
  
  const visitedOrder: string[] = []; // Ordre de visite des nœuds
  const visitedNodes = new Set<string>(); // Ensemble des nœuds visités
  const paths = new Map<string, string[]>(); // Chemins pour atteindre chaque nœud
  const depthMap = new Map<string, number>(); // Profondeur de chaque nœud

  // Initialiser le chemin pour le nœud de départ
  paths.set(startNodeId, [startNodeId]);
  depthMap.set(startNodeId, 0);

  // Version itérative du DFS (avec pile explicite)
  function dfsIterative() {
    const stack: { nodeId: string; depth: number }[] = [{ nodeId: startNodeId, depth: 0 }];
    
    while (stack.length > 0) {
      const { nodeId, depth } = stack.pop()!;
      
      // Si le nœud a déjà été visité ou si on dépasse la profondeur maximale, passer au suivant
      if (visitedNodes.has(nodeId) || depth > maxDepth) continue;
      
      // Marquer le nœud comme visité
      visitedNodes.add(nodeId);
      visitedOrder.push(nodeId);
      
      // Exécuter le callback s'il existe
      if (visitCallback) {
        visitCallback(nodeId, depth);
      }
      
      // Récupérer les voisins du nœud et les ajouter à la pile dans l'ordre inverse
      // pour maintenir l'ordre de visite naturel
      const neighbors = [...graph.getNeighbors(nodeId)].reverse();
      
      for (const neighborId of neighbors) {
        if (!visitedNodes.has(neighborId)) {
          stack.push({ nodeId: neighborId, depth: depth + 1 });
          
          // Mettre à jour le chemin pour atteindre ce voisin si pas déjà défini
          if (!paths.has(neighborId)) {
            const currentPath = paths.get(nodeId) || [];
            paths.set(neighborId, [...currentPath, neighborId]);
            depthMap.set(neighborId, depth + 1);
          }
        }
      }
    }
  }
  
  // Fonction récursive pour le DFS (alternative)
  function dfsRecursive(nodeId: string, depth: number) {
    // Vérifier la profondeur maximale
    if (depth > maxDepth) return;
    
    // Marquer le nœud comme visité
    visitedNodes.add(nodeId);
    visitedOrder.push(nodeId);
    
    // Exécuter le callback s'il existe
    if (visitCallback) {
      visitCallback(nodeId, depth);
    }
    
    // Récupérer les voisins du nœud
    const neighbors = graph.getNeighbors(nodeId);
    
    // Explorer les voisins non visités
    for (const neighborId of neighbors) {
      if (!visitedNodes.has(neighborId)) {
        // Mettre à jour le chemin pour atteindre ce voisin
        const currentPath = paths.get(nodeId) || [];
        paths.set(neighborId, [...currentPath, neighborId]);
        depthMap.set(neighborId, depth + 1);
        
        // Explorer récursivement
        dfsRecursive(neighborId, depth + 1);
      }
    }
  }
  
  // Démarrer le parcours (version itérative par défaut)
  dfsIterative();
  // Alternativement, on pourrait utiliser la version récursive:
  // dfsRecursive(startNodeId, 0);
  
  return {
    visitedOrder,
    visitedNodes,
    paths,
    depthMap
  };
}// END OF FILE: src/lib/algorithms/dfsSearch.ts

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/lib/algorithms/dijkstra.ts

// src/lib/algorithms/dijkstra.ts
import { GraphWeighted, Node } from '../models/GraphWeighted';

export interface DijkstraResult {
  distances: Map<string, number>;
  predecessors: Map<string, string | null>;
  visitedOrder: string[];
  steps: DijkstraStep[];
}

export interface DijkstraStep {
  currentNode: string;
  currentDistance: number;
  distanceTable: Map<string, number>;
  relaxedEdges: { source: string; target: string; newDistance: number }[];
}

/**
 * Implémente l'algorithme de Dijkstra pour trouver les plus courts chemins
 * depuis un nœud source vers tous les autres nœuds du graphe.
 * 
 * @param graph Graphe pondéré
 * @param startNodeId ID du nœud source
 * @returns Résultat de l'algorithme (distances, prédécesseurs, ordre de visite)
 */
export function dijkstra(graph: GraphWeighted, startNodeId: string): DijkstraResult {
  // Vérifier que le graphe ne contient pas de poids négatifs
  if (!graph.isDijkstraCompatible()) {
    throw new Error("L'algorithme de Dijkstra ne fonctionne pas avec des poids négatifs");
  }
  
  const distances = new Map<string, number>();
  const predecessors = new Map<string, string | null>();
  const visited = new Set<string>();
  const visitedOrder: string[] = [];
  const steps: DijkstraStep[] = [];
  
  // Initialiser les distances à l'infini et les prédécesseurs à null
  graph.getNodes().forEach(node => {
    distances.set(node.id, node.id === startNodeId ? 0 : Infinity);
    predecessors.set(node.id, null);
  });
  
  // Tant qu'il reste des nœuds non visités
  while (visited.size < graph.getNodes().length) {
    // Trouver le nœud non visité avec la distance minimale
    let currentNode: string | null = null;
    let minDistance = Infinity;
    
    distances.forEach((distance, nodeId) => {
      if (!visited.has(nodeId) && distance < minDistance) {
        currentNode = nodeId;
        minDistance = distance;
      }
    });
    
    // Si tous les nœuds restants sont inaccessibles, on arrête
    if (currentNode === null || minDistance === Infinity) {
      break;
    }
    
    // Marquer le nœud comme visité
    visited.add(currentNode);
    visitedOrder.push(currentNode);
    
    // Récupérer les voisins du nœud courant avec leurs poids
    const neighbors = graph.getNeighborsWithWeights(currentNode);
    const relaxedEdges: { source: string; target: string; newDistance: number }[] = [];
    
    // Pour chaque voisin, mettre à jour la distance si on trouve un chemin plus court
    neighbors.forEach((weight, neighborId) => {
      if (!visited.has(neighborId)) {
        const newDistance = distances.get(currentNode!)! + weight;
        
        if (newDistance < distances.get(neighborId)!) {
          distances.set(neighborId, newDistance);
          predecessors.set(neighborId, currentNode);
          relaxedEdges.push({
            source: currentNode!,
            target: neighborId,
            newDistance
          });
        }
      }
    });
    
    // Enregistrer cette étape
    steps.push({
      currentNode,
      currentDistance: distances.get(currentNode)!,
      distanceTable: new Map(distances),
      relaxedEdges
    });
  }
  
  return {
    distances,
    predecessors,
    visitedOrder,
    steps
  };
}

/**
 * Reconstruit le chemin le plus court du nœud source au nœud cible
 * 
 * @param result Résultat de l'algorithme de Dijkstra
 * @param targetNodeId ID du nœud cible
 * @returns Chemin (liste ordonnée des IDs de nœuds) ou null si pas de chemin
 */
export function reconstructPath(result: DijkstraResult, targetNodeId: string): string[] | null {
  const { predecessors, distances } = result;
  
  // Vérifier si le nœud cible est accessible
  if (distances.get(targetNodeId) === Infinity) {
    return null;
  }
  
  const path: string[] = [];
  let currentNode: string | null = targetNodeId;
  
  // Remonter les prédécesseurs jusqu'à la source
  while (currentNode !== null) {
    path.unshift(currentNode);
    currentNode = predecessors.get(currentNode)!;
  }
  
  return path;
}// END OF FILE: src/lib/algorithms/dijkstra.ts

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/lib/algorithms/graphService.ts

// src/lib/services/graphService.ts
import { Person } from '../models/Person';
import { Relationship } from '../models/Relationship';
import { FamilyTreeData } from '../models/FamilyTree';
import { breadthFirstSearch } from '../algorithms/bfsSearch';
import { findRelationshipPath } from '../algorithms/pathFinding';
import { validateFamilyTree } from '../algorithms/validation';
import { generateTreeLayout } from '../algorithms/treeLayout';

export class GraphService {
  private persons: Map<string, Person> = new Map();
  private relationships: Relationship[] = [];
  private relationshipsBySourceId: Map<string, Relationship[]> = new Map();
  private relationshipsByTargetId: Map<string, Relationship[]> = new Map();
  
  constructor() {}
  
  // Chargement des données
  loadData(data: FamilyTreeData): void {
    this.clear();
    
    // Charger les personnes
    data.persons.forEach(person => {
      this.persons.set(person.id, { ...person });
    });
    
    // Charger les relations
    data.relationships.forEach(relation => {
      this.addRelationshipToIndex(relation);
    });
  }
  
  // Réinitialiser
  clear(): void {
    this.persons.clear();
    this.relationships = [];
    this.relationshipsBySourceId.clear();
    this.relationshipsByTargetId.clear();
  }
  
  // Méthodes d'accès aux données
  getAllPersons(): Person[] {
    return Array.from(this.persons.values());
  }
  
  getAllPersonIds(): string[] {
    return Array.from(this.persons.keys());
  }
  
  getPersonById(id: string): Person | undefined {
    return this.persons.get(id);
  }
  
  getAllRelationships(): Relationship[] {
    return this.relationships;
  }
  
  getRelationshipsBySourceId(id: string): Relationship[] {
    return this.relationshipsBySourceId.get(id) || [];
  }
  
  getRelationshipsByTargetId(id: string): Relationship[] {
    return this.relationshipsByTargetId.get(id) || [];
  }
  
  // Méthodes de manipulation
  addPerson(person: Person): void {
    this.persons.set(person.id, { ...person });
  }
  
  updatePerson(person: Person): void {
    if (this.persons.has(person.id)) {
      this.persons.set(person.id, { ...person });
    }
  }
  
  deletePerson(id: string): void {
    // Supprimer la personne
    this.persons.delete(id);
    
    // Supprimer les relations associées
    const relationsToRemove = [
      ...this.getRelationshipsBySourceId(id),
      ...this.getRelationshipsByTargetId(id)
    ];
    
    for (const relation of relationsToRemove) {
      this.deleteRelationship(relation.id);
    }
  }
  
  addRelationship(relationship: Relationship): void {
    this.addRelationshipToIndex(relationship);
  }
  
  updateRelationship(relationship: Relationship): void {
    // Trouver et supprimer l'ancienne relation
    const index = this.relationships.findIndex(r => r.id === relationship.id);
    if (index !== -1) {
      const oldRelationship = this.relationships[index];
      
      // Supprimer des index
      this.removeRelationshipFromIndex(oldRelationship);
      
      // Mettre à jour
      this.relationships[index] = { ...relationship };
      
      // Ajouter aux index
      this.addRelationshipToIndex(relationship);
    }
  }
  
  deleteRelationship(id: string): void {
    const index = this.relationships.findIndex(r => r.id === id);
    if (index !== -1) {
      const relationship = this.relationships[index];
      
      // Supprimer des index
      this.removeRelationshipFromIndex(relationship);
      
      // Supprimer de la liste
      this.relationships.splice(index, 1);
    }
  }
  
  // Algorithmes
  findRelatives(personId: string, relationType?: string, maxDepth: number = 2) {
    return breadthFirstSearch(
      this.persons,
      this.relationships,
      personId,
      { 
        maxDepth,
        relationTypes: relationType ? [relationType] : undefined 
      }
    );
  }
  
  findRelationshipPath(person1Id: string, person2Id: string) {
    return findRelationshipPath(
      this.persons,
      this.relationships,
      person1Id,
      person2Id
    );
  }
  
  validateFamilyTree() {
    return validateFamilyTree(
      this.getAllPersons(),
      this.relationships
    );
  }
  
  generateTreeLayout(rootPersonId: string, options?: any) {
    return generateTreeLayout(
      this.getAllPersons(),
      this.relationships,
      rootPersonId,
      options
    );
  }
  
  // Méthodes auxiliaires privées
  private addRelationshipToIndex(relationship: Relationship): void {
    // Ajouter à la liste principale
    this.relationships.push({ ...relationship });
    
    // Indexer par source
    if (!this.relationshipsBySourceId.has(relationship.sourceId)) {
      this.relationshipsBySourceId.set(relationship.sourceId, []);
    }
    this.relationshipsBySourceId.get(relationship.sourceId)!.push(relationship);
    
    // Indexer par cible
    if (!this.relationshipsByTargetId.has(relationship.targetId)) {
      this.relationshipsByTargetId.set(relationship.targetId, []);
    }
    this.relationshipsByTargetId.get(relationship.targetId)!.push(relationship);
  }
  
  private removeRelationshipFromIndex(relationship: Relationship): void {
    // Supprimer de l'index source
    const sourceRelations = this.relationshipsBySourceId.get(relationship.sourceId);
    if (sourceRelations) {
      const sourceIndex = sourceRelations.findIndex(r => r.id === relationship.id);
      if (sourceIndex !== -1) {
        sourceRelations.splice(sourceIndex, 1);
      }
    }
    
    // Supprimer de l'index cible
    const targetRelations = this.relationshipsByTargetId.get(relationship.targetId);
    if (targetRelations) {
      const targetIndex = targetRelations.findIndex(r => r.id === relationship.id);
      if (targetIndex !== -1) {
        targetRelations.splice(targetIndex, 1);
      }
    }
  }
  
  // Conversion format
  toFamilyTreeData(): FamilyTreeData {
    return {
      persons: this.getAllPersons(),
      relationships: [...this.relationships],
      metadata: {
        nom: "Arbre généalogique",
        dateCreation: new Date().toISOString(),
        dateMiseAJour: new Date().toISOString()
      }
    };
  }
}

// Exporter une instance singleton
export const graphService = new GraphService();// END OF FILE: src/lib/algorithms/graphService.ts

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/lib/algorithms/kruskal.ts

// src/lib/algorithms/kruskal.ts
import { GraphWeighted, Edge } from '../models/GraphWeighted';

export interface KruskalResult {
  minimumSpanningTree: Edge[];
  totalWeight: number;
  steps: KruskalStep[];
}

export interface KruskalStep {
  edge: Edge;
  accepted: boolean;
  reason: string;
  currentForest: { [nodeId: string]: string }; // Représentation de la forêt
  mstEdges: Edge[]; // Arêtes de l'ACM à cette étape
}

/**
 * Implémente l'algorithme de Kruskal pour trouver l'arbre couvrant minimal d'un graphe
 * 
 * @param graph Graphe pondéré
 * @returns Résultat contenant l'arbre couvrant minimal, son poids total et les étapes
 */
export function kruskal(graph: GraphWeighted): KruskalResult {
  // Ne fonctionne que sur des graphes non dirigés
  if (graph.directed) {
    throw new Error("L'algorithme de Kruskal nécessite un graphe non dirigé");
  }
  
  const nodes = graph.getNodes();
  const edges = [...graph.getEdges()]; // Copie pour pouvoir trier
  const minimumSpanningTree: Edge[] = [];
  const steps: KruskalStep[] = [];
  
  // Trier les arêtes par poids croissant
  edges.sort((a, b) => a.weight - b.weight);
  
  // Initialiser la structure Union-Find (chaque nœud est dans son propre ensemble)
  const forest: { [nodeId: string]: string } = {};
  nodes.forEach(node => {
    forest[node.id] = node.id;
  });
  
  // Fonction pour trouver la racine d'un nœud dans la forêt
  const findRoot = (nodeId: string): string => {
    if (forest[nodeId] !== nodeId) {
      // Compression de chemin
      forest[nodeId] = findRoot(forest[nodeId]);
    }
    return forest[nodeId];
  };
  
  // Fonction pour unir deux ensembles
  const union = (nodeId1: string, nodeId2: string): void => {
    const root1 = findRoot(nodeId1);
    const root2 = findRoot(nodeId2);
    forest[root2] = root1;
  };
  
  // Parcourir toutes les arêtes triées
  for (const edge of edges) {
    const sourceRoot = findRoot(edge.source);
    const targetRoot = findRoot(edge.target);
    
    // Si les nœuds ne sont pas déjà dans le même ensemble (évite les cycles)
    if (sourceRoot !== targetRoot) {
      // Ajouter l'arête à l'ACM
      minimumSpanningTree.push(edge);
      
      // Unir les deux ensembles
      union(edge.source, edge.target);
      
      // Enregistrer cette étape comme acceptée
      steps.push({
        edge,
        accepted: true,
        reason: `Les nœuds ${edge.source} et ${edge.target} sont dans des composantes différentes`,
        currentForest: { ...forest },
        mstEdges: [...minimumSpanningTree]
      });
      
      // Arrêter si on a |V| - 1 arêtes (ACM complet)
      if (minimumSpanningTree.length === nodes.length - 1) {
        break;
      }
    } else {
      // Enregistrer cette étape comme rejetée (créerait un cycle)
      steps.push({
        edge,
        accepted: false,
        reason: `Les nœuds ${edge.source} et ${edge.target} sont déjà dans la même composante`,
        currentForest: { ...forest },
        mstEdges: [...minimumSpanningTree]
      });
    }
  }
  
  // Calculer le poids total de l'ACM
  const totalWeight = minimumSpanningTree.reduce((sum, edge) => sum + edge.weight, 0);
  
  return {
    minimumSpanningTree,
    totalWeight,
    steps
  };
}

/**
 * Vérifie si l'arbre couvrant minimal est complet (couvre tous les nœuds)
 * 
 * @param result Résultat de l'algorithme de Kruskal
 * @param graph Graphe original
 * @returns True si l'ACM est complet, false sinon
 */
export function isCompleteSpanningTree(result: KruskalResult, graph: GraphWeighted): boolean {
  const nodeCount = graph.getNodes().length;
  return result.minimumSpanningTree.length === nodeCount - 1;
}// END OF FILE: src/lib/algorithms/kruskal.ts

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/lib/algorithms/pathFinding.ts

// src/lib/algorithms/pathFinding.ts
import { Person } from '../models/Person';
import { Relationship } from '../models/Relationship';
import { breadthFirstSearch, BFSResult } from './bfsSearch';

export interface RelationshipPath {
  path: Relationship[];
  description: string;
  degree: number;
}

export function findRelationshipPath(
  persons: Map<string, Person>,
  relationships: Relationship[],
  person1Id: string,
  person2Id: string
): RelationshipPath | null {
  // Utiliser BFS bidirectionnel pour optimiser la recherche
  const forwardResults = breadthFirstSearch(persons, relationships, person1Id);
  
  // Si on a trouvé directement le chemin vers person2
  if (forwardResults.has(person2Id)) {
    const result = forwardResults.get(person2Id)!;
    return {
      path: result.path,
      description: describeRelationship(persons, result.path, person1Id, person2Id),
      degree: calculateRelationshipDegree(result.path)
    };
  }
  
  // Si on n'a pas trouvé de chemin direct, on pourrait implémenter
  // un algorithme plus complexe ici pour les relations indirectes
  
  return null;
}

export function describeRelationship(
  persons: Map<string, Person>,
  path: Relationship[],
  startId: string,
  endId: string
): string {
  if (path.length === 0) return "Même personne";
  
  // Déterminer le type de relation en fonction du chemin
  if (path.length === 1) {
    const rel = path[0];
    if (rel.type === "conjoint") {
      return rel.sousType === "marie" ? "Conjoint(e)" : "Partenaire";
    }
    if (rel.type === "parent" && rel.sourceId === startId) {
      return rel.sousType === "pere" ? "Père" : rel.sousType === "mere" ? "Mère" : "Parent";
    }
    if (rel.type === "parent" && rel.targetId === startId) {
      return rel.sousType === "pere" ? "Fils" : rel.sousType === "mere" ? "Fille" : "Enfant";
    }
    // Autres cas simples
  }
  
  // Frère/Soeur (même parents)
  if (path.length === 2 && 
      path[0].type === "parent" && path[1].type === "parent" &&
      path[0].sourceId === path[1].sourceId) {
    const siblingPerson = persons.get(endId);
    if (siblingPerson) {
      return siblingPerson.sexe === "M" ? "Frère" : "Sœur";
    }
    return "Frère/Sœur";
  }
  
  // Grand-parent / Petit-enfant
  if (path.length === 2 && 
      path[0].type === "parent" && path[1].type === "parent") {
    if (path[0].targetId === startId) {
      return "Grand-parent";
    } else {
      return "Petit-enfant";
    }
  }
  
  // Oncle/Tante - Neveu/Nièce
  if (path.length === 3 && 
      path[0].type === "parent" && path[1].type === "parent" && path[2].type === "parent") {
    // Logique pour déterminer oncle/tante ou neveu/nièce
  }
  
  // Cousin
  if (path.length === 4 && 
      path[0].type === "parent" && path[1].type === "parent" && 
      path[2].type === "parent" && path[3].type === "parent") {
    return "Cousin(e)";
  }
  
  // Si la relation est trop complexe ou inconnue
  return `Relation de degré ${calculateRelationshipDegree(path)}`;
}

export function calculateRelationshipDegree(path: Relationship[]): number {
  // Formule canonique pour le calcul du degré de parenté
  // Dans le système civil : somme des distances aux ancêtres communs
  return path.length;
}// END OF FILE: src/lib/algorithms/pathFinding.ts

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/lib/algorithms/prim.ts

// src/lib/algorithms/prim.ts
import { GraphWeighted, Edge } from '../models/GraphWeighted';

export interface PrimResult {
  minimumSpanningTree: Edge[];
  totalWeight: number;
  steps: PrimStep[];
}

export interface PrimStep {
  currentNode: string;
  addedEdge: Edge | null;
  candidateEdges: Edge[];
  nodeStatus: Map<string, boolean>; // true = dans l'arbre, false = hors de l'arbre
  mstEdges: Edge[]; // Arêtes de l'ACM à cette étape
}

/**
 * Implémente l'algorithme de Prim pour trouver l'arbre couvrant minimal d'un graphe
 * 
 * @param graph Graphe pondéré
 * @param startNodeId ID du nœud de départ (optionnel)
 * @returns Résultat contenant l'arbre couvrant minimal, son poids total et les étapes
 */
export function prim(graph: GraphWeighted, startNodeId?: string): PrimResult {
  // Ne fonctionne que sur des graphes non dirigés
  if (graph.directed) {
    throw new Error("L'algorithme de Prim nécessite un graphe non dirigé");
  }
  
  const nodes = graph.getNodes();
  
  // Si aucun nœud de départ n'est spécifié, prendre le premier
  if (!startNodeId && nodes.length > 0) {
    startNodeId = nodes[0].id;
  }
  
  if (!startNodeId) {
    throw new Error("Graphe vide ou nœud de départ invalide");
  }
  
  const minimumSpanningTree: Edge[] = [];
  const steps: PrimStep[] = [];
  
  // Ensemble des nœuds déjà inclus dans l'ACM
  const inTree = new Set<string>([startNodeId]);
  
  // File de priorité pour les arêtes candidates (implémentation simple)
  let candidateEdges: Edge[] = [];
  
  // Fonction pour mettre à jour les arêtes candidates
  const updateCandidateEdges = (nodeId: string) => {
    // Parcourir tous les voisins du nœud
    const neighbors = graph.getNeighborsWithWeights(nodeId);
    
    neighbors.forEach((weight, neighborId) => {
      // Si le voisin n'est pas déjà dans l'arbre
      if (!inTree.has(neighborId)) {
        // Ajouter l'arête aux candidates
        candidateEdges.push({
          source: nodeId,
          target: neighborId,
          weight
        });
      }
    });
    
    // Trier les arêtes candidates par poids croissant
    candidateEdges.sort((a, b) => a.weight - b.weight);
  };
  
  // Commencer avec le nœud de départ
  let currentNode = startNodeId;
  updateCandidateEdges(currentNode);
  
  // Enregistrer l'étape initiale
  steps.push({
    currentNode,
    addedEdge: null,
    candidateEdges: [...candidateEdges],
    nodeStatus: new Map(nodes.map(node => [node.id, inTree.has(node.id)])),
    mstEdges: []
  });
  
  // Continuer jusqu'à ce que tous les nœuds soient dans l'arbre ou qu'il n'y ait plus d'arêtes candidates
  while (inTree.size < nodes.length && candidateEdges.length > 0) {
    // Prendre l'arête de poids minimal
    let minEdge: Edge | undefined;
    
    // Trouver l'arête valide de poids minimal (qui ne crée pas de cycle)
    while (candidateEdges.length > 0) {
      const edge = candidateEdges.shift()!;
      
      // Vérifier si l'arête connecte un nœud de l'arbre à un nœud hors de l'arbre
      if (inTree.has(edge.source) && !inTree.has(edge.target)) {
        minEdge = edge;
        break;
      } else if (inTree.has(edge.target) && !inTree.has(edge.source)) {
        // Inverser l'arête si nécessaire
        minEdge = {
          source: edge.target,
          target: edge.source,
          weight: edge.weight
        };
        break;
      }
      // Sinon, l'arête est invalide (crée un cycle ou est obsolète), on continue
    }
    
    // Si aucune arête valide n'a été trouvée, on arrête
    if (!minEdge) {
      break;
    }
    
    // Ajouter l'arête à l'ACM
    minimumSpanningTree.push(minEdge);
    
    // Ajouter le nouveau nœud à l'ensemble des nœuds de l'arbre
    inTree.add(minEdge.target);
    
    // Mettre à jour les arêtes candidates avec ce nouveau nœud
    updateCandidateEdges(minEdge.target);
    
    // Enregistrer cette étape
    steps.push({
      currentNode: minEdge.target,
      addedEdge: minEdge,
      candidateEdges: [...candidateEdges],
      nodeStatus: new Map(nodes.map(node => [node.id, inTree.has(node.id)])),
      mstEdges: [...minimumSpanningTree]
    });
  }
  
  // Calculer le poids total de l'ACM
  const totalWeight = minimumSpanningTree.reduce((sum, edge) => sum + edge.weight, 0);
  
  return {
    minimumSpanningTree,
    totalWeight,
    steps
  };
}

/**
 * Vérifie si l'arbre couvrant minimal est complet (couvre tous les nœuds)
 * 
 * @param result Résultat de l'algorithme de Prim
 * @param graph Graphe original
 * @returns True si l'ACM est complet, false sinon
 */
export function isCompleteSpanningTree(result: PrimResult, graph: GraphWeighted): boolean {
  const nodeCount = graph.getNodes().length;
  return result.minimumSpanningTree.length === nodeCount - 1;
}// END OF FILE: src/lib/algorithms/prim.ts

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/lib/algorithms/treeLayout.ts

// src/lib/algorithms/treeLayout.ts
import { Person } from '../models/Person';
import { Relationship } from '../models/Relationship';

export interface TreeNode {
  id: string;
  person: Person;
  x: number;
  y: number;
  level: number;
  spouseNodes: TreeNode[];
  childrenNodes: TreeNode[];
  parentNodes: TreeNode[];
}

export interface TreeEdge {
  id: string;
  source: string;
  target: string;
  type: 'parent-child' | 'spouse';
  relationship: Relationship;
}

export interface TreeLayout {
  nodes: TreeNode[];
  edges: TreeEdge[];
  width: number;
  height: number;
}

export function generateTreeLayout(
  persons: Person[],
  relationships: Relationship[],
  rootPersonId: string,
  options = { 
    horizontal: true, 
    levelDistance: 100, 
    nodeDistance: 60 
  }
): TreeLayout {
  // Convertir les personnes en Map pour accès rapide
  const personsMap = new Map(persons.map(p => [p.id, p]));
  
  // Créer des index pour les relations
  const relationsByType = new Map<string, Relationship[]>();
  relationships.forEach(rel => {
    if (!relationsByType.has(rel.type)) {
      relationsByType.set(rel.type, []);
    }
    relationsByType.get(rel.type)!.push(rel);
  });
  
  // Fonction pour trouver les relations d'une personne par type
  function getRelationsForPerson(personId: string, type: string, asSource: boolean = true): Relationship[] {
    const relations = relationsByType.get(type) || [];
    return relations.filter(rel => 
      asSource ? rel.sourceId === personId : rel.targetId === personId
    );
  }
  
  // Construire l'arbre à partir de la personne racine
  const builtNodes = new Map<string, TreeNode>();
  const edges: TreeEdge[] = [];
  
  function buildTree(personId: string, level: number, x: number): TreeNode {
    // Éviter les cycles
    if (builtNodes.has(personId)) {
      return builtNodes.get(personId)!;
    }
    
    const person = personsMap.get(personId);
    if (!person) {
      throw new Error(`Person with ID ${personId} not found`);
    }
    
    // Créer le nœud
    const node: TreeNode = {
      id: personId,
      person,
      x,
      y: level * options.levelDistance,
      level,
      spouseNodes: [],
      childrenNodes: [],
      parentNodes: []
    };
    
    builtNodes.set(personId, node);
    
    // Ajouter les conjoints
    const spouseRelations = getRelationsForPerson(personId, 'conjoint');
    let spouseX = x + options.nodeDistance;
    
    for (const spouseRel of spouseRelations) {
      const spouseId = spouseRel.targetId === personId ? spouseRel.sourceId : spouseRel.targetId;
      if (!builtNodes.has(spouseId)) {
        const spouseNode = buildTree(spouseId, level, spouseX);
        node.spouseNodes.push(spouseNode);
        
        // Ajouter la relation conjoint
        edges.push({
          id: `edge-spouse-${spouseRel.id}`,
          source: personId,
          target: spouseId,
          type: 'spouse',
          relationship: spouseRel
        });
        
        spouseX += options.nodeDistance;
      }
    }
    
    // Ajouter les enfants
    const childRelations = getRelationsForPerson(personId, 'parent', true);
    
    if (childRelations.length > 0) {
      // Calculer la position x des enfants
      const childLevel = level + 1;
      const childrenWidth = childRelations.length * options.nodeDistance;
      const childrenStartX = x - (childrenWidth / 2);
      
      for (let i = 0; i < childRelations.length; i++) {
        const childRel = childRelations[i];
        const childId = childRel.targetId;
        
        if (!builtNodes.has(childId)) {
          const childX = childrenStartX + (i * options.nodeDistance);
          const childNode = buildTree(childId, childLevel, childX);
          node.childrenNodes.push(childNode);
          
          // Ajouter la relation parent-enfant
          edges.push({
            id: `edge-parent-${childRel.id}`,
            source: personId,
            target: childId,
            type: 'parent-child',
            relationship: childRel
          });
        }
      }
    }
    
    // Ajouter les parents
    const parentRelations = getRelationsForPerson(personId, 'parent', false);
    
    if (parentRelations.length > 0) {
      const parentLevel = level - 1;
      
      for (const parentRel of parentRelations) {
        const parentId = parentRel.sourceId;
        
        if (!builtNodes.has(parentId)) {
          const parentNode = buildTree(parentId, parentLevel, x - options.nodeDistance);
          node.parentNodes.push(parentNode);
          
          // La relation est déjà ajoutée dans la boucle des enfants
        }
      }
    }
    
    return node;
  }
  
  // Commencer la construction depuis la racine
  ///////////////////////const rootNode = buildTree(rootPersonId, 0, 0);
  
  // Ajuster les positions pour éviter les chevauchements (algorithme simplifié)
  // Un algorithme plus complexe serait nécessaire pour une disposition optimale
  
  // Calculer les dimensions totales
  let minX = Infinity;
  let maxX = -Infinity;
  let minY = Infinity;
  let maxY = -Infinity;
  
  for (const node of builtNodes.values()) {
    minX = Math.min(minX, node.x);
    maxX = Math.max(maxX, node.x);
    minY = Math.min(minY, node.y);
    maxY = Math.max(maxY, node.y);
  }
  
  return {
    nodes: Array.from(builtNodes.values()),
    edges,
    width: maxX - minX + options.nodeDistance,
    height: maxY - minY + options.levelDistance
  };
}// END OF FILE: src/lib/algorithms/treeLayout.ts

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/lib/algorithms/validation.ts

// src/lib/algorithms/validation.ts
import { Person } from '../models/Person';
import { Relationship } from '../models/Relationship';

export interface ValidationError {
  type: 'error' | 'warning';
  message: string;
  personId?: string;
  relationshipId?: string;
}

export function validateFamilyTree(
  persons: Person[],
  relationships: Relationship[]
): ValidationError[] {
  const errors: ValidationError[] = [];
  const personsMap = new Map(persons.map(p => [p.id, p]));
  
  // Validation des références
  for (const rel of relationships) {
    if (!personsMap.has(rel.sourceId)) {
      errors.push({
        type: 'error',
        message: `Relation fait référence à une personne source inexistante (ID: ${rel.sourceId})`,
        relationshipId: rel.id
      });
    }
    
    if (!personsMap.has(rel.targetId)) {
      errors.push({
        type: 'error',
        message: `Relation fait référence à une personne cible inexistante (ID: ${rel.targetId})`,
        relationshipId: rel.id
      });
    }
  }
  
  // Validation des dates
  for (const person of persons) {
    if (person.birthDate && person.deathDate) {
      const birthDate = new Date(person.birthDate);
      const deathDate = new Date(person.deathDate);
      
      if (birthDate > deathDate) {
        errors.push({
          type: 'error',
          message: `Date de naissance postérieure à la date de décès`,
          personId: person.id
        });
      }
    }
    
    if (person.deathDate && person.etat === 'vivant') {
      errors.push({
        type: 'warning',
        message: `Personne marquée comme vivante mais avec une date de décès`,
        personId: person.id
      });
    }
  }
  
  // Validation des relations parent-enfant
  const parentChildRelations = relationships.filter(rel => rel.type === 'parent');
  for (const rel of parentChildRelations) {
    const parent = personsMap.get(rel.sourceId);
    const child = personsMap.get(rel.targetId);
    
    if (parent && child && parent.birthDate && child.birthDate) {
      const parentBirth = new Date(parent.birthDate);
      const childBirth = new Date(child.birthDate);
      
      // Vérifier l'écart minimal entre parent et enfant (ex: 12 ans)
      const minParentAge = 12; // En années
      const minParentAgeMs = minParentAge * 365.25 * 24 * 60 * 60 * 1000;
      
      if (childBirth.getTime() - parentBirth.getTime() < minParentAgeMs) {
        errors.push({
          type: 'warning',
          message: `Le parent ${parent.prenom} ${parent.nom} semble avoir moins de ${minParentAge} ans à la naissance de ${child.prenom} ${child.nom}`,
          relationshipId: rel.id
        });
      }
    }
  }
  
  // Vérification de cycles impossibles (une personne ne peut pas être son propre ancêtre)
  validateNoCycles(relationships, errors);
  
  return errors;
}

function validateNoCycles(relationships: Relationship[], errors: ValidationError[]): void {
  // Construction du graphe orienté pour les relations parent-enfant
  const parentToChildEdges = new Map<string, string[]>();
  
  for (const rel of relationships) {
    if (rel.type === 'parent') {
      if (!parentToChildEdges.has(rel.sourceId)) {
        parentToChildEdges.set(rel.sourceId, []);
      }
      parentToChildEdges.get(rel.sourceId)!.push(rel.targetId);
    }
  }
  
  // Détection de cycle avec un algorithme DFS
  const visited = new Set<string>();
  const recursionStack = new Set<string>();
  
  function checkForCycle(nodeId: string): boolean {
    if (!visited.has(nodeId)) {
      visited.add(nodeId);
      recursionStack.add(nodeId);
      
      const neighbors = parentToChildEdges.get(nodeId) || [];
      for (const neighbor of neighbors) {
        if (!visited.has(neighbor) && checkForCycle(neighbor)) {
          return true;
        } else if (recursionStack.has(neighbor)) {
          errors.push({
            type: 'error',
            message: `Cycle détecté: une personne ne peut pas être son propre ancêtre (ID: ${nodeId})`,
            personId: nodeId
          });
          return true;
        }
      }
    }
    recursionStack.delete(nodeId);
    return false;
  }
  
  // Vérifier chaque nœud
  for (const nodeId of parentToChildEdges.keys()) {
    if (!visited.has(nodeId)) {
      checkForCycle(nodeId);
    }
  }
}// END OF FILE: src/lib/algorithms/validation.ts

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/lib/data/initialFamilyTree.ts

// src/lib/data/initialData.ts
import { FamiliesData, Family } from '../models/Families';
import { Person } from '../models/Person';
import { Relationship } from '../models/Relationship';

// Créer une famille Martin
const familyMartin: Family = {
  id: 'family-martin',
  name: 'Famille Martin',
  description: 'Arbre généalogique de la famille Martin',
  persons: [
    {
      id: "p1",
      nom: "Martin",
      prenom: "Jean",
      sexe: "M",
      birthDate: "1950-05-15",
      deathDate: null,
      etat: "vivant"
    },
    {
      id: "p2",
      nom: "Dupont",
      prenom: "Marie",
      sexe: "F",
      birthDate: "1952-08-22",
      deathDate: null,
      etat: "vivant"
    },
    {
      id: "p3",
      nom: "Martin",
      prenom: "Sophie",
      sexe: "F",
      birthDate: "1975-03-10",
      deathDate: null,
      etat: "vivant"
    },
    {
      id: "p4",
      nom: "Martin",
      prenom: "Paul",
      sexe: "M",
      birthDate: "1978-11-30",
      deathDate: null,
      etat: "vivant"
    },
    {
      id: "p5",
      nom: "Dubois",
      prenom: "Thomas",
      sexe: "M",
      birthDate: "1974-06-18",
      deathDate: null,
      etat: "vivant"
    },
    {
      id: "p6",
      nom: "Martin-Dubois",
      prenom: "Emma",
      sexe: "F",
      birthDate: "2005-04-12",
      deathDate: null,
      etat: "vivant"
    },
    {
      id: "p7",
      nom: "Martin",
      prenom: "Lucas",
      sexe: "M",
      birthDate: "2008-07-23",
      deathDate: null,
      etat: "vivant"
    }
  ],
  relationships: [
    // Jean et Marie sont mariés
    {
      id: "r1",
      type: "conjoint",
      sourceId: "p1",
      targetId: "p2",
      sousType: "marie",
      dateDebut: "1974-06-15",
      dateFin: null
    },
    // Jean est le père de Sophie
    {
      id: "r2",
      type: "parent",
      sourceId: "p1",
      targetId: "p3",
      sousType: "pere",
      dateDebut: null,
      dateFin: null
    },
    // Marie est la mère de Sophie
    {
      id: "r3",
      type: "parent",
      sourceId: "p2",
      targetId: "p3",
      sousType: "mere",
      dateDebut: null,
      dateFin: null
    },
    // Jean est le père de Paul
    {
      id: "r4",
      type: "parent",
      sourceId: "p1",
      targetId: "p4",
      sousType: "pere",
      dateDebut: null,
      dateFin: null
    },
    // Marie est la mère de Paul
    {
      id: "r5",
      type: "parent",
      sourceId: "p2",
      targetId: "p4",
      sousType: "mere",
      dateDebut: null,
      dateFin: null
    },
    // Sophie et Thomas sont mariés
    {
      id: "r6",
      type: "conjoint",
      sourceId: "p3",
      targetId: "p5",
      sousType: "marie",
      dateDebut: "2003-09-20",
      dateFin: null
    },
    // Sophie est la mère d'Emma
    {
      id: "r7",
      type: "parent",
      sourceId: "p3",
      targetId: "p6",
      sousType: "mere",
      dateDebut: null,
      dateFin: null
    },
    // Thomas est le père d'Emma
    {
      id: "r8",
      type: "parent",
      sourceId: "p5",
      targetId: "p6",
      sousType: "pere",
      dateDebut: null,
      dateFin: null
    },
    // Sophie est la mère de Lucas
    {
      id: "r9",
      type: "parent",
      sourceId: "p3",
      targetId: "p7",
      sousType: "mere",
      dateDebut: null,
      dateFin: null
    },
    // Thomas est le père de Lucas
    {
      id: "r10",
      type: "parent",
      sourceId: "p5",
      targetId: "p7",
      sousType: "pere",
      dateDebut: null,
      dateFin: null
    }
  ],
  createdAt: "2025-03-28T10:00:00Z",
  updatedAt: "2025-03-28T10:00:00Z"
};

// Créer une famille Durand
const familyDurand: Family = {
  id: 'family-durand',
  name: 'Famille Durand',
  description: 'Arbre généalogique de la famille Durand',
  persons: [
    {
      id: "d1",
      nom: "Durand",
      prenom: "Pierre",
      sexe: "M",
      birthDate: "1945-10-05",
      deathDate: null,
      etat: "vivant"
    },
    {
      id: "d2",
      nom: "Moreau",
      prenom: "Jeanne",
      sexe: "F",
      birthDate: "1948-04-12",
      deathDate: "2020-08-30",
      etat: "mort"
    },
    {
      id: "d3",
      nom: "Durand",
      prenom: "Marc",
      sexe: "M",
      birthDate: "1970-07-22",
      deathDate: null,
      etat: "vivant"
    },
    {
      id: "d4",
      nom: "Durand",
      prenom: "Claire",
      sexe: "F",
      birthDate: "1972-11-03",
      deathDate: null,
      etat: "vivant"
    }
  ],
  relationships: [
    // Pierre et Jeanne sont mariés
    {
      id: "rd1",
      type: "conjoint",
      sourceId: "d1",
      targetId: "d2",
      sousType: "marie",
      dateDebut: "1969-04-18",
      dateFin: null
    },
    // Pierre est le père de Marc
    {
      id: "rd2",
      type: "parent",
      sourceId: "d1",
      targetId: "d3",
      sousType: "pere",
      dateDebut: null,
      dateFin: null
    },
    // Jeanne est la mère de Marc
    {
      id: "rd3",
      type: "parent",
      sourceId: "d2",
      targetId: "d3",
      sousType: "mere",
      dateDebut: null,
      dateFin: null
    },
    // Pierre est le père de Claire
    {
      id: "rd4",
      type: "parent",
      sourceId: "d1",
      targetId: "d4",
      sousType: "pere",
      dateDebut: null,
      dateFin: null
    },
    // Jeanne est la mère de Claire
    {
      id: "rd5",
      type: "parent",
      sourceId: "d2",
      targetId: "d4",
      sousType: "mere",
      dateDebut: null,
      dateFin: null
    }
  ],
  createdAt: "2025-03-28T11:00:00Z",
  updatedAt: "2025-03-28T11:00:00Z"
};

// Données initiales complètes
export const initialFamiliesData: FamiliesData = {
  families: [familyMartin, familyDurand],
  activeFamilyId: 'family-martin',
  lastUpdated: "2025-03-28T11:00:00Z"
};// END OF FILE: src/lib/data/initialFamilyTree.ts

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/lib/models/Families.ts

// src/lib/models/Families.ts
import { Person } from './Person';
import { Relationship } from './Relationship';

export interface Family {
  id: string;
  name: string;
  description: string;
  persons: Person[];
  relationships: Relationship[];
  createdAt: string;
  updatedAt: string;
  rootPersonId?: string; // Optionnel: personne racine de l'arbre
}

export interface FamiliesData {
  families: Family[];
  activeFamilyId: string | null;
  lastUpdated: string;
}// END OF FILE: src/lib/models/Families.ts

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/lib/models/FamilyTree.ts

// src/lib/models/FamilyTree.ts
import { Person } from './Person';
import { Relationship } from './Relationship';

export interface FamilyTreeMetadata {
  nom: string;
  dateCreation: string;
  dateMiseAJour: string;
}

export interface FamilyTreeData {
  persons: Person[];
  relationships: Relationship[];
  metadata: FamilyTreeMetadata;
}// END OF FILE: src/lib/models/FamilyTree.ts

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/lib/models/Graph.ts

// src/lib/models/Graph.ts
export interface Node {
    id: string;
    label: string;
    // Autres propriétés optionnelles
    [key: string]: any;
  }
  
  export interface Edge {
    source: string;
    target: string;
    // Autres propriétés optionnelles
    [key: string]: any;
  }
  
  /**
   * Classe représentant un graphe générique
   */
  export class Graph {
    private nodes: Map<string, Node> = new Map();
    private adjacencyList: Map<string, Set<string>> = new Map();
    private edges: Edge[] = [];
    directed: boolean;
    
    constructor(directed: boolean = false) {
      this.directed = directed;
    }
    
    /**
     * Ajoute un nœud au graphe
     */
    addNode(node: Node): void {
      this.nodes.set(node.id, node);
      if (!this.adjacencyList.has(node.id)) {
        this.adjacencyList.set(node.id, new Set());
      }
    }
    
    /**
     * Ajoute une arête au graphe
     */
    addEdge(edge: Edge): void {
      // Vérifier que les nœuds existent
      if (!this.nodes.has(edge.source) || !this.nodes.has(edge.target)) {
        throw new Error(`Les nœuds ${edge.source} ou ${edge.target} n'existent pas`);
      }
      
      // Ajouter l'arête
      this.edges.push(edge);
      
      // Mettre à jour la liste d'adjacence
      this.adjacencyList.get(edge.source)!.add(edge.target);
      
      // Si le graphe n'est pas dirigé, ajouter l'arête inverse
      if (!this.directed) {
        this.adjacencyList.get(edge.target)!.add(edge.source);
      }
    }
    
    /**
     * Récupère tous les nœuds du graphe
     */
    getNodes(): Node[] {
      return Array.from(this.nodes.values());
    }
    
    /**
     * Récupère toutes les arêtes du graphe
     */
    getEdges(): Edge[] {
      return this.edges;
    }
    
    /**
     * Récupère les voisins d'un nœud
     */
    getNeighbors(nodeId: string): Set<string> {
      return this.adjacencyList.get(nodeId) || new Set();
    }
    
    /**
     * Crée un graphe à partir d'une matrice d'adjacence
     */
    static fromAdjacencyMatrix(matrix: number[][], nodeLabels?: string[]): Graph {
      const graph = new Graph(true); // Par défaut dirigé
      
      // Créer les nœuds
      for (let i = 0; i < matrix.length; i++) {
        const label = nodeLabels && i < nodeLabels.length ? nodeLabels[i] : `Node ${i}`;
        graph.addNode({ id: i.toString(), label });
      }
      
      // Créer les arêtes
      for (let i = 0; i < matrix.length; i++) {
        for (let j = 0; j < matrix[i].length; j++) {
          if (matrix[i][j] !== 0) {
            graph.addEdge({ 
              source: i.toString(), 
              target: j.toString(),
              weight: matrix[i][j]
            });
          }
        }
      }
      
      return graph;
    }
    
    /**
     * Crée un graphe à partir d'une liste d'adjacence
     */
    static fromAdjacencyList(adjList: { [key: string]: string[] }, nodeLabels?: { [key: string]: string }): Graph {
      const graph = new Graph(true); // Par défaut dirigé
      
      // Créer les nœuds
      Object.keys(adjList).forEach(nodeId => {
        const label = nodeLabels ? nodeLabels[nodeId] : `Node ${nodeId}`;
        graph.addNode({ id: nodeId, label });
      });
      
      // S'assurer que tous les nœuds cibles existent également
      Object.values(adjList).flat().forEach(nodeId => {
        if (!graph.nodes.has(nodeId)) {
          const label = nodeLabels ? nodeLabels[nodeId] : `Node ${nodeId}`;
          graph.addNode({ id: nodeId, label });
        }
      });
      
      // Créer les arêtes
      Object.entries(adjList).forEach(([nodeId, neighbors]) => {
        neighbors.forEach(neighborId => {
          graph.addEdge({ source: nodeId, target: neighborId });
        });
      });
      
      return graph;
    }
  }// END OF FILE: src/lib/models/Graph.ts

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/lib/models/GraphWeighted.ts

// src/lib/models/GraphWeighted.ts
export interface Node {
    id: string;
    label: string;
    // Autres propriétés optionnelles
    [key: string]: any;
  }
  
  export interface Edge {
    source: string;
    target: string;
    weight: number;
    // Autres propriétés optionnelles
    [key: string]: any;
  }
  
  /**
   * Classe représentant un graphe pondéré
   */
  export class GraphWeighted {
    private nodes: Map<string, Node> = new Map();
    private adjacencyList: Map<string, Map<string, number>> = new Map();
    private edges: Edge[] = [];
    directed: boolean;
    
    constructor(directed: boolean = false) {
      this.directed = directed;
    }
    
    /**
     * Ajoute un nœud au graphe
     */
    addNode(node: Node): void {
      this.nodes.set(node.id, node);
      if (!this.adjacencyList.has(node.id)) {
        this.adjacencyList.set(node.id, new Map());
      }
    }
    
    /**
     * Ajoute une arête au graphe avec un poids
     */
    addEdge(edge: Edge): void {
      // Vérifier que les nœuds existent
      if (!this.nodes.has(edge.source) || !this.nodes.has(edge.target)) {
        throw new Error(`Les nœuds ${edge.source} ou ${edge.target} n'existent pas`);
      }
      
      // Ajouter l'arête
      this.edges.push(edge);
      
      // Mettre à jour la liste d'adjacence avec le poids
      this.adjacencyList.get(edge.source)!.set(edge.target, edge.weight);
      
      // Si le graphe n'est pas dirigé, ajouter l'arête inverse
      if (!this.directed) {
        this.adjacencyList.get(edge.target)!.set(edge.source, edge.weight);
      }
    }
    
    /**
     * Vérifie si une arête existe entre deux nœuds
     */
    hasEdge(sourceId: string, targetId: string): boolean {
      return this.adjacencyList.get(sourceId)?.has(targetId) || false;
    }
    
    /**
     * Récupère le poids d'une arête entre deux nœuds
     */
    getEdgeWeight(sourceId: string, targetId: string): number | undefined {
      return this.adjacencyList.get(sourceId)?.get(targetId);
    }
    
    /**
     * Récupère tous les nœuds du graphe
     */
    getNodes(): Node[] {
      return Array.from(this.nodes.values());
    }
    
    /**
     * Récupère toutes les arêtes du graphe
     */
    getEdges(): Edge[] {
      return this.edges;
    }
    
    /**
     * Récupère les voisins d'un nœud avec leurs poids
     */
    getNeighborsWithWeights(nodeId: string): Map<string, number> {
      return this.adjacencyList.get(nodeId) || new Map();
    }
    
    /**
     * Récupère juste les IDs des voisins d'un nœud
     */
    getNeighbors(nodeId: string): string[] {
      return Array.from(this.adjacencyList.get(nodeId)?.keys() || []);
    }
    
    /**
     * Crée un graphe à partir d'une matrice d'adjacence pondérée
     */
    static fromAdjacencyMatrix(matrix: number[][], nodeLabels?: string[]): GraphWeighted {
      const graph = new GraphWeighted(true); // Par défaut dirigé
      
      // Créer les nœuds
      for (let i = 0; i < matrix.length; i++) {
        const label = nodeLabels && i < nodeLabels.length ? nodeLabels[i] : `Node ${i}`;
        graph.addNode({ id: i.toString(), label });
      }
      
      // Créer les arêtes
      for (let i = 0; i < matrix.length; i++) {
        for (let j = 0; j < matrix[i].length; j++) {
          if (matrix[i][j] !== 0) {
            graph.addEdge({ 
              source: i.toString(), 
              target: j.toString(),
              weight: matrix[i][j]
            });
          }
        }
      }
      
      return graph;
    }
    
    /**
     * Crée un graphe à partir d'une liste d'adjacence pondérée
     * Format: A: B(5), C(3) - signifie A est connecté à B avec poids 5 et à C avec poids 3
     */
    static fromAdjacencyList(adjList: string[], nodeLabels?: { [key: string]: string }): GraphWeighted {
      const graph = new GraphWeighted(true); // Par défaut dirigé
      const edgePattern = /(\w+)\s*\(\s*(-?\d+(?:\.\d+)?)\s*\)/;
      
      // Extraire les nœuds et leurs connexions
      const connections: { [source: string]: { target: string, weight: number }[] } = {};
      
      adjList.forEach(line => {
        const parts = line.split(':');
        if (parts.length !== 2) return;
        
        const source = parts[0].trim();
        const neighborsStr = parts[1].trim();
        const neighbors: { target: string, weight: number }[] = [];
        
        // Extraire les voisins et leurs poids
        const neighborsList = neighborsStr.split(',');
        neighborsList.forEach(neighbor => {
          neighbor = neighbor.trim();
          const match = neighbor.match(edgePattern);
          
          if (match) {
            // Format avec poids explicite: B(5)
            const target = match[1];
            const weight = parseFloat(match[2]);
            neighbors.push({ target, weight });
          } else {
            // Format sans poids: B
            const target = neighbor;
            neighbors.push({ target, weight: 1 }); // Poids par défaut: 1
          }
        });
        
        connections[source] = neighbors;
        
        // Ajouter le nœud source
        if (!graph.nodes.has(source)) {
          const label = nodeLabels ? nodeLabels[source] : source;
          graph.addNode({ id: source, label });
        }
      });
      
      // Ajouter tous les nœuds cibles également
      Object.values(connections).flat().forEach(({ target }) => {
        if (!graph.nodes.has(target)) {
          const label = nodeLabels ? nodeLabels[target] : target;
          graph.addNode({ id: target, label });
        }
      });
      
      // Ajouter les arêtes
      Object.entries(connections).forEach(([source, neighbors]) => {
        neighbors.forEach(({ target, weight }) => {
          graph.addEdge({
            source,
            target,
            weight
          });
        });
      });
      
      return graph;
    }
    
    /**
     * Vérifie si le graphe est valide pour l'algorithme de Dijkstra
     * (pas de poids négatifs)
     */
    isDijkstraCompatible(): boolean {
      return !this.edges.some(edge => edge.weight < 0);
    }
    
    /**
     * Récupère le poids minimum et maximum des arêtes
     */
    getWeightRange(): { min: number, max: number } {
      if (this.edges.length === 0) {
        return { min: 0, max: 0 };
      }
      
      let min = this.edges[0].weight;
      let max = this.edges[0].weight;
      
      this.edges.forEach(edge => {
        min = Math.min(min, edge.weight);
        max = Math.max(max, edge.weight);
      });
      
      return { min, max };
    }
  }// END OF FILE: src/lib/models/GraphWeighted.ts

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/lib/models/Person.ts

// src/lib/models/Person.ts
export interface Person {
    id: string;
    nom: string;
    prenom: string;
    sexe: "M" | "F" | "A";  // M = Masculin, F = Féminin, A = Autre
    birthDate: string | null;
    deathDate: string | null;
    etat: "vivant" | "mort";
  }// END OF FILE: src/lib/models/Person.ts

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/lib/models/Relationship.ts

// src/lib/models/Relationship.ts
export type RelationType = "parent" | "conjoint" | "enfant";
export type RelationSubType = "pere" | "mere" | "adoptif" | "marie" | "non_marie" | "biologique" | "adopte";

export interface Relationship {
  id: string;
  type: RelationType;
  sourceId: string;  // ID de la personne source
  targetId: string;  // ID de la personne cible
  sousType: RelationSubType;
  dateDebut: string | null;
  dateFin: string | null;
}// END OF FILE: src/lib/models/Relationship.ts

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/lib/models/User.ts

// END OF FILE: src/lib/models/User.ts

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/lib/services/authService.ts

// END OF FILE: src/lib/services/authService.ts

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/lib/services/familyService.ts

// END OF FILE: src/lib/services/familyService.ts

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/lib/services/graphService.ts

// END OF FILE: src/lib/services/graphService.ts

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/lib/services/storageService.ts

// storageService.ts
import { FamilyTreeData } from '../models/FamilyTree';


export async function saveFamilyTree(familyTree: FamilyTreeData): Promise<void> {
    localStorage.setItem('familyTree', JSON.stringify(familyTree));
  }
  
  export async function loadFamilyTree(): Promise<FamilyTreeData | null> {
    const data = localStorage.getItem('familyTree');
    if (!data) {
      return null;
    }
    return JSON.parse(data) as FamilyTreeData;
  }
  
  // Initialisation avec les données par défaut
  export async function initializeIfEmpty(): Promise<FamilyTreeData> {
    const existingData = await loadFamilyTree();
    if (existingData) {
      return existingData;
    }
    
    // Importer les données initiales
    const { initialFamilyTreeData } = await import('../data/initialFamilyTree');
    await saveFamilyTree(initialFamilyTreeData);
    return initialFamilyTreeData;
  }// END OF FILE: src/lib/services/storageService.ts

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/lib/utils/dateUtils.ts

// src/lib/utils/dateUtils.ts
import { Person } from '../models/Person';

export function calculateAge(person: Person): number {
  if (!person.birthDate) return 0;
  
  const birthDate = new Date(person.birthDate);
  const endDate = person.etat === 'mort' && person.deathDate 
    ? new Date(person.deathDate) 
    : new Date();
  
  const ageMs = endDate.getTime() - birthDate.getTime();
  const ageDate = new Date(ageMs);
  return Math.abs(ageDate.getUTCFullYear() - 1970);
}// END OF FILE: src/lib/utils/dateUtils.ts

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/src/lib/utils/validation.ts

// END OF FILE: src/lib/utils/validation.ts

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/tailwind.config.js

// tailwind.config.js
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: ['./src/**/*.{html,js,ts,jsx,tsx}'],
  theme: {
    extend: {
      colors: {
        primary: 'rgb(var(--primary-color))',
        secondary: 'rgb(var(--secondary-color))',
      },
    },
  },
  plugins: [],
}// END OF FILE: tailwind.config.js

//---> PATH: /media/kenfack/DAE4F205E4F1E3A3/4GI/semestre_2/recherche_operationnelle/tp/arbre_genealogique/tsconfig.json

{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
// END OF FILE: tsconfig.json

